/*
 Name:          BlazorFormManager
 Version:       1.8.0
 Author:        Abdourahamane Kaba
 Description:   Handle AJAX form data submission with zero or more files, and
                report back data upload activities to a .NET Blazor Component.
 License:       Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
 Copyright:     © Numeric Horizon LLC. All rights reserved.
 */
(function (global) {
    // "use strict";
    const XHRSTATE = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 };
    const CONSOLE_FUNC = { info: "info", warn: "warn", error: "error", log: "log" };
    const LOG_LEVEL = { none: 0, information: 1, warning: 2, error: 3, debug: 4 };
    const UPLOAD_EVENTS = { loadstart: 0, progress: 1, load: 2, error: 3, abort: 4, timeout: 5, loadend: 6 };
    const PRIMITIVES = ["string", "number", "bigint", "boolean"];
    const FILE_READER_FUNC = { 1: "readAsArrayBuffer", 2: "readAsBinaryString", 3: "readAsDataURL", 4: "readAsText", 5: "enumerate" };
    const READ_FILE_LIST_EVENTS = { start: 0, rejected: 1, processed: 2, end: 3 };
    const READ_FILE_LIST_REJECTION = { none: 0, extension: 1, type: 2, multiple: 3, aborted: 4 };
    const DROP_EFFECTS = { none: 0, copy: 1, link: 2, move: 3 };
    const DROP_EFFECTS_ALLOWED = { none: 0, copy: 1, copyLink: 2, copyMove: 3, link: 4, linkMove: 5, move: 6, all: 7, uninitialized: 8 };
    const FILTER_KEY_TYPES = { none: 0, alpha: 1, alphaNumeric: 2, digits: 3 };

    const SIZE_KB = 1024;
    const SIZE_MB = SIZE_KB * SIZE_KB;
    const SIZE_GB = SIZE_KB * SIZE_MB;
    const SIZE_TB = SIZE_KB * SIZE_GB;

    const _defaultImagePreviewOptions = {
        autoGenerate: true,
        generateFileInfo: true,
        attributeName: "src",
        tagName: "img",
        tagClass: "blazor-form-manager-image-preview",
        autoGeneratedClass: "form-manager-auto-generated",
        wrapperSelector: ".image-wrapper",
        width: 150,
        height: 0,
        preserveAspectRatio: true,
        noResize: false,
    };

    const _dotnet = global.DotNet;
    const _document = global.document;
    const _supportsAJAXwithUpload = supportsAjaxUploadWithProgress();
    const _supportsFileReader = !!global.FileReader;
    const _dragDropStorage = {};
    const _processedFileStorage = {};
    const _imageUtilAvailable = supportsImageUtil();

    /** Dictionary containing configuration options for all forms */
    const _formsOptions = {};

    /** Field required to abort the readFileList function. */
    let _readFileListAborted = false;

    /**
     * ReCaptchaOptions { siteKey: string; verificationTokenName: string; version: string; allowLocalHost: boolean }
     * */

    /** Structure of a FileReaderOptions object
    {
        formId: string, inputId: string, inputName: string, accept: string, acceptType: string, multiple: boolean, createObjectUrl: boolean,
        method: { readAsArrayBuffer: 1, readAsBinaryString: 2, readAsDataURL: 3, readAsText: 4, enumerate: 5 },
        imagePreviewOptions: {
            autoGenerate: boolean, generateFileInfo: boolean, tagName: string, tagClass: string, tagId: string,
            attributeName: string, wrapperSelector: string, width: number, height: number, noResize: boolean,
            preserveAspectRatio: boolean
        }
    };
    */

    const RECAPTCHA_SCRIPT_BASE_URL = 'https://www.google.com/recaptcha/api.js';
    const _greCAPTCHA = {
        callbacks: {},
        scripts: {
            v1: '',
            v2: RECAPTCHA_SCRIPT_BASE_URL + '?onload=BlazorFormManagerReCaptchaOnload&render=explicit',
            v3: RECAPTCHA_SCRIPT_BASE_URL + '?render=',
            inserted: false,
            inserting: false
        }
    };

    global.BlazorFormManager = {
        init: async function (options) {
            if (!updateOptions(options) || !_isString(options.formId))
                return showOptionsUsage(true);

            const { objInstanceRef, formId } = options;
            logDebug(formId, "Initializing with options:", options);

            if (!validateFormAttributes(formId)) {
                return false;
            }

            if (!!objInstanceRef) {
                logDebug(formId, "Invokable object instance reference received.", objInstanceRef);
            } else {
                logWarning(formId, "Invokable object instance reference not received. " +
                    "This is the preferred way of invoking.NET methods from " +
                    "withing Blazor components.");
            }

            registerSubmitHandler(options);
            logInfo(formId, "Initialized successfully!");
            return true;
        },
        setLogLevel: function ({ formId, logLevel: level }) {
            const options = _formsOptions[formId];
            if (!!options) {
                if (options.logLevel !== level) {
                    if (typeof level === "number") {
                        const validLevel = 0 | level; // force the number to be an integer
                        if (validLevel > -1 && validLevel < 5) {
                            options.logLevel = validLevel;
                            logInfo(formId, "Log level changed to", validLevel);
                            return true;
                        }
                    }
                    logError(formId, "Log level must be an integer between 0 and 4 inclusive.");
                }
            } else {
                logError(formId, `The form #${formId} has not been initialized yet.`);
            }
            return false;
        },
        updateOptions,
        raiseAjaxUploadWithProgressNotSupported,
        submitForm: function (formId) {
            logDebug(formId, "Form submit requested.", formId);

            const form = document.getElementById(formId);

            if (!form) {
                logInfo(formId, `Form #${formId} not defined`);
                return false;
            }

            if (!!form.onsubmit) {
                form.onsubmit();
                logInfo(formId, "Form submitted via 'BlazorFormManager.submitForm'.")
                return true;
            }

            logDebug(formId, `'onsubmit' event handler not defined for form #${formId}.`);
            return false;
        },
        localStorageSetItem: function (key, value) {
            localStorage.setItem(key, value);
        },
        localStorageRemoveItem: function (key) {
            localStorage.removeItem(key);
        },
        localStorageGetItem: function (key) {
            return localStorage.getItem(key);
        },

        readInputFiles: function (options) {
            return readInputFiles(options, processedFiles => {
                const { formId, inputId, inputName } = options;
                logDebug(formId, "Received processed files.");

                if (processedFiles && processedFiles.length > 0) {
                    logDebug(formId, "Storing processed files...");
                    // store files that have been processed so that they can be 
                    // used later to validate when the form is being submitted
                    let config = _processedFileStorage[formId];

                    if (!config) {
                        // create the configuration
                        config = {
                            inputs: []
                        }
                        _processedFileStorage[formId] = config;
                    }

                    const input = config.inputs.find(obj => obj.id === inputId);

                    // update the configuration
                    if (!input) {
                        config.inputs.push({
                            id: inputId,
                            name: inputName,
                            files: processedFiles
                        });
                        logDebug(formId, "Created processed files configuration.");
                    } else {
                        input.files = processedFiles;
                        logDebug(formId, "Updated processed files configuration.");
                    }
                } else {
                    logDebug(formId, "No files processed!");
                }
            });
        },

        deleteProcessedFileList,

        dragDropEnable,
        dragDropDisable,
        dragDropRemoveFileList,
        dragDropInputFilesOnTarget,

        /**
         * Register the specified .NET assembly for JSInterop.
         * @param {string} assembly The assembly in which the static .NET method is to be invoked.
         */
        registerInteropAssembly: function (assembly) {
            if (!_isString(_formsOptions.assembly)) {
                if (!_isString(assembly)) {
                    logError(null, "No assembly specified for JavaScript Interop.");
                    return false;
                }

                _formsOptions.assembly = assembly;
                return true;
            } else {
                logDebug(null, `An assembly named '${_formsOptions.assembly}' has already been registered.`);
            }
            return false;
        },

        /**
         * Blocks unwanted key strokes.
         * @param {object} options An configuration object with the following properties:
         * targetId, eventType, callback, filter.
         */
        filterKeys,

        /**
         * Adds an event handler to the specified element identifier.
         * @param {string} targetId The DOM element identifier to which to add the event listener.
         * @param {string} eventType The type of event to be added (e.g. 'keypress', 'load', etc.).
         * @param {string} callback A static .NET method delegate to invoke.
         */
        addEventListener,
        removeEventListener
    };

    /**
     * Register an AJAX handler for the submission of a form.
     * @param {object} options An object used to register the form submit handler.
     */
    function registerSubmitHandler(options) {
        const {
            formId,
            onGetModel,
            onBeforeSubmit,
            onBeforeSend,
            onSendFailed,
            onSendSucceeded,
            requireModel,
            reCaptcha
        } = options;

        if (_isObject(reCaptcha)) {
            configureReCaptcha(options);
        }

        handleFormSubmission({
            formId,
            requireModel,
            reCaptcha,
            getFormData: async () => {
                // custom routine for retrieving form data defined with models
                let model;

                if (_isString(onGetModel)) {
                    model = await invokeDotNet(formId, onGetModel);
                    logDebug(formId, "Model", model);
                }

                if (model === null) {
                    if (requireModel) {
                        logError(formId, "A model is required.");
                    } else {
                        logDebug(formId, "Model not defined. FormData will be collected by caller.");
                    }
                    return { formData: null, hasFiles: false, json: false };
                }

                logDebug(formId, "Collecting form model data...");

                // collect existing inputs from the form
                const form = _document.getElementById(formId);
                const enctype = form.getAttribute("enctype") || '';
                // check if the form contains any files
                const hasFiles = containsFiles(form);

                logDebug(formId, "Form enctype is:", enctype);

                if (enctype.toLowerCase().indexOf('json') > -1) {
                    if (hasFiles)
                        logWarning(formId, "The form contains files which cannot be sent using the JSON format.");
                    else
                        logDebug(formId, "Collecting form model data as JSON...");
                    // send as JSON
                    return { formData: JSON.stringify(model), hasFiles, json: true };
                } else {
                    const formData = new FormData(form);
                    // add additional form data values using the model...
                    collectModelData(model, formData);

                    return { formData, hasFiles, json: false };
                }
            },
            beforeSubmit: async function () {
                let cancel = false;
                if (_isString(onBeforeSubmit))
                    cancel = await invokeDotNet(formId, onBeforeSubmit);
                return cancel;
            },
            beforeSend: async function () {
                let cancel = false;
                if (_isString(onBeforeSend))
                    cancel = await invokeDotNet(formId, onBeforeSend,
                        getXhrResult.call(this, true)
                    );
                return cancel;
            },
            done: function () {
                logInfo(formId, "Form data successfully uploaded.", this);

                if (_isString(onSendSucceeded))
                    invokeDotNet(formId, onSendSucceeded,
                        getXhrResult.call(this, false)
                    );

                // eventually free up the processed file storage for this form
                deleteProcessedFileList({ formId });
            },
            fail: function (error) {
                logError(formId, "Form upload failed.");
                logDebug(formId, "XHR", this);

                if (_isString(onSendFailed))
                    invokeDotNet(formId, onSendFailed,
                        getXhrResult.call(this, false, error)
                    );

                resetReCaptcha(formId, reCaptcha);
            }
        });

        /**
         * Retrieve the XHR result
         * @param {boolean} excludeHeaders Whether to exclude all response headers.
         * @param {any} error The error might have occurred.
         */
        function getXhrResult(excludeHeaders, error) {
            /** @param {XMLHttpRequest}  */
            const xhr = this;

            const extraProperties = { error };
            const response = xhr.response || null;
            const responseHeaders = excludeHeaders ? null : xhr.getAllResponseHeaders() + "";
            const status = 0 | xhr.status;
            const statusText = xhr.statusText + "" || "";
            const timeout = 0 | xhr.timeout;

            // these properties may throw an "InvalidStateError" DOMException
            let responseText = '', responseType = '', responseXML = '';

            // so we safely access them
            try { responseText = xhr.responseText || ''; } catch { }
            try { responseType = xhr.responseType || ''; } catch { }
            try { responseXML = xhr.responseXML && xhr.responseXML.textContent || null; } catch { }

            return {
                response,
                responseHeaders,
                responseText,
                responseType,
                responseXML,
                status,
                statusText,
                timeout,
                extraProperties,
            };
        }
    }

    function configureReCaptcha(options) {
        const { formId, reCaptcha } = options;
        const { scripts } = _greCAPTCHA;

        if (!(scripts.inserted || scripts.inserting)) {

            const document = global.document;

            const {
                siteKey,
                version,
                verificationTokenName,
                theme: them,
                languageCode,
                invisible,
                size: sz,
                cssSelector
            } = reCaptcha;

            const ver = (version + '' || '').toLowerCase();

            let url = scripts[ver] + '';
            let success = false;

            if (!_isString(url)) {
                const message = `Unsupported reCAPTCHA version: ${ver}`;
                logError(formId, message);
                reportRecaptchaActivity(formId, { message, type: 'danger' });
            } else {
                if (ver === 'v2') {
                    // register version 2 callback for this form
                    const { callbacks } = _greCAPTCHA;
                    const cbConfig = {};

                    // reCAPTCHA execution callback used to 
                    // collect the token and submit the form
                    cbConfig.setTokenCallback = function (token) {
                        logDebug(formId, 'reCAPTCHA token received; preparing to submit the form.', token);

                        if (invisible) {
                            // these properties must be set in the 'handleFormSubmission' 
                            // function when the form is being submitted
                            const { xhr, formData } = cbConfig;

                            if (xhr && formData) {
                                reportRecaptchaActivity(formId);
                                formData.set(verificationTokenName, token);
                                formData.set('g-recaptcha-version', ver);
                                xhr.send(formData);
                            } else {
                                const message = 'reCAPTCHA: xhr and formData properties not set.';
                                logError(formId, message);
                                reportRecaptchaActivity(formId, { message, type: 'danger' });
                            }
                        } else {
                            // store the token; it will be used when sending the form
                            cbConfig['token'] = token;

                            // clear previous (danger|warning, etc.) message
                            reportRecaptchaActivity(formId);
                        }
                    };

                    callbacks[formId] = cbConfig;

                    if (!global.BlazorFormManagerReCaptchaOnload) {
                        // fired when reCAPTCHA is ready
                        global.BlazorFormManagerReCaptchaOnload = function () {
                            const selector = cssSelector || '.g-recaptcha';
                            const form = document.getElementById(formId);
                            const elements = form && form.querySelectorAll(selector) || [];

                            const count = elements.length;

                            if (count > 0) {
                                logDebug(formId, `${count} HTML element(s) with ${selector} CSS selector found.`);

                                let hl = '', size = sz, theme = them;

                                if (languageCode)
                                    hl = languageCode;

                                if (invisible)
                                    reCaptcha['size'] = size = 'invisible';
                                else if (!_isString(size))
                                    reCaptcha['size'] = size = 'normal';

                                if (!_isString(theme))
                                    theme = 'light';

                                const parameters = {
                                    hl,
                                    size,
                                    theme,
                                    'sitekey': siteKey,
                                    'callback': cbConfig.setTokenCallback
                                };

                                // since a reCAPTCHA response is verified only once,
                                // we have to store the rendered widget IDs so that 
                                // we can reset it later, should the submission fail
                                const widgets = [];

                                for (let i = 0; i < count; i++) {
                                    // grecaptcha.render returns an ID for each created widget
                                    const wid = global.grecaptcha.render(
                                        elements[i],
                                        parameters
                                    );

                                    widgets.push(wid);
                                }

                                cbConfig['widgets'] = widgets;
                            } else {
                                logError(formId, `No HTML element with ${selector} CSS selector found.`);
                            }
                        };
                    }
                }

                if (ver === 'v3') url += siteKey;

                if (!(scripts.inserted || scripts.inserting)) {
                    scripts.inserting = true;
                    logDebug(formId, 'Inserting reCAPTCHA script tag...', url);

                    const s = document.createElement('script');

                    s.async = true;
                    s.defer = true;
                    s.src = url;

                    const heads = document.getElementsByTagName('head');

                    if (heads.length === 0) {
                        const h = document.createElement('head');
                        document.appendChild(h);
                        h.appendChild(s);
                    } else {
                        heads[0].appendChild(s);
                    }

                    logDebug(formId, 'reCAPTCHA script tag inserted successfully!');

                    scripts.inserted = true;
                    scripts.inserting = false;
                }

                success = true;
            }

            return success;
        }
    }

    function resetReCaptcha(formId, reCaptcha) {
        if (!reCaptcha) return;

        const { grecaptcha } = global;

        if (!grecaptcha) return;

        const { version } = reCaptcha;
        const ver = version.toLowerCase();

        // version 3 is executed when the form is submitted
        if (ver === 'v3') return; 

        // get the widget identifers that have been rendered
        const { widgets } = _greCAPTCHA.callbacks[formId] || {};

        if (widgets instanceof Array && widgets.length) {

            for (var i = 0; i < widgets.length; i++)
                grecaptcha.reset(widgets[i]);
            
            const message = `reCAPTCHA was reset.`;
            logDebug(formId, message);

            reportRecaptchaActivity(formId, { message, type: 'warning' });
        }
    }

    /**
     * Report an activity related to Google's reCAPTCHA technology.
     * @param {any} formId The form identifier.
     * @param {{ message: string, type: string, data: string }} activity The activity to report.
     */
    function reportRecaptchaActivity(formId, activity) {
        const { onReCaptchaActivity } = _formsOptions[formId] || {};
        if (_isString(onReCaptchaActivity)) {
            if (!activity)
                activity = { message: '', type: '', data: null };
            if (activity.data === undefined)
                activity.data = null;
            invokeDotNet(formId, onReCaptchaActivity, activity);
        }
    }

    function handleFormSubmission(options) {
        options || (options = {});
        const { formId, requireModel, reCaptcha } = options;

        if (!formId) {
            logError(formId, "No form to upload identified!");
            return false;
        }

        const form = _document.getElementById(formId);
        if (!form) {
            logError(formId, `Form with id #${formId} not found!`);
            return false;
        }

        form.onsubmit = async () => {
            logDebug(formId, "Submitting form...");
            let cancel = false;
            const { beforeSubmit } = options;

            if (_isFunction(beforeSubmit)) cancel = await beforeSubmit.call(form);

            if (cancel) {
                logInfo(formId, "Form submissing was cancelled.");
                return false;
            }

            // With nowadays (modern) browsers, this is VERY unlikely, but just in case...
            if (!_supportsAJAXwithUpload) {
                logWarning(formId, "AJAX upload with progress report not supported.");

                cancel = await raiseAjaxUploadWithProgressNotSupported(formId);

                if (cancel) {
                    // do not allow full page refresh
                    logInfo(formId, "Blocked submitting form with full-page refresh.");
                    return false;
                }

                // allow normal form submission (post back with full page refresh)
                return true;
            }

            const { beforeSend, done, fail, getFormData } = options;
            let { formData, hasFiles, json } = await getFormData();

            if (formData === null || formData === undefined) {
                if (requireModel) {
                    logError(formId, "Form submission cancelled because a model is required to continue.");
                    return false;
                } else {
                    formData = new FormData(form);
                    hasFiles = containsFiles(form);
                }
            }

            if (!json) {
                if (clearFilesAppendProcessed(formId, formData)) {
                    hasFiles = true;
                }
            }

            const xhr = new XMLHttpRequest();

            xhr.onreadystatechange = function () {
                if (this.readyState === XHRSTATE.DONE) {
                    // any status code between 200 and 299 inclusive is success
                    if (this.status > 199 && this.status < 300) {
                        if (_isFunction(done)) done.call(this);
                    } else if (_isFunction(fail)) {
                        fail.call(this);
                    }
                }
            };

            addXHRUploadEventListeners(formId, xhr, hasFiles);

            const url = form.getAttribute("action") || global.location.href;
            const method = (form.getAttribute("method") || "POST").toUpperCase();

            logDebug(formId, "Form action URL is:", url);
            logDebug(formId, "Form method is:", method);

            xhr.open(method, url, true);

            let headersSet = false;

            if (_isFunction(beforeSend)) {
                const xhrResult = await beforeSend.call(xhr);
                logDebug(formId, "beforeSend was called:", xhrResult);

                if (_isObject(xhrResult)) {
                    if (xhrResult.cancel) {
                        logDebug(formId, "XMLHttpRequest.send was cancelled.");
                        return false;
                    }

                    logDebug(formId, "Trying to set XMLHttpRequest (XHR) properties...");
                    try {
                        headersSet = setRequestHeaders(formId, xhr, xhrResult.requestHeaders);
                        xhr.withCredentials = xhrResult.withCredentials;
                    } catch (e) {
                        logError(formId, "Error setting XHR properties.", e);
                        if (_isFunction(fail)) fail.call(xhr, e.message);
                        return false;
                    }
                }
            }

            if (!headersSet)
                setRequestHeaders(formId, xhr, _formsOptions[formId].requestHeaders);

            if (json) {
                setRequestHeaders(formId, xhr, { 'content-type': 'application/json', accept: 'application/json; text/plain' });
            }

            adjustBadFormDataKeys(formData);

            const grecaptcha = global.grecaptcha;
            const { siteKey, version, verificationTokenName, allowLocalHost, invisible, size } = reCaptcha || {};

            if (_isString(siteKey) && grecaptcha) {
                if (!allowLocalHost && global.location.hostname.toLowerCase().startsWith('localhost')) {
                    const message = "reCAPTCHA not allowed on localhost; sending form with XHR.";
                    logWarning(formId, message);
                    reportRecaptchaActivity(formId, { message, type: 'warning' });
                    xhr.send(formData);
                } else {
                    let ver = version.toLowerCase();
                    logDebug(formId, "Trying to submit form with reCAPTCHA version " + ver);

                    if (ver === 'v2') {
                        const cbConfig = _greCAPTCHA.callbacks[formId];

                        if (!cbConfig) {
                            const message = 'No callback for reCAPTCHA v2 has been ' +
                            'configured for this form; submitting without the challenge.';

                            logWarning(formId, message);
                            reportRecaptchaActivity(formId, { message, type: 'warning' });
                            xhr.send(formData);
                        } else {
                            if (invisible || size === 'invisible') {
                                // set these properties so that the reCAPTCHA 
                                // callback may use them to send the request
                                cbConfig['xhr'] = xhr;
                                cbConfig['formData'] = formData;

                                // execution, if successful, will delegate the form submission
                                grecaptcha.execute();
                            } else {
                                const token = cbConfig.token || '';
                                if (!_isString(token)) {
                                    const message = "Please make sure to complete the reCAPTCHA challenge!";
                                    logError(formId, message);
                                    reportRecaptchaActivity(formId, { message, type: 'danger' });
                                } else {
                                    formData.set(verificationTokenName, token);
                                    formData.set('g-recaptcha-version', ver);
                                    xhr.send(formData);
                                }
                            }
                        }
                    } else if (ver === 'v3') {
                        grecaptcha.ready(function () {
                            grecaptcha.execute(siteKey, { action: 'submit' }).then(function (token) {
                                const message = "reCAPTCHA token received.";
                                logDebug(formId, message);
                                reportRecaptchaActivity(formId, { message, type: 'info', data: token });
                                formData.set(verificationTokenName, token);
                                formData.set('g-recaptcha-version', ver);
                                xhr.send(formData);
                            });
                        });
                    } else {
                        const message = 'Unsupported reCAPTCHA version: ' + ver;
                        logWarning(formId, message);
                        reportRecaptchaActivity(formId, { message, type: 'warning', data: ver });
                        xhr.send(formData);
                    }
                }
            } else {
                xhr.send(formData);
            }

            return false; // To avoid actual submission of the form
        }
        return true;
    }

    /**
     * Remove inappropriate form data keys.
     * @param {FormData} formData The form data to clean up.
     */
    function adjustBadFormDataKeys(formData) {
        const RVT_KEY1 = '__RequestVerificationToken';
        const RVT_KEY2 = 'requestVerificationToken';

        const rvt1 = formData.get(RVT_KEY1);
        const rvt2 = formData.get(RVT_KEY2);

        if (!_isString(rvt1))
            formData.set(RVT_KEY1, rvt2);

        formData.delete(RVT_KEY2);
    }

    function showOptionsUsage(isError) {
        const optionalNameOfMethodWhen = "string (optional): The name of the .NET method to invoke when ";
        const options = {
            formId: "string (required): The unique identifier of the form to submit.",

            requireModel: "boolean (optional): Gets or sets a value that indicates whether specifying a " +
                "non-null reference model is required when the 'onGetModel' event is invoked. If this value is " +
                "true and no valid model is provided after that event, the form submission will be cancelled.",

            assembly: "string (optional): The name of the .NET assembly on which " +
                "to invoke static methods. Required if any of the 'onXXX' static " +
                "method names are set.",

            logLevel: "number (optional): The level of details when logging messages " +
                "to the console. Supported values are: 0 (none), 1 (information), " +
                "2 (warning), 3 (error), 4 (debug). The default is 3.",

            requestHeaders: "object (optional): A dictionary of key-value pairs to set on an instance of XMLHttpRequest.",

            reCaptcha: "object (optional): An object that encapsulates configuration settings for Google's reCAPTCHA technology.",

            onGetModel: optionalNameOfMethodWhen + "retrieving the form model.",
            onBeforeSubmit: optionalNameOfMethodWhen + "submitting the form. This event can be cancelled.",
            onBeforeSend: optionalNameOfMethodWhen + "sending the HTTP request. This event can be cancelled.",
            onSendFailed: optionalNameOfMethodWhen + "the HTTP request fails.",
            onSendSucceeded: optionalNameOfMethodWhen + "the HTTP request completes successfully.",
            onUploadChanged: optionalNameOfMethodWhen + "an upload operation occurs.",
            onFileReaderChanged: optionalNameOfMethodWhen + "a change occurs in a file reading operation.",
            onFileReaderResult: optionalNameOfMethodWhen + "a file reading operation is completed successfully.",
            onReCaptchaActivity: optionalNameOfMethodWhen + "a Google reCAPTCHA activity is reported.",
            onAjaxUploadWithProgressNotSupported: optionalNameOfMethodWhen + "the browser does not support AJAX uploads with progress report.",
        };

        const message = "Initialization options must be a variation of the following format:";
        const formId = undefined;

        if (isError) logError(formId, message, options);
        else logInfo(formId, message, options);

        return false;
    }

    function validateFormAttributes(formId) {
        const frm = _document.getElementById(formId);
        if (!frm) {
            logError(formId, `The form element identified by '${formId}' does not exist in the DOM.`);
            return false;
        }
        if (!_isString(frm.getAttribute("action"))) {
            logError(formId, "The form action attribute is not defined.");
            return false;
        }
        return true;
    }

    /**
     * Recursively append to the specified form data 
     * properties and values from the given model.
     * @param {any} model The model from which to collect form data.
     * @param {FormData} formData The FormData object to which collected values are appended.
     * @param {string} path The current navigation path to a given property of the model.
     */
    function collectModelData(model, formData, path) {
        if (_isObject(model) && !(model instanceof Date) && !(model instanceof File) && !(model instanceof Blob)) {
            Object.keys(model).forEach(key => {
                collectModelData(model[key], formData, path ? `${path}[${key}]` : key);
            });
        } else {
            const value = (model === null || model === undefined) ? '' : model;
            formData.append(path, value);
        }
    }

    /**
     * Check if the specified form contains at least one file to upload.
     * @param {HTMLFormElement} form The form to query.
     */
    function containsFiles(form) {
        const inputs = form.querySelectorAll("input[type=file]");
        for (let i = 0; i < inputs.length; i++) {
            if (inputs[i].files && inputs[i].files.length) {
                return true;
            }
        }
        return false;
    }

    /**
     * Invoke dotnet method 'onAjaxUploadWithProgressNotSupported'.
     * @param {string} formId The form identifier.
     */
    async function raiseAjaxUploadWithProgressNotSupported(formId) {
        let cancel = false;
        if (!!_formsOptions[formId]) {
            const { onAjaxUploadWithProgressNotSupported } = _formsOptions[formId];

            if (_isString(onAjaxUploadWithProgressNotSupported)) {
                const navigatorInfo = {};
                populateDictionary(navigatorInfo, global.navigator);
                logDebug(formId, "Navigator properties collected", navigatorInfo);

                cancel = await invokeDotNet(formId, onAjaxUploadWithProgressNotSupported,
                    { extraProperties: navigatorInfo }
                );
            }
        }
        return cancel;
    }

    function supportsAjaxUploadWithProgress() {
        return supportsFileAPI() &&
            supportsAjaxUploadProgressEvents() &&
            supportsFormData();

        function supportsFileAPI() {
            var fi = _document.createElement("INPUT");
            fi.type = "file";
            return "files" in fi;
        };

        function supportsAjaxUploadProgressEvents() {
            var xhr = "XMLHttpRequest" in global && new XMLHttpRequest();
            return !!(xhr && ("upload" in xhr) && ("onprogress" in xhr.upload));
        };

        function supportsFormData() {
            return !!global.FormData;
        }
    }

    function invokeDotNet(formId, method, arg) {
        if (arg === undefined) arg = null;
        const { objInstanceRef } = _formsOptions[formId];

        if (!!objInstanceRef) {
            logDebug(formId, `Invoking .NET method "${method}" using object instance.`, arg);
            return objInstanceRef.invokeMethodAsync(method, arg);
        } else {
            logDebug(formId, `Invoking .NET method "${method}" using static type`, arg);
            return _dotnet.invokeMethodAsync(_formsOptions.assembly, method, arg);
        }
    }

    function addXHRUploadEventListeners(formId, xhr, hasFiles) {
        const { onUploadChanged } = _formsOptions[formId];
        if (!_isString(onUploadChanged)) return;
        logDebug(formId, "Setting up upload event handlers...");
        addFileReaderOrUploadEventListeners(formId, xhr, xhr.upload, onUploadChanged, hasFiles);
    }

    /**
     * Set up event handlers for a FileReader object.
     * @param {string} formId The form identifier.
     * @param {FileReader} reader A FileReader object to which event listeners will be added.
     * @param {object} alternateHandlers Optional: An configuration options object to specify alternate event handlers.
     * Property names may be any of the following functions:
     * 'onstart' Event handler to invoke when the operation starts.
     * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
     * 'onsuccess' Event handler to invoke when the operation completes successfully.
     * 'onfinish' Event handler to invoke when the operation finishes.
     * 'onabort' Event handler to invoke when the operation is aborted.
     * 'onerror' Event handler to invoke when an error occurs.
     */
    function addFileReaderEventListeners(formId, reader, alternateHandlers) {
        const { onFileReaderChanged } = _formsOptions[formId];
        if (!_isString(onFileReaderChanged)) return;

        addFileReaderOrUploadEventListeners(formId, reader, reader, onFileReaderChanged, true, alternateHandlers);
    }

    /**
     * Set up event handlers for an XMLHttpRequest.upload or FileReader object.
     * @param {string} formId The form identifier.
     * @param {object} owner The object that owns the eventTarget (on which 'abort()' should be called if requested).
     * @param {object} eventTarget An object to which event listeners will be added.
     * If it's an XMLHttpRequest instance then it should its 'upload' property.
     * Otherwise, this is the same object has the 'owner'.
     * @param {string} interopCallback The name of the .NET callback function to invoke when a change occurs.
     * @param {boolean} hasFiles true if it's an upload operation with files; otherwise, false.
     * @param {object} alternateHandlers Optional: A configuration options object to specify alternate event handlers.
     * Property names may be any of the following functions:
     * 'onstart' Event handler to invoke when the operation starts.
     * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
     * 'onsuccess' Event handler to invoke when the operation completes successfully.
     * 'onfinish' Event handler to invoke when the operation finishes.
     * 'onabort' Event handler to invoke when the operation is aborted.
     * 'onerror' Event handler to invoke when an error occurs.
     */
    function addFileReaderOrUploadEventListeners(formId, owner, eventTarget, interopCallback, hasFiles, alternateHandlers) {

        /**
         * Handles a progress event.
         * @param {ProgressEvent<XMLHttpRequest>|ProgressEvent<FileReader>} e The event data.
         */
        async function handleEvent(e) {
            return invokeDotNet(formId, interopCallback, {
                bytesReadOrSent: e.loaded,
                totalBytesToReadOrSend: e.total,
                eventType: UPLOAD_EVENTS[e.type] | 0,
                hasFiles
            });
        }

        let { onstart, onprogress, onsuccess, onfinish, onabort, onerror } = alternateHandlers || {};

        if (!onstart) onstart = handleEvent;

        // The upload/read has begun.
        addEventHandler(eventTarget, 'loadstart', onstart);

        if (!onsuccess) onsuccess = handleEvent;

        // The upload/read completed successfully.
        addEventHandler(eventTarget, 'load', onsuccess);

        if (!onfinish) onfinish = handleEvent;

        /**
         * The upload/read finished. This event does not differentiate between
         * success or failure, and is sent at the end of the upload
         * regardless of the outcome. Prior to this event, one of load,
         * error, abort, or timeout will already have been delivered to
         * indicate why the upload ended.
         */
        addEventHandler(eventTarget, 'loadend', onfinish);

        if (!onprogress)
            onprogress = function (e) {
                handleEvent(e).then(cancel => (cancel) && owner.abort());
            };

        // Periodically delivered to indicate the amount of progress made so far.
        addEventHandler(eventTarget, 'progress', onprogress);

        if (!onerror) onerror = handleEvent;

        // The upload/read failed due to an error.
        addEventHandler(eventTarget, 'error', onerror);

        if (!onabort) onabort = handleEvent;

        // The upload/read operation was aborted.
        addEventHandler(eventTarget, 'abort', onabort);

        if ('ontimeout' in eventTarget) {
            // The upload timed out because a reply did not arrive within 
            // the time interval specified by the XMLHttpRequest.timeout.
            addEventHandler(eventTarget, 'timeout', handleEvent);
        }
    }

    /**
     * Set request headers on the specified XMLHttpRequest object.
     * @param {string} formId The form identifier.
     * @param {XMLHttpRequest} xhr
     * @param {Object} headers An initialized object.
     */
    function setRequestHeaders(formId, xhr, headers) {
        if (!_isDictionary(headers)) return false;

        logDebug(formId, "Setting request headers...");

        for (const name in headers) {
            if (headers.hasOwnProperty(name)) {
                const value = headers[name];
                logDebug(formId, "Header:", { name, value });
                xhr.setRequestHeader(name, value);
            }
        }

        return true;
    }

    function logInfo(formId) {
        log(formId, CONSOLE_FUNC.info, ...arguments);
    }

    function logWarning(formId) {
        log(formId, CONSOLE_FUNC.warn, ...arguments);
    }

    function logError(formId) {
        log(formId, CONSOLE_FUNC.error, ...arguments);
    }

    function logDebug(formId) {
        log(formId, CONSOLE_FUNC.log, ...arguments);
    }

    function log(formId, func, ...args) {
        const { logLevel = LOG_LEVEL.debug } = _formsOptions[formId] || { logLevel: LOG_LEVEL.debug };

        if (logLevel === LOG_LEVEL.none) return;

        func || (func = CONSOLE_FUNC.info);
        const argument = [`${func === "log" ? "debug" : func}: BlazorFormManager:`, ...args];

        if (logLevel === LOG_LEVEL.debug)
            console[func].apply(console, argument);

        else if (func === CONSOLE_FUNC.error && logLevel >= LOG_LEVEL.error)
            console.error.apply(console, argument);

        else if (func === CONSOLE_FUNC.warn && logLevel >= LOG_LEVEL.warning)
            console.warn.apply(console, argument);

        else if (func === CONSOLE_FUNC.info && logLevel >= LOG_LEVEL.information)
            console.info.apply(console, argument);
    }

    function _isString(obj) {
        return !!obj && typeof obj === "string" && ("" + obj).trim().length > 0;
    }

    function _isObject(obj) {
        return !!obj && typeof obj === "object";
    }

    function _isFunction(obj) {
        return !!obj && typeof obj === "function";
    }

    function _isDictionary(obj) {
        return _isObject(obj) && Object.keys(obj).length > 0;
    }

    /**
     * Builds a dictionary of primitive types.
     * @param {any} target
     * @param {any} source
     */
    function populateDictionary(target, source) {
        for (const prop in source) {
            const value = source[prop];
            const type = typeof value;
            if (value === undefined || value === null) continue;
            if (PRIMITIVES.indexOf(type) > -1) {
                target[prop] = value;
            }
            //if (value instanceof Array) {
            //    for (let i = 0; i < value.length; i++) {

            //    }
            //}
        }
        return target;
    }

    function updateOptions(options) {
        // fail early
        if (!_isObject(options))
            return showOptionsUsage(true);

        const { formId } = options;

        logDebug(formId, "Updating script options", options);

        if (!_isObject(options)) {
            logError(null, "Invalid options", options);
            return false;
        }

        if (!_formsOptions[formId]) {
            _formsOptions[formId] = options;
            logDebug(formId, "Entire script options set.");
        } else {
            const storedOptions = _formsOptions[formId];
            let count = 0;
            for (const key in options) {
                if (options.hasOwnProperty(key)) {
                    storedOptions[key] = options[key];
                    count++;
                }
            }
            logDebug(formId, `Script properties updated: ${count}`);
        }

        return true;
    }

    /**
     * Read input files using the specified options
     * @param {{ formId: string, inputId: string, inputName: string, accept: string, acceptType: string, multiple: boolean, createObjectUrl: boolean, method: {readAsArrayBuffer: number, readAsBinaryString: number, readAsDataURL: number, readAsText: number, enumerate: number}, imagePreviewOptions: { autoGenerate: boolean, generateFileInfo: boolean, tagName: string, tagClass: string, tagId: string, attributeName: string, wrapperSelector: string, width: number, height: number, noResize: boolean, preserveAspectRatio: boolean }}}
     * options The file reader options.
     * @param {(files: FileList | File[]) => void} processedFileListCallback
     * A callback function that receives an array of the files effectively processed.
     */
    async function readInputFiles(options, processedFileListCallback) {
        logDebug(options.formId, "Preparing to read input files with options", options);

        const ERROR_CODE_BASE = 100;
        let succeeded = false, error = '', code = 0;

        if (!_supportsFileReader) {
            return { succeeded, error: "Your device does not support the FileReader API.", code: ERROR_CODE_BASE + 1 };
        }

        const { formId, method, inputId } = options;
        logDebug(formId, "Reading file(s) from input using options", options);

        // The .NET callback method name to invoke when the operation 
        // completes, unless the imagePreviewElement parameter is set.
        const { onFileReaderResult } = _formsOptions[formId];

        if (FILE_READER_FUNC[method] === undefined) {
            succeeded = false;
            code = ERROR_CODE_BASE + 2;
            error = `Unsupported file reader method: ${method}`;
        } else if (_isString(inputId)) {

            if (!_isString(onFileReaderResult))
                logWarning(formId, "Managed callback 'onFileReaderResult' not specified.");

            const input = _document.getElementById(inputId);

            if (input && 'files' in input) {
                return readFileList(input.files, options, processedFileListCallback);
            } else {
                code = ERROR_CODE_BASE + 4;
                error = `Specified input id #${inputId} does not identify an input element of type 'file'.`;
            }
        } else {
            code = ERROR_CODE_BASE + 3;
            error = `Invalid file reader options: 'inputId' not present.`;
        }

        logError(formId, error);
        succeeded = false;
        return { succeeded, error, code };
    }

    function enforceMultipleFilesPolicy(formId, dropTargetId, fileCount) {
        if (fileCount > 1)
            logWarning(null, `Dropping multiple files (${fileCount}) here is not allowed. Picking first and ignoring the rest.`);

        fileCount = dragDropGetFileCount(dropTargetId);
        logDebug(formId, "dragDropGetFileCount", fileCount);

        // remove existing files
        if (fileCount > 0) dragDropRemoveFileList({ formId, dropTargetId });
    }

    /**
     * Read a list of files.
     * @param {FileList|File[]} fileList The list of files to read.
     * @param {any} options An object that encapsulates settings for file reading operations.
     * @param {(files: FileList | File[]) => void} processedFileListCallback
     * A callback function that receives an array of the files effectively processed.
     * @param {boolean} storeOnly 
     * true to validate file acceptance and store files without reading them; otherwise, false.
     */
    async function readFileList(fileList, options, processedFileListCallback, storeOnly) {
        const ERROR_CODE_BASE = 200;
        const fileCount = fileList && fileList.length || 0;

        if (fileCount > 0) {
            const { formId, accept, acceptType, multiple, inputId, createObjectUrl } = options;

            // check for multiple files
            if (!multiple) enforceMultipleFilesPolicy(formId, inputId, fileCount);

            const hasAccept = _isString(accept);
            const hasAcceptType = _isString(acceptType);
            const acceptAllFiles = !(hasAccept || hasAcceptType);
            const supportedFiles = acceptAllFiles
                ? []
                : hasAccept ? (accept + '').split(',').map(type => type.trim().toLowerCase()) : undefined;

            const processedFileList = [];
            const { onReadFileList } = _formsOptions[formId];
            const hasCallback = _isFunction(processedFileListCallback);
            const hasOnReadFileList = _isString(onReadFileList);
            const abortedByUser = "File list reading operation has been aborted by user";

            let notAllowed = false;
            let dimensions = { width: 0, height: 0 };

            _readFileListAborted = false;

            if (acceptAllFiles) logDebug(formId, "Any file accepted.");

            if (hasOnReadFileList)
                await invokeDotNet(formId, onReadFileList, { type: READ_FILE_LIST_EVENTS["start"], totalFilesToRead: fileCount });

            for (let i = 0; i < fileCount; i++) {
                logDebug(formId, `Processing file... ${i + 1} of ${fileCount}`);

                const file = fileList[i];

                if (!acceptAllFiles) {
                    if (hasAccept) {
                        if (!supportsFileExtension(file.name)) {
                            logWarning(formId, `File "${file.name}" is not allowed.`);
                            notAllowed = true;

                            if (hasOnReadFileList) {
                                const evArgs = {
                                    type: READ_FILE_LIST_EVENTS["rejected"],
                                    reason: READ_FILE_LIST_REJECTION["extension"],
                                    file: createFileInfo(file, null, createObjectUrl),
                                    filesRead: i + 1,
                                    totalFilesToRead: fileCount
                                };
                                const cancel = await invokeDotNet(formId, onReadFileList, evArgs);
                                if (cancel) {
                                    _readFileListAborted = true;
                                    logDebug(formId, `${abortedByUser} after rejected file extension.`);
                                    break;
                                }
                            }

                            continue;
                        }
                    }

                    if (hasAcceptType) {
                        // checking could be more elaborated using regex but for now it'll do it
                        if (file.type && file.type.indexOf(acceptType) === -1) {
                            logWarning(formId, `File "${file.name}" of type ${file.type} is not allowed.`);
                            notAllowed = true;

                            if (hasOnReadFileList) {
                                const evArgs = {
                                    type: READ_FILE_LIST_EVENTS["rejected"],
                                    reason: READ_FILE_LIST_REJECTION["type"],
                                    file: createFileInfo(file, null, createObjectUrl),
                                    filesRead: i + 1,
                                    totalFilesToRead: fileCount
                                };
                                const cancel = await invokeDotNet(formId, onReadFileList, evArgs);
                                if (cancel) {
                                    _readFileListAborted = true;
                                    logDebug(formId, `${abortedByUser} after rejected file type.`);
                                    break;
                                }
                            }

                            continue;
                        }
                    }
                }

                dimensions = null;

                if (!storeOnly) {
                    logDebug(formId, `Reading file ${file.name}`);

                    const result = await readFileCore(
                        file,
                        options,
                        async dataURL => dimensions = await generateImagePreview(dataURL, file, options)
                    );

                    if (result.aborted) {
                        _readFileListAborted = true;
                        break;
                    }
                }

                if (hasOnReadFileList) {
                    const evArgs = {
                        type: READ_FILE_LIST_EVENTS["processed"],
                        file: createFileInfo(file, dimensions, createObjectUrl),
                        filesRead: i + 1,
                        totalFilesToRead: fileCount
                    };
                    const cancel = await invokeDotNet(formId, onReadFileList, evArgs);
                    if (cancel) {
                        if (cancel === 5)
                            continue; // rejection by application policy (file ignored)

                        _readFileListAborted = true;
                        logDebug(formId, abortedByUser);
                        break;
                    }
                }

                if (hasCallback)
                    processedFileList.push(file);

                if (_readFileListAborted)
                    break;

                if (!multiple) {
                    if (fileCount > 1) {
                        logWarning(formId, `Processing multiple files (${fileCount}) is not allowed. The remaining files are ignored.`);

                        if (hasOnReadFileList) {
                            const evArgs = {
                                type: READ_FILE_LIST_EVENTS["rejected"],
                                reason: READ_FILE_LIST_REJECTION["multiple"],
                                files: [...fileList].slice(i + 1).map(f => createFileInfo(f, null, createObjectUrl)),
                                filesRead: i + 1,
                                totalFilesToRead: fileCount
                            };
                            await invokeDotNet(formId, onReadFileList, evArgs);
                        }
                    }
                    break;
                }
            }

            if (_readFileListAborted)
                logDebug(formId, "Exited 'readFileList' loop prematurely!");

            const filesRead = processedFileList.length;

            if (!multiple && notAllowed)
                resetInputFile(formId, options.inputFileId);
            if (hasCallback && filesRead && !_readFileListAborted)
                processedFileListCallback.call(this, processedFileList);

            if (hasOnReadFileList) {
                await invokeDotNet(formId, onReadFileList, {
                    type: READ_FILE_LIST_EVENTS["end"],
                    reason: _readFileListAborted ? READ_FILE_LIST_REJECTION["aborted"] : READ_FILE_LIST_REJECTION["none"],
                    filesRead,
                    totalFilesToRead: fileCount
                })
            }

            _readFileListAborted = false;
            return { succeeded: true, error: null, code: 0 };

            function supportsFileExtension(name) {
                name = (name || "").toLowerCase();
                for (let i = 0; i < supportedFiles.length; i++)
                    if (name.endsWith(supportedFiles[i]))
                        return true;
                return false;
            }
        } else {
            const error = "No file available to read.";
            logDebug(options.formId, error);
            return { succeeded: false, error, code: ERROR_CODE_BASE + 1 };
        }
    }

    /**
     * Read a file.
     * @param {File} file
     * @param {any} options
     * @param {Promise<void>} setDataURLCallback
     */
    async function readFileCore(file, options, setDataURLCallback) {
        const { formId, method, inputId = null, inputName = null } = options;
        const { onFileReaderResult } = _formsOptions[formId];
        const methodName = FILE_READER_FUNC[method];
        const result = {
            // given back these 3 properties makes the identification
            // in the 'onFileReaderResult' callback more accurate
            method: method + "",
            inputId: inputId + "",
            inputName: inputName + "",

            aborted: false,
            succeeded: false,
            completedInScript: false,
            error: "",
            content: "",
            contentArray: [],
        };

        try {
            if (methodName === "enumerate") {
                logDebug(formId, "Enumerating file ", file);
                result.succeeded = true;
            } else {
                // create a Promise that takes care of reading the file
                const promiseResult = await createFileReaderPromise(formId, file, method);
                const { succeeded, aborted, content } = promiseResult;

                if (succeeded) {
                    if (methodName === "readAsArrayBuffer") {
                        // convert to a 'normal' array
                        const contentArray = Array.prototype.slice.call(new Uint8Array(content));
                        result.contentArray = contentArray;

                    } else if (_isFunction(setDataURLCallback) &&
                        methodName === "readAsDataURL" &&
                        file.type && file.type.indexOf("image") !== -1) {

                        await setDataURLCallback.call(this, content);
                        result.completedInScript = true;
                    } else {
                        result.content = content;
                    }
                }

                result.succeeded = succeeded;
                result.aborted = !!aborted;
            }

            if (_isString(onFileReaderResult))
                await invokeDotNet(formId, onFileReaderResult, result);

            // clean up
            if (!result.completedInScript) {
                result.content = null;
                result.contentArray = null;
            }

            return result;
        } catch (e) {
            const error = e.message || e;
            result.succeeded = false;
            result.error = error + "";

            logError(formId, e);

            if (_isString(onFileReaderResult)) await invokeDotNet(formId, onFileReaderResult, result);

            return result;
        }
    }

    /**
     * Create a Promise that will handle all supported file reading events and notifications to the Blazor app.
     * @param {string} formId The form identifier.
     * @param {File} file The file to read.
     * @param {number} method An integer between 1 and 4.
     * @return {Promise<{succeeded: boolean, aborted: boolean, content: string|ArrayBuffer}>}
     */
    function createFileReaderPromise(formId, file, method) {
        const methodName = FILE_READER_FUNC[method];
        const { onFileReaderChanged } = _formsOptions[formId];

        return new Promise((resolve, reject) => {
            try {
                let succeeded = false;
                let aborted = false;
                const reader = new FileReader();

                // custom event handlers
                const onstart = e => raiseNotification(e);

                const onprogress = async e => {
                    const cancel = await raiseNotification(e);
                    if (cancel) {
                        // Phew! This one was hard to debug...!
                        // The local 'aborted' flag isn't enough for a small-sized file;
                        // it may have already been read to end after the notification returns,
                        // hence the 'readFileList' function won't get a chance to quit because
                        // the 'aborted' property isn't set in the resolved object.

                        // That's why we also set the '_readFileListAborted' field to true in
                        // case the current promise was created in the call-chain of 'readFileList'.
                        _readFileListAborted = aborted = true;

                        reader.abort();
                        logWarning(formId, "File reading operation was aborted on demand.");
                    }
                };

                // onload
                const onsuccess = e => {
                    succeeded = !aborted;
                    return raiseNotification(e);
                };

                // onloadend
                const onfinish = async e => {
                    await raiseNotification(e);
                    resolve({ succeeded, aborted, content: aborted ? null : e.target.result });
                };

                const onerror = async e => {
                    const error = `Failed to read file! Reason: ${reader.error}`;
                    logDebug(formId, error);
                    await raiseNotification(e, error);
                    reject(error);
                };

                const onabort = async () => {
                    _readFileListAborted = aborted = true;
                };

                const alternateHandlers = { onstart, onprogress, onsuccess, onfinish, onerror, onabort };
                addFileReaderEventListeners(formId, reader, alternateHandlers);

                logDebug(formId, "Attempting to read file using method", methodName);

                switch (methodName) {
                    case "readAsArrayBuffer":
                        reader.readAsArrayBuffer(file);
                        break;
                    case "readAsBinaryString":
                        reader.readAsBinaryString(file);
                        break;
                    case "readAsDataURL":
                        reader.readAsDataURL(file);
                        break;
                    case "readAsText":
                        reader.readAsText(file);
                        break;
                    default:
                        reject(new Error(`Unsupported method: ${method}`));
                }
            } catch (e) {
                logDebug(formId, "Error reading file", e);
                reject(e);
            }
        });

        /**
         * Invoke .NET method when a progress event is received.
         * @param {ProgressEvent<FileReader>} e The event data.
         * @param {string} error Optional: A message that describes the error that might have occurred.
         */
        async function raiseNotification(e, error) {
            const eventType = UPLOAD_EVENTS[e.type] | 0;
            const eventData = {
                bytesReadOrSent: e.loaded,
                totalBytesToReadOrSend: e.total,
                eventType,
                hasFiles: true,
                error: error || null
            };
            if (eventType === 0) eventData.file = createFileInfo(file);
            return invokeDotNet(formId, onFileReaderChanged, eventData);
        }
    }

    /**
     * Create a file info object from the specified file.
     * @param {File} file
     * @param {{width: number, height: number}} dimensions Optional: The dimensions of the file if it's an image.
     * @param {boolean} createUrl true to create an object URL if the file type is an image.
     */
    function createFileInfo(file, dimensions, createUrl) {
        if (!_isObject(dimensions)) dimensions = null;
        return {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModifiedDate: new Date(file.lastModified),
            dimensions,
            objectUrl: createUrl && file.type.toLowerCase().indexOf('image/') > -1 ? URL.createObjectURL(file) : ""
        }
    }

    /**
     * Takes care of generating an image preview for the specified file.
     * @param {string} dataURL URL-encoded image data.
     * @param {File} file The file whose dataURL is provided.
     * @param {object} options An object used to generate an image.
     */
    async function generateImagePreview(dataURL, file, options) {
        const { formId, dropTargetId, imagePreviewOptions, multiple } = options;

        if (!_isObject(imagePreviewOptions)) {
            logWarning(formId, "No image preview generation options set.");
        } else {
            const {
                autoGenerate, autoGeneratedClass, generateFileInfo, tagClass, tagId,
                tagName, src, wrapperSelector, width: desiredWidth, height: desiredHeight,
                preserveAspectRatio, noResize
            } = defaultPreviewOptionsFrom(imagePreviewOptions);

            if (_isString(tagId)) {
                const result = await getTargetElementById(formId, tagId);
                const { succeeded, targetElement: image, error } = result;

                if (succeeded) {
                    addImageAttributes(image);
                    return {
                        width: (image.width || 0) | 0,
                        height: (image.height || 0) | 0
                    };
                }

                logError(formId, error);

            } else if (autoGenerate) {
                const dropTarget = _document.getElementById(dropTargetId);
                let container = dropTarget;
                let image, width = 0, height = 0;

                if (!noResize && _imageUtilAvailable && multiple) {
                    logDebug(formId, "Generating preview with ImageUtil.");
                    const { canvas, naturalWidth, naturalHeight } = await new ImageUtil(dataURL).resize(desiredWidth, desiredHeight, preserveAspectRatio);
                    image = addImageAttributes(canvas, true, naturalWidth, naturalHeight);
                    width = naturalWidth;
                    height = naturalHeight;
                } else {
                    image = addImageAttributes(_document.createElement("" + tagName));
                }

                if (_isString(wrapperSelector)) {
                    if (wrapperSelector.startsWith("#")) {
                        // id specified, don't look for the element in the drop target
                        container = _document.querySelector(wrapperSelector);
                    } else {
                        // query first the dropTarget
                        if (!!dropTarget) container = dropTarget.querySelector(wrapperSelector);

                        // then query the document if not found
                        if (!container) container = _document.querySelector(wrapperSelector);
                    }

                    if (!container) {
                        // if an image container has been specified but not found, that's an error
                        logError(formId, `Wrapper ${wrapperSelector} for auto-generated image not found in the DOM tree.`);
                    }
                }

                if (!container) container = dropTarget || _document;

                container.appendChild(image);

                return { width, height };

            } else {
                logWarning(formId, "Automatic image preview generation option is disabled!");
            }

            /**
             * Add attributes for an auto-generated image.
             * @param {HTMLElement} img The target HTML element to add attributes to.
             * Can be any HTML element but usually it's an <img /> or a <canvas></canvas> tag.
             * @param {boolean} skipSrc true to skip setting the 'src' attribute; otherwise, false.
             * @param {number} naturalWidth Optional: The original width of the image.
             * @param {number} naturalHeight The original height of the image.
             */
            function addImageAttributes(img, skipSrc, naturalWidth, naturalHeight) {
                const fileSize = fileSizeToString(file.size);

                if (!skipSrc) img.setAttribute(src, dataURL);

                // use classList to preserve existing classes
                addClassList(img, tagClass);

                if (generateFileInfo) {
                    /* A variation of what's built:
    
                     <span class="form-manager-auto-generated">
                        <img src="data:image;..."/>
                        <span class="file-info">
                            <span class="name">file_name.jpg</span>
                            <span class="size">98.29 KB</span>
                        </span>
                        <span class="bg-dimmed"></span>
                     </span>
                     */
                    const elcontainer = _document.createElement("span");
                    const elmeta = _document.createElement("span");
                    const elfilename = _document.createElement("span");
                    const elfilesize = _document.createElement("span");
                    const eldimmed = _document.createElement("span");
                    const eldimensions = naturalWidth && naturalHeight && _document.createElement("span") || null;

                    // add an internal class so that we can remove those created with the current script
                    elcontainer.setAttribute("class", autoGeneratedClass);
                    if (multiple) elcontainer.classList.add("gallery");

                    elmeta.setAttribute("class", "file-info");
                    elfilesize.setAttribute("class", "size");
                    elfilename.setAttribute("class", "name");
                    eldimensions && eldimensions.setAttribute("class", "dimensions");
                    eldimmed.setAttribute("class", "bg-dimmed");

                    elfilesize.textContent = fileSize;
                    elfilename.textContent = file.name;
                    eldimensions && (eldimensions.textContent = `${naturalWidth}x${naturalHeight}`);

                    elmeta.appendChild(elfilesize);
                    elmeta.appendChild(elfilename);
                    eldimensions && elmeta.appendChild(eldimensions);

                    elcontainer.appendChild(img);
                    elcontainer.appendChild(elmeta);
                    elcontainer.appendChild(eldimmed);

                    return elcontainer;
                } else {
                    addClassList(img, autoGeneratedClass).setAttribute("title", `${file.name} (${fileSize})`);
                    return img;
                }
            }
        }

        return { width: 0, height: 0 };
    }

    /**
     * Remove auto-generated images.
     * @param {HTMLElement} container Optional: The HTML element that contains the images. Defaults to document.
     */
    function removeAutoGeneratedImages(container) {
        const images = (container || _document).querySelectorAll(`.${_defaultImagePreviewOptions.autoGeneratedClass}`);
        for (let i = 0; i < images.length; i++) {
            const img = images[i];
            img.remove();
        }
    }

    async function getTargetElementById(formId, id) {
        const ERROR_CODE_BASE = 300;
        if (_isString(id)) {
            const targetElement = _document.getElementById(id);

            if (!targetElement) {
                const error = notFound(id);
                const result = { succeeded: false, error, targetElement, code: ERROR_CODE_BASE + 2 };

                if (_isString(_formsOptions[formId].onFileReaderResult))
                    await invokeDotNet(formId, _formsOptions[formId].onFileReaderResult, result);
                return result;
            }

            return { succeeded: true, error: undefined, targetElement, code: 0 };
        }

        return { succeeded: false, error: undefined, targetElement: undefined, code: ERROR_CODE_BASE + 1 }
    }

    /**
     * Enable drag and drop support for the target element.
     * @param {any} options An object that contains at least these 4 properties: 'formId', 'dropTargetId', 'dropEffect', and 'inputName'.
     */
    async function dragDropEnable(options) {
        const ERROR_CODE_BASE = 400;
        const {
            formId,
            dropTargetId,
        } = options;

        logDebug(formId, "Enable drag and drop support with options", options);

        let succeeded = false, error = '', code = 0;
        const targetId = "" + dropTargetId;

        if (targetId in _dragDropStorage) {
            code = ERROR_CODE_BASE + 1;
            error = `The drop target element identified by #${targetId} has already been registered.`;
            logDebug(formId, error);
        } else {
            const dropTarget = _document.getElementById(targetId);

            if (!!dropTarget) {
                const { dropEffect = "copy", effectAllowed = "copy" } = options;

                /**
                 * A drag operation has started.
                 * @param {DragEvent} e
                 */
                const dragstart = async e => {
                    e.stopPropagation();
                    e.preventDefault();

                    let effectSet = false;
                    const dt = e.dataTransfer;

                    logDebug(formId, `dragStart: dropEffect = ${dt.dropEffect} ; effectAllowed = ${dt.effectAllowed}`);

                    // Since _formsOptions can be updated, let's get the most current values
                    // of 'onDragStart' and 'onDrop' every time a drag and drop operation occurs.
                    const { onDragStart } = _formsOptions[formId];

                    if (_isString(onDragStart)) {
                        const args = getMouseEventArgs(e);

                        args.dataTransfer = {
                            dropEffect: dt.dropEffect,
                            effectAllowed: dt.effectAllowed,
                            files: [],
                            items: [...dt.items].map(i => ({ kind: i.kind, type: i.type })),
                            types: dt.types
                        };

                        const result = await invokeDotNet(onDragStart, args);

                        if (_isObject(result)) {
                            const { data, dataFormat, effectAllowed: effect } = result;

                            if (_isString(data) && _isString(dataFormat)) {
                                dt.setData(dataFormat, data);
                                logDebug(formId, `Drag start event data set. Format=${dataFormat}`, data);
                            }

                            if (_isString(effect)) {
                                dt.effectAllowed = effect;
                                effectSet = true;
                            }
                        }
                    }

                    if (!effectSet) dt.effectAllowed = effectAllowed;
                };

                /**
                 * Handles the 'dragover' event.
                 * @param {DragEvent} e
                 */
                const dragover = e => {
                    e.stopPropagation();
                    e.preventDefault();
                    e.dataTransfer.dropEffect = dropEffect;
                };

                // copy the options used for dropping so that they can 
                // be locally overriden without global consequences
                const dropOptions = Object.assign({}, options);

                const drop = function (e) {
                    handleDrop(e, dropOptions, dropTarget);
                };

                addEventHandler(dropTarget, 'dragstart', dragstart);
                addEventHandler(dropTarget, 'dragover', dragover);
                addEventHandler(dropTarget, 'drop', drop);

                // required to clean up the mess on demand
                _dragDropStorage[targetId] = {
                    dragstart,
                    dragover,
                    drop,
                    options
                };

                succeeded = true;
                error = null;
                logDebug(formId, `Drag and drop enabled for target element #${targetId}.`);
            } else {
                code = ERROR_CODE_BASE + 2;
                error = notFound(targetId, "drop target");
            }
        }

        return { succeeded, error, code };
    }

    /**
     * Clean up by removing drag and drop event listeners.
     * @param {string} targetId The drop target element identifier.
     */
    function dragDropDisable({ formId, targetId }) {
        const ERROR_CODE_BASE = 500;
        // explicitly initialize these variables to 
        // make the return type of the function clear
        let succeeded = false, error = '', code = 0;

        if (targetId in _dragDropStorage) {
            const dropTarget = _document.getElementById(targetId);

            if (!!dropTarget) {
                const config = _dragDropStorage[targetId];

                dropTarget.removeEventListener("dragstart", config.dragstart);
                dropTarget.removeEventListener("dragover", config.dragover);
                dropTarget.removeEventListener("drop", config.drop);

                delete config.dragstart;
                delete config.dragover;
                delete config.drop;
                delete config.options;
                if ('droppedFiles' in config) delete config.droppedFiles;

                error = null;
                succeeded = true;
                logDebug(formId, `Drag and drop disabled for #${targetId}.`);
            } else {
                code = ERROR_CODE_BASE + 2;
                error = notFound(targetId, "drop target");
            }

            delete _dragDropStorage[targetId];

        } else {
            code = ERROR_CODE_BASE + 1;
            error = `The event listeners for the drop target element #${targetId} ` +
                "do not exist or have already been removed.";
            logDebug(formId, error);
        }

        return { succeeded, error, code };
    }

    /**
     * Remove dropped files and auto-generated images for the specified target element.
     * @param {string} formId The form identifier.
     * @param {string} dropTargetId The identifier of the drop target element.
     */
    function dragDropRemoveFileList({ formId, targetId }) {
        logDebug(formId, `Attempting to remove dropped files for target element #${targetId}...`);

        if (targetId in _dragDropStorage) {
            const config = _dragDropStorage[targetId];
            const { options } = config;
            const { inputName, imagePreviewOptions = _defaultImagePreviewOptions } = options;

            if ('droppedFiles' in config) {
                delete config.droppedFiles[inputName];
                delete config.droppedFiles;
                logDebug(formId, "Files deleted from drag and drop storage.");
            } else {
                logDebug(formId, "No files have been dropped onto the dedicated area.");
            }

            if (!!imagePreviewOptions) {
                const { tagId: previewId, attributeName: attr } = imagePreviewOptions;
                if (_isString(previewId)) {
                    // suppress image preview, if any
                    const image = _document.getElementById(previewId);
                    if (!!image) {
                        image.removeAttribute(attr || "src");
                        logDebug(formId, "Removed image preview.");
                    }
                    else
                        logDebug(formId, `Image #${previewId} not found in the DOM tree.`);
                }
            }

            const dropTarget = _document.getElementById(targetId);

            if (!!dropTarget) dropTarget.classList.add("drag-drop-area-empty");

            removeAutoGeneratedImages(dropTarget);

            return true;
        } else {
            logDebug(formId, "Target element not found in drag and drop storage.");
        }
        return false;
    }

    /**
     * Read files from an input identified by 'options.inputId' and add them to the 
     * temporary drag and drop storage identified by 'options.targetId'.
     * @param {{ formId: string; targetId: string; inputId: string; inputName: string; method: number }} options The options.
     */
    async function dragDropInputFilesOnTarget(options) {
        const ERROR_CODE_BASE = 600;
        let succeeded = false, error = '', code = 0;
        const { formId, targetId, inputId, inputName, method } = options;

        // first, check if the drop target settings exist
        const config = _dragDropStorage[targetId];

        if (!config) {
            code = ERROR_CODE_BASE + 1;
            error = `Drag and drop settings not found for element #${targetId}.`;
            logError(formId, error);
            return { succeeded, error, code };
        } else {
            // second, get a copy of the stored options from config
            const newOptions = Object.assign({}, config.options);

            // and set new properties appropriately
            newOptions.inputId = inputId;
            newOptions.method = method;
            newOptions.dropTargetId = targetId;

            // finally, read the files and store the processed list into the drag and drop settings
            return await readInputFiles(newOptions, processedFiles => {
                dragDropAfterFilesProcessed(formId, processedFiles, targetId, inputName);
            });
        }
    }

    /**
     * Add the list of files to the drag and drop store.
     * @param {string} formId The form identifier.
     * @param {File[]} files The list of files to add.
     * @param {string} dropTargetId The identifier of the drop target element.
     * @param {string} inputName The name of the form field associated with the files.
     * @param {HTMLElement} dropTargetElement Optional: An HTML element that represents the drop target.
     * If not specified, 'dropTargetId' is used to retrieve it in the DOM. It is used to remove
     * the CSS class 'drag-drop-area-empty' from it.
     * @param {boolean} keepEmtpyClass true to keep the 'drag-drop-area-empty' class on the drop target.
     */
    function dragDropAfterFilesProcessed(formId, files, dropTargetId, inputName, dropTargetElement, keepEmtpyClass) {
        if (files && files.length) {
            // store the dropped files for later use when submitting the form
            const config = _dragDropStorage[dropTargetId];
            if (!!config) {
                // make sure to add to any previously-dropped files
                const { droppedFiles } = config;
                if (!!droppedFiles) {
                    const existingFiles = droppedFiles[inputName];
                    if (existingFiles instanceof Array)
                        files = existingFiles.concat(files);
                }
                config.droppedFiles = { [inputName]: files, fileCount: files.length };
                logDebug(formId, `Dropped files stored for target #${dropTargetId} and input ${inputName}.`);
                if (!keepEmtpyClass) {
                    dropTargetElement || (dropTargetElement = _document.getElementById(dropTargetId));
                    dropTargetElement && dropTargetElement.classList.remove("drag-drop-area-empty");
                }
            } else {
                logError(formId, `No drop store found for target #${dropTargetId}.`);
            }
        }
    }

    /**
     * Handles the 'drop' event.
     * @param {DragEvent} e
     * @param {any} options
     * @param {HTMLElement} dropTarget
     */
    async function handleDrop(e, options, dropTarget) {
        e.stopPropagation();
        e.preventDefault();

        const { formId, inputFileId, multiple, inputName, createObjectUrl } = options;
        const dt = e.dataTransfer;
        const fileList = dt.files;
        const fileCount = fileList && fileList.length || 0;
        const hasFiles = fileCount > 0;
        const files = hasFiles ? [...fileList] : [];
        const { onDrop: onDropInterop } = _formsOptions[formId];

        let filesToProcess = files;
        let storeFilesOnly = false;

        logDebug(formId, "Processing dropped files with options", options);

        if (hasFiles) {
            if (!multiple) filesToProcess = [files[0]];

            logDebug(formId, `${fileCount} file(s) dropped onto target element #${dropTarget.id}`);
            if (_isString(inputFileId)) resetInputFile(formId, inputFileId);
        }

        if (_isString(onDropInterop)) {
            const args = {
                dataTransfer: {
                    dropEffect: DROP_EFFECTS[dt.dropEffect],
                    effectAllowed: DROP_EFFECTS_ALLOWED[dt.effectAllowed],
                    files: hasFiles ? files.map(f => createFileInfo(f, null, createObjectUrl)) : [],
                    items: !!dt.items ? [...dt.items].map(dti => ({ kind: dti.kind, type: dti.type })) : [],
                    types: dt.types,
                },
                targetId: dropTarget.id,
                multiple: !!multiple,
            };

            logDebug(formId, "Drop event args:", args);

            const result = await invokeDotNet(onDropInterop, args);

            logDebug(formId, "Drop event response:", result);

            if (_isObject(result)) {
                const { cancel, acceptedFiles, storeOnly, maxFileCount, maxTotalSize, imagePreviewOptions } = result;

                if (cancel) {
                    logDebug(formId, `Drop operation has been cancelled by the user/app.`);
                    return;
                }

                if (hasFiles) {
                    if (acceptedFiles instanceof (Array) && acceptedFiles.length) {
                        // process only specific files

                        logDebug(formId, "Filtering out specific files to be processed defined by the application.");

                        // cast acceptedFiles from 'any' to 'string' for strongly-typed file name equality comparison
                        const fileNamesAsStringArray = acceptedFiles.map(n => "" + n);

                        // find corresponding items in the original 'files' array
                        filesToProcess = fileNamesAsStringArray
                            .map(name => files.find(file => file.name === name)) // type- and case-sensitive comparison
                            .filter(f => !!f); // remove potentially undefined items returned by the 'map' function
                    }

                    // only integers allowed
                    const maxcount = maxFileCount | 0;

                    if (maxcount > 0) {
                        filesToProcess = filesToProcess.slice(0, maxcount);
                        logDebug(formId, `Maximum ${maxcount} of ${fileCount} files selected for processing.`);
                    }

                    if (maxTotalSize > 0) {
                        logDebug(`Limiting total file size to ${maxTotalSize} MB.`);

                        let sum = 0;
                        const totalFiles = []
                        // convert max from MB to bytes
                        const maxTotalSizeBytes = SIZE_MB * maxTotalSize;

                        for (let i = 0; i < filesToProcess.length; i++) {
                            const file = filesToProcess[i];
                            if ((sum + file.size) <= maxTotalSizeBytes) {
                                sum += file.size;
                                totalFiles.push(file);
                            } else {
                                break;
                            }
                        }

                        const initialFileCount = filesToProcess.length;
                        filesToProcess = totalFiles;

                        logDebug(formId, `${filesToProcess.length} of ${initialFileCount} files ` +
                            `selected for processing.Total size: ${fileSizeToString(sum)}`);
                    }

                    storeFilesOnly = storeOnly;
                    if (_isObject(imagePreviewOptions))
                        options.imagePreviewOptions = imagePreviewOptions;
                }
            }
        }

        // make sure that files have been dropped onto the target
        if (hasFiles && filesToProcess.length) {
            logDebug(formId, `Processing ${filesToProcess.length} dropped file(s)...`);

            /**
             * Callback invoked when at least one file has been effectively processed.
             * @param {File[]} processedFileList
             */
            const cb = processedFileList => {
                const dropTargetId = dropTarget.id;
                if (storeFilesOnly) dropTarget = undefined;
                dragDropAfterFilesProcessed(formId, processedFileList, dropTargetId, inputName, dropTarget, /*keepEmptyClass:*/ storeFilesOnly);
            };

            readFileList(filesToProcess, options, cb, storeFilesOnly);
        }
    }

    /**
     * Return the number of files dropped on the identified target.
     * @param {string} dropTargetId
     */
    function dragDropGetFileCount(dropTargetId) {
        const config = _dragDropStorage[dropTargetId];
        return (!!config && !!config.droppedFiles && config.droppedFiles.fileCount | 0) || 0;
    }

    /**
     * Convert size to a human-readable format.
     * @param {number} size The file size in bytes.
     */
    function fileSizeToString(size) {
        if (size <= 0) return "";
        if (size < SIZE_KB) return `${size} B`;
        if (size < SIZE_MB) return `${(size / SIZE_KB).toFixed(1)} KB`;
        if (size < SIZE_GB) return `${(size / SIZE_MB).toFixed(1)} MB`;
        return `${(size / SIZE_TB).toFixed(2)} GB`;
    }

    /**
     * Attempt to set the value of an input file to an empty string.
     * @param {string} formId The form identifier.
     * @param {string} inputFileId The identifier of the input file to reset.
     */
    function resetInputFile(formId, inputFileId) {
        logDebug(formId, `Resetting input file #${inputFileId}`);
        try {
            const input = _document.getElementById(inputFileId);
            input && (input.value = "");
        } catch (e) {
            logError(formId, `Error resetting the value of file input #${inputFileId}`, e);
        }
    }

    /**
     * Log an error message for the element that has not been found in the DOM tree.
     * @param {string} targetId The identifier of the not-found element.
     * @param {string} name Optional: The name of the element.
     */
    function notFound(targetId, name) {
        const error = `The ${name} element identified by #${targetId} has not been found in the DOM tree.`;
        logError(null, error);
        return error;
    }

    /**
     * Add classes to the element's classList collection.
     * @param {HTMLElement} element
     * @param {string} classes A whitespace-separated string of HTML classes.
     */
    function addClassList(element, classes) {
        element.classList.add(("" + classes).split(" ").map(cls => cls.trim()));
        return element;
    }

    /**
     * Return an object with all mouse-related event properties.
     * @param {MouseEvent} e
     */
    function getMouseEventArgs(e) {
        return {
            altKey: e.altKey,
            button: e.button,
            buttons: e.buttons,
            clientX: e.clientX,
            clientY: e.clientY,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            movementX: e.movementX,
            movementY: e.movementY,
            offsetX: e.offsetX,
            offsetY: e.offsetY,
            pageX: e.pageX,
            pageY: e.pageY,
            screenX: e.screenX,
            screenY: e.screenY,
            shiftKey: e.shiftKey,
            which: e.which,
            x: e.x,
            y: e.y
        }
    }

    function defaultPreviewOptionsFrom(options) {
        // delete invalid properties
        Object.keys(options).forEach(prop => {
            if (options[prop] === 0 || options[prop] === undefined || options[prop] === null)
                delete options[prop];
        });

        const def = _defaultImagePreviewOptions;
        const result = Object.assign({
            autoGenerate: def.autoGenerate,
            autoGeneratedClass: def.autoGeneratedClass,
            generateFileInfo: def.generateFileInfo,
            tagClass: def.tagClass,
            tagName: def.tagName,
            src: def.attributeName,
            wrapperSelector: def.wrapperSelector,
            width: def.width,
            height: def.height,
            preserveAspectRatio: def.preserveAspectRatio,
            noResize: def.noResize,
        }, options);

        return result;
    }

    function supportsImageUtil() {
        // before checking for the ImageUtil class, which uses the 
        // <canvas> element, make sure first that the device supports canvas
        if (!!window.CanvasRenderingContext2D &&
            !!global.ImageUtil && ImageUtil.prototype && ImageUtil.prototype.constructor) {
            const util = new ImageUtil("");
            return ("crop" in util) && ("resize" in util);
        }
        return false;
    }

    /**
     * Adds an event listener to a specified target element identified by 'targetId'.
     * @param {string} targetId The identifier of the target element.
     * @param {string} eventType The type of event to add the listener for.
     * @param {string} callback The static .NET method to invoke when an event occurs.
     */
    function addEventListener(targetId, eventType, callback) {
        logDebug(null, `Adding '${eventType}' event listener for #${targetId}.`);
        const target = _document.getElementById(targetId);

        if (!!target) {
            /**
             * The event handler for the element.
             * @param {Event} event
             */
            const handler = function (event) {
                const obj = {
                    targetId,
                    eventType,
                    arguments: populateDictionary({}, event),
                    value: target.value === undefined ? "" : target.value
                };
                // logDebug(`Event received: ${event.type}, invoking .NET method ${callback}...`, obj);
                _dotnet.invokeMethodAsync(_formsOptions.assembly, callback, obj);
            };

            if (addEventHandler(target, eventType, handler))
                logDebug(null, "Event listener added successfully.");

            return true;
        } else {
            notFound(targetId);
            return false;
        }
    }

    /**
     * Removes an event listener from a target element identified by 'targetId'.
     * @param {string} targetId The identifier of the target element.
     * @param {string} eventType The type of event to remove the listener for.
     */
    function removeEventListener(targetId, eventType) {
        logDebug(`Removing event listener ${eventType} for #${targetId}.`);
        return removeEventHandler(targetId, eventType);
    }

    /**
     * Add an event listener to the specified HTMLElement.
     * @param {HTMLElement|string} target
     * @param {string} eventType The event type.
     * @param {(event: Event) => void} handler The event handler.
     */
    function addEventHandler(target, eventType, handler) {
        if (_isString(target)) {
            target = _document.getElementById(target);
        }

        if (!_isObject(target)) {
            logError(null, "Target is not a valid object reference.");
            return false;
        }

        if (!!target.addEventListener) {
            target.addEventListener(eventType, handler, false);
            return true;
        }
        else if (!!target.attachEvent) {
            target.attachEvent('on' + eventType, handler);
            return true;
        }
        logDebug(`Could not add '${eventType}' event handler for #${target}`);
        return false;
    }

    /**
     * Remove the event listener in the identifier target element's event listener list.
     * @param {string} targetId The identifier of the element for which to remove the event listener.
     * @param {string} eventType The type of event to remove.
     */
    function removeEventHandler(targetId, eventType) {
        const target = _document.getElementById(targetId);
        if (!!target) {
            target.removeEventListener(eventType);
            return true;
        }
        return false;
    }

    /**
     * Adds a 'keydown' or 'keypress' event listener to the element identified 
     * by 'targetId' and optionally allows or blocks certain types of keystrokes.
     * @param {{targetId: string; eventType: string; callback: string; filter: 
     * {allowKeyType: number; blockKeyCodes: number[]; noCallbackOnPassThrough: boolean }}} options
     * An object that encapsulates configuration settings.
     */
    function filterKeys(options) {
        const { targetId, eventType, callback, filter } = options;

        if (!_isString(targetId)) {
            logError(null, "The targetId property must be a string.");
            return false;
        }

        // Keyboard events occur in the following order: keydown->keypress->input->keyup
        // However, only the first two can be cancelled,.
        if (["keydown", "keypress", "keyup"].indexOf(eventType) === -1) {
            logError(null, "Only the 'keydown', 'keypress', and 'keyup' events are supported.");
            return false;
        }

        const target = _document.getElementById(targetId);

        if (!!target) {
            const isKeyupEvent = eventType === "keyup";
            const { allowKeyType = FILTER_KEY_TYPES.none, blockKeyCodes, noCallbackOnPassThrough } = filter || {};
            const blockedKeyCodes = Array.from(blockKeyCodes || []).map(n => n | 0);
            const hasCallback = _isString(callback);

            /**
             * Intercepts the 'keydown' and 'keypress' events.
             * @param {KeyboardEvent} e The event data.
             */
            const handler = e => {
                const charCode = (e.which) ? e.which : e.keyCode;

                // The 'keyup' event cannot be prevented, so we don't check it.
                if (!isKeyupEvent) {
                    if (allowKeyType !== FILTER_KEY_TYPES.none) {
                        if ((allowKeyType === FILTER_KEY_TYPES.alpha && !isAlpha()) ||
                            (allowKeyType === FILTER_KEY_TYPES.alphaNumeric && !isAlphaNumeric()) ||
                            (allowKeyType === FILTER_KEY_TYPES.digits && !isDigit()))
                            return cancelEvent();
                    }

                    if (blockedKeyCodes.indexOf(charCode) > -1)
                        return cancelEvent();
                }

                if (hasCallback && !noCallbackOnPassThrough) {
                    const arg = populateDictionary({
                        targetId,
                        eventType: e.type,
                        value: e.target.value === undefined ? "" : e.target.value
                    }, e);
                    _dotnet.invokeMethodAsync(_formsOptions.assembly, callback, arg);
                }

                return true;

                function isAlpha() {
                    // 95 = _
                    return charCode === 95 || /^[A-Za-z]+$/.test(e.key);
                }

                function isAlphaNumeric() {
                    return /^[\w]+$/.test(e.key);
                }

                function isDigit() {
                    return charCode > 47 && charCode < 58;
                }

                function cancelEvent() {
                    e.preventDefault();
                    return false;
                }
            };

            addEventHandler(target, eventType, handler);

            return true;
        } else {
            notFound();
            return false;
        }
    }

    /**
     * Remove from the processed file storage the files 
     * that have been previously been successfully selected.
     * @param {{formId: string; inputId: string}} options
     */
    function deleteProcessedFileList(options) {
        logDebug("Deleting processed files with options: ", options);

        const { formId, inputId } = options || {};
        const config = _processedFileStorage[formId];

        if (!!config) {
            const inputs = config.inputs;

            if (!!inputId && inputs instanceof Array) {
                const input = inputs.find(inp => inp.id === inputId);
                if (!!input) {
                    delete input.id;
                    delete input.name;
                    delete input.files;
                }
            }

            // remove the entire storage for the specified form
            delete _processedFileStorage[formId];
            logDebug("Deleted processed file storage for form #" + formId);
            return true;
        } else {
            logDebug("No processed files associated with form #" + formId);
        }

        return false;
    }

    /**
     * Collect all processed (approved) files before submitting the form.
     * @param {string} formId The form identifier.
     * @returns {[{name: string, value: File}]}
     */
    function collectFilesOnFormSubmit(formId) {
        return collectInputFiles(formId).concat(collectDragDropFiles(formId));
    }

    /**
     * Collect all input files found in the specified form identifier.
     * @param {string} formId The form identifier.
     * @returns {[{name: string, value: File}]}
     */
    function collectInputFiles(formId) {
        const config = _processedFileStorage[formId];

        if (!config) {
            logDebug(formId, "No processed files found for form #" + formId);
            return [];
        }

        const { inputs } = config;
        const collected = [];

        for (let i = 0; i < inputs.length; i++) {
            const { id, name, files } = inputs[i];
            for (let k = 0; k < files.length; k++) {
                collected.push({
                    name,
                    value: files[k]
                });
            }
        }

        return collected;
    }

    /** 
     * Collect all files dropped so far.
     * @param {string} formId The form identifier.
     * @returns {[{name: string, value: File}]}
     */
    function collectDragDropFiles(formId) {
        logDebug(formId, "Collecting drag/drop files...");
        const collectedFiles = [];

        for (const dropTargetId in _dragDropStorage) {
            if (_dragDropStorage.hasOwnProperty(dropTargetId)) {
                const config = _dragDropStorage[dropTargetId];
                const { droppedFiles } = config;

                if (!!droppedFiles && droppedFiles.fileCount > 0) {
                    for (const inputName in droppedFiles) {
                        if (droppedFiles.hasOwnProperty(inputName)) {
                            const fileList = droppedFiles[inputName];

                            for (let i = 0; i < fileList.length; i++) {
                                collectedFiles.push({
                                    name: inputName,
                                    value: fileList[i]
                                });
                            }
                        }
                    }
                } else {
                    logDebug(formId, `No file dropped onto target #${dropTargetId}.`);
                }
            }
        }

        logDebug(formId, `Collected ${collectedFiles.length} drag and drop file(s) for target elements.`);
        return collectedFiles;
    }

    /**
     * Make sure that only successfully processed files are submitted with the form data.
     * @param {string} formId The form identifier.
     * @param {FormData} formData The form data to check.
     */
    function clearFilesAppendProcessed(formId, formData) {
        if (!formId || !formData) {
            logError(formId, "formId and formData parameters must be set when validating processed files.");
            return false;
        }

        logDebug(formId, "Validating processed files on form submit");

        // get processed files...
        const processedFiles = collectFilesOnFormSubmit(formId);
        const hasFiles = processedFiles.length > 0;

        if (hasFiles) {
            clearFormDataFiles(formId, formData);
        }

        // ... and append them
        processedFiles.forEach(({ name, value: file }) => {
            formData.append(name, file, file.name);
        });

        return hasFiles;
    }

    /**
     * Remove all files from the specified form data.
     * @param {string} formId The form identifier.
     * @param {FormData} formData The form data to clear.
     */
    function clearFormDataFiles(formId, formData) {
        if (!formData) return false;

        // first, grab the keys to avoid deleting 
        // entries from the formData while enumerating
        const keys = [];

        for (const key of formData.keys()) {
            keys.push(key);
        }

        logDebug(formId, "Removing all files from form data; keys are: ", keys);

        let success = false;

        // delete all files
        for (let i = 0; i < keys.length; i++) {
            const entry = formData.get(keys[i]);
            if (entry instanceof File) {
                formData.delete(keys[i]);
                success = true;
            }
        }

        return success;
    }

    global.BlazorFormManager.registerInteropAssembly("BlazorFormManager");
})(window);
