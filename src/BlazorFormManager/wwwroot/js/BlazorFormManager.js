/*
 Name:          BlazorFormManager
 Version:       1.4.0
 Author:        Abdourahamane Kaba
 Description:   Handle AJAX form data submission with zero or more files, and
                report back data upload activities to a .NET Blazor Component.
 License:       Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
 Copyright:     © Karfamsoft. All rights reserved.
 */
(function (global) {
    // "use strict";
    const XHRSTATE = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 };
    const CONSOLE_FUNC = { info: "info", warn: "warn", error: "error", log: "log" };
    const LOG_LEVEL = { none: 0, information: 1, warning: 2, error: 3, debug: 4 };
    const UPLOAD_EVENTS = { loadstart: 0, progress: 1, load: 2, error: 3, abort: 4, timeout: 5, loadend: 6 };
    const PRIMITIVES = ["string", "number", "bigint", "boolean"];
    const FILE_READER_FUNC = { 1: "readAsArrayBuffer", 2: "readAsBinaryString", 3: "readAsDataURL", 4: "readAsText" };
    const READ_FILE_LIST_EVENTS = { start: 0, rejected: 1, processed: 2, end: 3 };
    const READ_FILE_LIST_REJECTION = { none: 0, extension: 1, type: 2, multiple: 3, aborted: 4 };
    const DROP_EFFECTS = { none: 0, copy: 1, link: 2, move: 3 };
    const DROP_EFFECTS_ALLOWED = { none: 0, copy: 1, copyLink: 2, copyMove: 3, link: 4, linkMove: 5, move: 6, all: 7, uninitialized: 8 };

    const _defaultImagePreviewOptions = {
        autoGenerate: true,
        generateFileInfo: true,
        attributeName: "src",
        tagName: "img",
        tagClass: "blazor-form-manager-image-preview",
        autoGeneratedClass: "form-manager-auto-generated",
        wrapperSelector: ".image-wrapper",
        width: 150,
        height: 0,
        preserveAspectRatio: true,
        noResize: false,
    };

    const _dotnet = global.DotNet;
    const _document = global.document;
    const _supportsAJAXwithUpload = supportsAjaxUploadWithProgress();
    const _supportsFileReader = !!global.FileReader;
    const _dragDropStorage = {};
    const _imageUtilAvailable = supportsImageUtil();

    let _form;
    let _managerOptions;
    let _invokableInstanceRef;

    /** Field required to abort the readFileList function. */
    let _readFileListAborted = false;

    global.BlazorFormManager = {
        init: async function (options, objInstanceRef) {
            _managerOptions = options;
            _invokableInstanceRef = objInstanceRef;
            logDebug("Initializing with options:", options);

            // fail early
            if (!_isObject(options) || !_isString(options.formId))
                return showOptionsUsage(true);

            if (!validateFormAttributes(options.formId)) {
                return false;
            }

            if (!!_invokableInstanceRef) {
                logDebug("Invokable object instance reference received.", _invokableInstanceRef);
            } else {
                logWarning("Invokable object instance reference not received. " +
                    "This is the preferred way of invoking.NET methods from " +
                    "withing Blazor components.");
            }

            registerSubmitHandler();
            logInfo("Initialized successfully!");
            return true;
        },
        setLogLevel: function (level) {
            if (!!_managerOptions) {
                if (_managerOptions.logLevel !== level) {
                    if (typeof level === "number") {
                        const validLevel = 0 | level; // force the number to be an integer
                        if (validLevel > -1 && validLevel < 5) {
                            _managerOptions.logLevel = validLevel;
                            logInfo("Log level changed to", validLevel);
                            return true;
                        }
                    }
                    logError("Log level must be an integer between 0 and 4 inclusive.");
                }
            } else {
                logError("Initialization has not been done yet.");
            }
            return false;
        },
        updateOptions: function (options) {
            logDebug("Updating script options", options);

            if (!_isObject(options)) {
                logError("Invalid options", options);
                return false;
            }

            if (!_managerOptions) {
                _managerOptions = options;
                logDebug("Entire script options set.");
            } else {
                let count = 0;
                for (const key in options) {
                    if (options.hasOwnProperty(key)) {
                        _managerOptions[key] = options[key];
                        count++;
                    }
                }
                logDebug(`Script properties updated: ${count}`);
            }

            return true;
        },
        raiseAjaxUploadWithProgressNotSupported: function () {
            logDebug("raiseAjaxUploadWithProgressNotSupported() invoked in script.");
            raiseAjaxUploadWithProgressNotSupported();
        },
        submitForm: function () {
            logDebug("Form submit requested.");

            if (!_form) {
                logInfo("Form not defined");
                return false;
            }

            if (!!_form.onsubmit) {
                _form.onsubmit();
                logInfo("Form submitted via 'BlazorFormManager.submitForm'.")
                return true;
            }

            logDebug("Form's 'onsubmit' event handler not defined.");
            return false;
        },
        localStorageSetItem: function (key, value) {
            localStorage.setItem(key, value);
        },
        localStorageRemoveItem: function (key) {
            localStorage.removeItem(key);
        },
        localStorageGetItem: function (key) {
            return localStorage.getItem(key);
        },
        readInputFiles,
        dragDropEnable,
        dragDropDisable,
        dragDropRemoveFileList,
        dragDropInputFilesOnTarget
    };

    /**
    * Register an AJAX handler for the submission of a form with a file.
    */
    function registerSubmitHandler() {
        const {
            formId,
            onGetModel,
            onBeforeSubmit,
            onBeforeSend,
            onSendFailed,
            onSendSucceeded,
            requireModel
        } = _managerOptions;

        handleFormSubmission({
            formId,
            requireModel,
            getFormData: async () => {
                // custom routine for retrieving form data defined with models
                let model;

                if (_isString(onGetModel)) {
                    model = await invokeDotNet(onGetModel);
                    logDebug("Model", model);
                }

                if (model === null) {
                    if (requireModel) {
                        logError("A model is required.");
                    } else {
                        logDebug("Model not defined. FormData will be collected by caller.");
                    }
                    return { formData: null };
                }

                logDebug("Collecting form model data...");

                // collect existing inputs from the form
                const form = _document.getElementById(formId);
                const formData = new FormData(form);

                // add additional form data values using the model...
                collectModelData(model, formData);

                // check if the form contains any files
                const hasFiles = containsFiles(form);
                return { formData, hasFiles };
            },
            beforeSubmit: async () => {
                let cancel = false;
                if (_isString(onBeforeSubmit))
                    cancel = await invokeDotNet(onBeforeSubmit);
                return cancel;
            },
            beforeSend: async () => {
                let cancel = false;
                if (_isString(onBeforeSend))
                    cancel = await invokeDotNet(onBeforeSend,
                        getXhrResult.call(this, true)
                    );
                return cancel;
            },
            done: function () {
                logInfo("Form data successfully uploaded.");

                if (_isString(onSendSucceeded))
                    invokeDotNet(onSendSucceeded,
                        getXhrResult.call(this, false)
                    );
            },
            fail: function (error) {
                logError("Form upload failed.");
                logDebug("XHR", this);

                if (_isString(onSendFailed))
                    invokeDotNet(onSendFailed,
                        getXhrResult.call(this, false, error)
                    );
            }
        });

        function getXhrResult(excludeHeaders, error) {
            const extraProperties = !!error ? { error } : {};

            return {
                response: this.response || null,
                responseHeaders: excludeHeaders ? null : this.getAllResponseHeaders(),
                responseText: this.responseText || "",
                responseType: this.responseType || "",
                responseXML: this.responseXML || "",
                status: 0 | this.status,
                statusText: this.statusText || "",
                timeout: 0 | this.timeout,
                extraProperties,
            };
        }
    }

    function handleFormSubmission(options) {
        options || (options = {});
        const { formId, requireModel } = options;

        if (!formId) {
            logError("No form to upload identified!");
            return false;
        }

        const form = _document.getElementById(formId);
        if (!form) {
            logError(`Form with id #${formId} not found!`);
            return false;
        }

        form.onsubmit = async () => {
            logDebug("Submitting form...");
            let cancel = false;
            const { beforeSubmit } = options;

            if (_isFunction(beforeSubmit)) cancel = await beforeSubmit.call(form);

            if (cancel) {
                logInfo("Form submissing was cancelled.");
                return false;
            }

            // With nowadays (modern) browsers, this is VERY unlikely, but just in case...
            if (!_supportsAJAXwithUpload) {
                logWarning("AJAX upload with progress report not supported.");

                cancel = await raiseAjaxUploadWithProgressNotSupported();

                if (cancel) {
                    // do not allow full page refresh
                    logInfo("Blocked submitting form with full-page refresh.");
                    return false;
                }

                // allow normal form submission (post back with full page refresh)
                return true;
            }

            const { beforeSend, done, fail, getFormData } = options;
            let { formData, hasFiles } = await getFormData();

            if (formData === null || formData === undefined) {
                if (requireModel) {
                    logError("Form submission cancelled because a model is required to continue.");
                    return false;
                } else {
                    formData = new FormData(form);
                    hasFiles = containsFiles(form);
                }
            }

            const fileCount = dragDropAppendFilesOnFormSubmit(formData);
            if (fileCount > 0) hasFiles = true;

            const xhr = new XMLHttpRequest();

            xhr.onreadystatechange = function () {
                if (this.readyState === XHRSTATE.DONE) {
                    // any status code between 200 and 299 inclusive is success
                    if (this.status > 199 && this.status < 300) {
                        if (_isFunction(done)) done.call(this);
                    } else if (_isFunction(fail)) {
                        fail.call(this);
                    }
                }
            };

            addXHRUploadEventListeners(xhr, hasFiles);

            const url = form.getAttribute("action");
            const method = (form.getAttribute("method") || "POST").toUpperCase();

            logDebug("Form action URL is:", url);
            logDebug("Form method is:", method);

            xhr.open(method, url, true);

            let headersSet = false;

            if (_isFunction(beforeSend)) {
                const xhrResult = await beforeSend.call(xhr);
                logDebug("beforeSend was called:", xhrResult);

                if (_isObject(xhrResult)) {
                    if (xhrResult.cancel) {
                        logDebug("XMLHttpRequest.send was cancelled.");
                        return false;
                    }

                    logDebug("Trying to set XMLHttpRequest (XHR) properties...");
                    try {
                        headersSet = setRequestHeaders(xhr, xhrResult.requestHeaders);
                        xhr.withCredentials = xhrResult.withCredentials;
                    } catch (e) {
                        logError("Error setting XHR properties.", e);
                        if (_isFunction(fail)) fail.call(xhr, e.message);
                        return false;
                    }
                }
            }

            if (!headersSet)
                setRequestHeaders(xhr, _managerOptions.requestHeaders);

            xhr.send(formData);
            return false; // To avoid actual submission of the form
        }

        _form = form;
        return true;
    }

    function showOptionsUsage(isError) {
        const optionalNameOfMethodWhen = "string (optional): The name of the .NET method to invoke when ";
        const options = {
            formId: "string (required): The unique identifier of the form to submit.",

            requireModel: "boolean (optional): Gets or sets a value that indicates whether specifying a " +
                "non-null reference model is required when the 'onGetModel' event is invoked. If this value is " +
                "true and no valid model is provided after that event, the form submission will be cancelled.",

            assembly: "string (optional): The name of the .NET assembly on which " +
                "to invoke static methods. Required if any of the 'onXXX' static " +
                "method names are set.",

            logLevel: "number (optional): The level of details when logging messages " +
                "to the console. Supported values are: 0 (none), 1 (information), " +
                "2 (warning), 3 (error), 4 (debug). The default is 3.",

            requestHeaders: "object (optional): A dictionary of key-value pairs to set on an instance of XMLHttpRequest.",

            onGetModel: optionalNameOfMethodWhen + "retrieving the form model.",
            onBeforeSubmit: optionalNameOfMethodWhen + "submitting the form. This event can be cancelled.",
            onBeforeSend: optionalNameOfMethodWhen + "sending the HTTP request. This event can be cancelled.",
            onSendFailed: optionalNameOfMethodWhen + "the HTTP request fails.",
            onSendSucceeded: optionalNameOfMethodWhen + "the HTTP request completes successfully.",
            onUploadChanged: optionalNameOfMethodWhen + "an upload operation occurs.",
            onFileReaderChanged: optionalNameOfMethodWhen + "a change occurs in a file reading operation.",
            onFileReaderResult: optionalNameOfMethodWhen + "a file reading operation is completed successfully.",
            onAjaxUploadWithProgressNotSupported: optionalNameOfMethodWhen + "the browser does not support AJAX uploads with progress report.",
        };

        const message = "Initialization options must be a variation of the following format:";

        if (isError) logError(message, options);
        else logInfo(message, options);

        return false;
    }

    function validateFormAttributes(formId) {
        const frm = _document.getElementById(formId);
        if (!frm) {
            logError(`The form element identified by '${formId}' does not exist in the DOM.`);
            return false;
        }
        if (!_isString(frm.getAttribute("action"))) {
            logError("The form action attribute is not defined.");
            return false;
        }
        return true;
    }

    /**
     * Recursively append to the specified form data 
     * properties and values from the given model.
     * @param {any} model The model from which to collect form data.
     * @param {FormData} formData The FormData object to which collected values are appended.
     * @param {string} path The current navigation path to a given property of the model.
     */
    function collectModelData(model, formData, path) {
        if (_isObject(model) && !(model instanceof Date) && !(model instanceof File) && !(model instanceof Blob)) {
            Object.keys(model).forEach(key => {
                collectModelData(model[key], formData, path ? `${path}[${key}]` : key);
            });
        } else {
            const value = (model === null || model === undefined) ? '' : model;
            formData.append(path, value);
        }
    }

    /**
     * Check if the specified form contains at least one file to upload.
     * @param {any} form The form to query.
     */
    function containsFiles(form) {
        const inputs = form.querySelectorAll("input[type=file]");
        for (let i = 0; i < inputs.length; i++) {
            if (inputs[i].files && inputs[i].files.length) {
                return true;
            }
        }
        return false;
    }

    async function raiseAjaxUploadWithProgressNotSupported() {
        let cancel = false;
        if (!!_managerOptions) {
            const { onAjaxUploadWithProgressNotSupported } = _managerOptions;

            if (_isString(onAjaxUploadWithProgressNotSupported)) {
                const navigatorInfo = {};
                populateDictionary(navigatorInfo, global.navigator);
                logDebug("Navigator properties collected", navigatorInfo);

                cancel = await invokeDotNet(onAjaxUploadWithProgressNotSupported,
                    { extraProperties: navigatorInfo }
                );
            }
        }
        return cancel;
    }

    function supportsAjaxUploadWithProgress() {
        return supportsFileAPI() &&
            supportsAjaxUploadProgressEvents() &&
            supportsFormData();

        function supportsFileAPI() {
            var fi = _document.createElement("INPUT");
            fi.type = "file";
            return "files" in fi;
        };

        function supportsAjaxUploadProgressEvents() {
            var xhr = "XMLHttpRequest" in global && new XMLHttpRequest();
            return !!(xhr && ("upload" in xhr) && ("onprogress" in xhr.upload));
        };

        function supportsFormData() {
            return !!global.FormData;
        }
    }

    function invokeDotNet(method, arg) {
        if (arg === undefined) arg = null;

        if (!!_invokableInstanceRef) {
            logDebug(`Invoking .NET method "${method}" using object instance.`, arg);
            return _invokableInstanceRef.invokeMethodAsync(method, arg);
        } else {
            logDebug(`Invoking .NET method "${method}" using static type`, arg);
            return _dotnet.invokeMethodAsync(_managerOptions.assembly, method, arg);
        }
    }

    function addXHRUploadEventListeners(xhr, hasFiles) {
        const { onUploadChanged } = _managerOptions;
        if (!_isString(onUploadChanged)) return;
        logDebug("Setting up upload event handlers...");
        addFileReaderOrUploadEventListeners(xhr, xhr.upload, onUploadChanged, hasFiles);
    }

    /**
     * Set up event handlers for a FileReader object.
     * @param {FileReader} reader A FileReader object to which event listeners will be added.
     * @param {object} alternateHandlers Optional: An configuration options object to specify alternate event handlers.
     * Property names may be any of the following functions:
     * 'onstart' Event handler to invoke when the operation starts.
     * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
     * 'onsuccess' Event handler to invoke when the operation completes successfully.
     * 'onfinish' Event handler to invoke when the operation finishes.
     * 'onabort' Event handler to invoke when the operation is aborted.
     * 'onerror' Event handler to invoke when an error occurs.
     */
    function addFileReaderEventListeners(reader, alternateHandlers) {
        const { onFileReaderChanged } = _managerOptions;
        if (!_isString(onFileReaderChanged)) return;

        addFileReaderOrUploadEventListeners(reader, reader, onFileReaderChanged, true, alternateHandlers);
    }

    /**
     * Set up event handlers for an XMLHttpRequest.upload or FileReader object.
     * @param {object} owner The object that owns the eventTarget (on which 'abort()' should be called if requested).
     * @param {object} eventTarget An object to which event listeners will be added.
     * If it's an XMLHttpRequest instance then it should its 'upload' property.
     * Otherwise, this is the same object has the 'owner'.
     * @param {string} interopCallback The name of the .NET callback function to invoke when a change occurs.
     * @param {boolean} hasFiles true if it's an upload operation with files; otherwise, false.
     * @param {object} alternateHandlers Optional: An configuration options object to specify alternate event handlers.
     * Property names may be any of the following functions:
     * 'onstart' Event handler to invoke when the operation starts.
     * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
     * 'onsuccess' Event handler to invoke when the operation completes successfully.
     * 'onfinish' Event handler to invoke when the operation finishes.
     * 'onabort' Event handler to invoke when the operation is aborted.
     * 'onerror' Event handler to invoke when an error occurs.
     */
    function addFileReaderOrUploadEventListeners(owner, eventTarget, interopCallback, hasFiles, alternateHandlers) {

        /**
         * Handles a progress event.
         * @param {ProgressEvent<XMLHttpRequest>|ProgressEvent<FileReader>} e The event data.
         */
        async function handleEvent(e) {
            return invokeDotNet(interopCallback, {
                bytesReadOrSent: e.loaded,
                totalBytesToReadOrSend: e.total,
                eventType: UPLOAD_EVENTS[e.type] | 0,
                hasFiles
            });
        }

        let { onstart, onprogress, onsuccess, onfinish, onabort, onerror } = alternateHandlers || {};

        if (!onstart) onstart = handleEvent;

        // The upload/read has begun.
        addEventHandler(eventTarget, 'loadstart', onstart);

        if (!onsuccess) onsuccess = handleEvent;

        // The upload/read completed successfully.
        addEventHandler(eventTarget, 'load', onsuccess);

        if (!onfinish) onfinish = handleEvent;

        /**
         * The upload/read finished. This event does not differentiate between
         * success or failure, and is sent at the end of the upload
         * regardless of the outcome. Prior to this event, one of load,
         * error, abort, or timeout will already have been delivered to
         * indicate why the upload ended.
         */
        addEventHandler(eventTarget, 'loadend', onfinish);

        if (!onprogress)
            onprogress = function (e) {
                handleEvent(e).then(cancel => (cancel) && owner.abort());
            };

        // Periodically delivered to indicate the amount of progress made so far.
        addEventHandler(eventTarget, 'progress', onprogress);

        if (!onerror) onerror = handleEvent;

        // The upload/read failed due to an error.
        addEventHandler(eventTarget, 'error', onerror);

        if (!onabort) onabort = handleEvent;

        // The upload/read operation was aborted.
        addEventHandler(eventTarget, 'abort', onabort);

        if ('ontimeout' in eventTarget) {
            // The upload timed out because a reply did not arrive within 
            // the time interval specified by the XMLHttpRequest.timeout.
            addEventHandler(eventTarget, 'timeout', handleEvent);
        }
    }

    /**
     * Set request headers on the specified XMLHttpRequest object.
     * @param {XMLHttpRequest} xhr
     * @param {Object} headers An initialized object.
     */
    function setRequestHeaders(xhr, headers) {
        if (!_isDictionary(headers)) return false;

        logDebug("Setting request headers...");

        for (const name in headers) {
            if (headers.hasOwnProperty(name)) {
                const value = headers[name];
                logDebug("Header:", { name, value });
                xhr.setRequestHeader(name, value);
            }
        }

        return true;
    }

    function logInfo() {
        log(CONSOLE_FUNC.info, ...arguments);
    }

    function logWarning() {
        log(CONSOLE_FUNC.warn, ...arguments);
    }

    function logError() {
        log(CONSOLE_FUNC.error, ...arguments);
    }

    function logDebug() {
        log(CONSOLE_FUNC.log, ...arguments);
    }

    function log(func, ...args) {
        const { logLevel = LOG_LEVEL.debug } = _managerOptions;

        if (logLevel === LOG_LEVEL.none) return;

        func || (func = CONSOLE_FUNC.info);
        const argument = [`${func === "log" ? "debug" : func}: BlazorFormManager:`, ...args];

        if (logLevel === LOG_LEVEL.debug)
            console[func].apply(console, argument);

        else if (func === CONSOLE_FUNC.error && logLevel >= LOG_LEVEL.error)
            console.error.apply(console, argument);

        else if (func === CONSOLE_FUNC.warn && logLevel >= LOG_LEVEL.warning)
            console.warn.apply(console, argument);

        else if (func === CONSOLE_FUNC.info && logLevel >= LOG_LEVEL.information)
            console.info.apply(console, argument);
    }

    function _isString(obj) {
        return !!obj && typeof obj === "string" && ("" + obj).trim().length;
    }

    function _isObject(obj) {
        return !!obj && typeof obj === "object";
    }

    function _isFunction(obj) {
        return !!obj && typeof obj === "function";
    }

    function _isDictionary(obj) {
        return _isObject(obj) && Object.keys(obj).length;
    }

    /**
     * Builds a dictionary of primitive types.
     * @param {any} dic
     * @param {any} obj
     */
    function populateDictionary(dic, obj) {
        if (!obj) return;
        for (const prop in obj) {
            const value = obj[prop];
            const type = typeof value;
            if (value === undefined || value === null) continue;
            if (value instanceof Array || PRIMITIVES.indexOf(type) > -1) {
                dic[prop] = value;
            }
        }
    }

    async function readInputFiles(options, processedFileListCallback) {
        const ERROR_CODE_BASE = 100;
        let succeeded = false, error = '', code = 0;

        if (!_supportsFileReader) {
            return { succeeded, error: "Your device does not support the FileReader API.", code: ERROR_CODE_BASE + 1 };
        }

        logDebug("Reading file(s) from input using options", options);
        const { method, inputId } = options;

        // The .NET callback method name to invoke when the operation 
        // completes, unless the imagePreviewElement parameter is set.
        const { onFileReaderResult } = _managerOptions;

        if (FILE_READER_FUNC[method] === undefined) {
            succeeded = false;
            code = ERROR_CODE_BASE + 2;
            error = `Unsupported file reader method: ${method}`;
        } else if (_isString(inputId) && _isString(onFileReaderResult)) {
            const input = _document.getElementById(inputId);

            if (!!input && 'files' in input) {
                return readFileList(input.files, options, processedFileListCallback);
            } else {
                code = ERROR_CODE_BASE + 4;
                error = `Specified input id #${inputId} does not identify an input element of type 'file'.`;
            }
        } else {
            code = ERROR_CODE_BASE + 3;
            error = `Invalid file reader options: 'inputId', and/or 'onFileReaderResult' not present.`;
        }

        logError(error);
        succeeded = false;
        return { succeeded, error, code };
    }

    function enforceMultipleFilesPolicy(dropTargetId, fileCount) {
        if (fileCount > 1)
            logWarning(`Dropping multiple files (${fileCount}) here is not allowed. Picking first and ignoring the rest.`);

        fileCount = dragDropGetFileCount(dropTargetId);
        logDebug("dragDropGetFileCount", fileCount);

        // remove existing files
        if (fileCount > 0) dragDropRemoveFileList(dropTargetId);
    }

    /**
     * Read a list of files.
     * @param {FileList|File[]} fileList The list of files to read.
     * @param {any} options An object that encapsulates settings for file reading operations.
     * @param {Function} processedFileListCallback A callback function that receives an array of the files effectively processed.
     * @param {boolean} storeOnly true to validate file acceptance and store files without reading them; otherwise, false.
     */
    async function readFileList(fileList, options, processedFileListCallback, storeOnly) {
        const ERROR_CODE_BASE = 200;
        const fileCount = fileList && fileList.length || 0;

        if (fileCount > 0) {
            const { accept, acceptType, multiple, dropTargetId } = options;

            // check for multiple files
            if (!multiple) enforceMultipleFilesPolicy(dropTargetId, fileCount);

            const hasAccept = _isString(accept);
            const hasAcceptType = _isString(acceptType);
            const acceptAllFiles = !(hasAccept || hasAcceptType);
            const supportedFiles = acceptAllFiles
                ? undefined
                : hasAccept ? accept.split(',').map(type => type.trim().toLowerCase()) : undefined;

            const processedFileList = [];
            const { onReadFileList } = _managerOptions;
            const hasCallback = _isFunction(processedFileListCallback);
            const hasOnReadFileList = _isString(onReadFileList);
            const abortedByUser = "File list reading operation has been aborted by user";

            let notAllowed = false;
            let dimensions = { width: 0, height: 0 };

            _readFileListAborted = false;

            if (acceptAllFiles) logDebug("Any file accepted.");

            if (hasOnReadFileList)
                await invokeDotNet(onReadFileList, { type: READ_FILE_LIST_EVENTS["start"], totalFilesToRead: fileCount });

            for (let i = 0; i < fileCount; i++) {
                logDebug(`Processing file... ${i + 1} of ${fileCount}`);

                const file = fileList[i];

                if (!acceptAllFiles) {
                    if (hasAccept) {
                        if (!supportsFileExtension(file.name)) {
                            logWarning(`File "${file.name}" is not allowed.`);
                            notAllowed = true;

                            if (hasOnReadFileList) {
                                const evArgs = {
                                    type: READ_FILE_LIST_EVENTS["rejected"],
                                    reason: READ_FILE_LIST_REJECTION["extension"],
                                    file: createFileInfo(file),
                                    filesRead: i + 1,
                                    totalFilesToRead: fileCount
                                };
                                const { cancel } = await invokeDotNet(onReadFileList, evArgs);
                                if (cancel) {
                                    _readFileListAborted = true;
                                    logDebug(`${abortedByUser} after rejected file extension.`);
                                    break;
                                }
                            }

                            continue;
                        }
                    }

                    if (hasAcceptType) {
                        // checking could be more elaborated using regex but for now it'll do it
                        if (file.type && file.type.indexOf(acceptType) === -1) {
                            logWarning(`File "${file.name}" of type ${file.type} is not allowed.`);
                            notAllowed = true;

                            if (hasOnReadFileList) {
                                const evArgs = {
                                    type: READ_FILE_LIST_EVENTS["rejected"],
                                    reason: READ_FILE_LIST_REJECTION["type"],
                                    file: createFileInfo(file),
                                    filesRead: i + 1,
                                    totalFilesToRead: fileCount
                                };
                                const { cancel } = await invokeDotNet(onReadFileList, evArgs);
                                if (cancel) {
                                    _readFileListAborted = true;
                                    logDebug(`${abortedByUser} after rejected file type.`);
                                    break;
                                }
                            }

                            continue;
                        }
                    }
                }

                dimensions = null;

                if (!storeOnly) {
                    logDebug(`Reading file ${file.name}`);

                    const result = await readFileCore(
                        file,
                        options,
                        async dataURL => dimensions = await generateImagePreview(dataURL, file, options)
                    );

                    if (!!result.aborted) {
                        _readFileListAborted = true;
                        break;
                    }
                }

                if (hasCallback) processedFileList.push(file);

                if (hasOnReadFileList) {
                    const evArgs = {
                        type: READ_FILE_LIST_EVENTS["processed"],
                        file: createFileInfo(file, dimensions),
                        filesRead: i + 1,
                        totalFilesToRead: fileCount
                    };
                    const { cancel } = await invokeDotNet(onReadFileList, evArgs);
                    if (cancel) {
                        _readFileListAborted = true;
                        logDebug(abortedByUser);
                        break;
                    }
                }

                if (_readFileListAborted) break;

                if (!multiple) {
                    if (fileCount > 1) {
                        logWarning(`Processing multiple files (${fileCount}) is not allowed. The remaining files are ignored.`);

                        if (hasOnReadFileList) {
                            const evArgs = {
                                type: READ_FILE_LIST_EVENTS["rejected"],
                                reason: READ_FILE_LIST_REJECTION["multiple"],
                                files: [...fileList].slice(i + 1).map(f => createFileInfo(f)),
                                filesRead: i + 1,
                                totalFilesToRead: fileCount
                            };
                            await invokeDotNet(onReadFileList, evArgs);
                        }
                    }
                    break;
                }
            }

            if (_readFileListAborted) logDebug("Exited 'readFileList' loop prematurely!");

            const filesRead = processedFileList.length;

            if (!multiple && notAllowed) resetInputFile(options.inputFileId);
            if (hasCallback && filesRead && !_readFileListAborted) processedFileListCallback.call(this, processedFileList);

            if (hasOnReadFileList) {
                await invokeDotNet(onReadFileList, {
                    type: READ_FILE_LIST_EVENTS["end"],
                    reason: _readFileListAborted ? READ_FILE_LIST_REJECTION["aborted"] : READ_FILE_LIST_REJECTION["none"],
                    filesRead,
                    totalFilesToRead: fileCount
                })
            }

            _readFileListAborted = false;
            return { succeeded: true, error: null, code: 0 };

            function supportsFileExtension(name) {
                name = (name || "").toLowerCase();
                for (let i = 0; i < supportedFiles.length; i++)
                    if (name.endsWith(supportedFiles[i]))
                        return true;
                return false;
            }
        } else {
            const error = "No file available to read.";
            logDebug(error);
            return { succeeded: false, error, code: ERROR_CODE_BASE + 1 };
        }
    }

    /**
     * Read a file.
     * @param {File} file
     * @param {any} options
     * @param {Promise<void>} setDataURLCallback
     */
    async function readFileCore(file, options, setDataURLCallback) {
        const { onFileReaderResult } = _managerOptions;
        try {
            const { method, inputId = null, inputName = null } = options;

            // create a Promise that takes care of reading the file
            const promiseResult = await createFileReaderPromise(file, method);
            const { succeeded, aborted, content } = promiseResult;
            let result, contentArray;
            const methodName = FILE_READER_FUNC[method];

            if (succeeded) {
                if (methodName === "readAsArrayBuffer") {
                    // convert to a 'normal' array
                    contentArray = Array.prototype.slice.call(new Uint8Array(content));
                    result = { contentArray };

                } else if (_isFunction(setDataURLCallback) &&
                    methodName === "readAsDataURL" &&
                    file.type && file.type.indexOf("image") !== -1) {

                    await setDataURLCallback.call(this, content);
                    result = { completedInScript: true };
                } else {
                    result = { content };
                }
            } else {
                result = {};
            }

            result.succeeded = succeeded;
            result.aborted = !!aborted;

            // given back these properties makes the identification 
            // in the 'onFileReaderResult' callback more accurate
            result.method = method;
            result.inputId = inputId;
            result.inputName = inputName;

            if (_isString(onFileReaderResult))
                await invokeDotNet(onFileReaderResult, result);

            // clean up
            if (!result.completedInScript) {
                result.content = null;
                result.contentArray = null;
            }

            return result;
        } catch (e) {
            const error = e.message || e;
            const result = { succeeded: false, error };

            logError(e);

            if (_isString(onFileReaderResult)) await invokeDotNet(onFileReaderResult, result);

            return result;
        }
    }

    /**
     * Create a Promise that will handle all supported file reading events and notifications to the Blazor app.
     * @param {File} file The file to read.
     * @param {number} method An integer between 1 and 4.
     * @return {Promise<{succeeded: boolean, aborted: boolean, content: string|ArrayBuffer}>}
     */
    function createFileReaderPromise(file, method) {
        const methodName = FILE_READER_FUNC[method];
        const { onFileReaderChanged } = _managerOptions;

        return new Promise((resolve, reject) => {
            try {
                let succeeded = false;
                let aborted = false;
                const reader = new FileReader();

                // custom event handlers
                const onstart = e => raiseNotification(e);

                const onprogress = async e => {
                    const cancel = await raiseNotification(e);
                    if (cancel) {
                        // Phew! This one was hard to debug...!
                        // The local 'aborted' flag isn't enough for a small-sized file;
                        // it may have already been read to end after the notification returns,
                        // hence the 'readFileList' function won't get a chance to quit because
                        // the 'aborted' property isn't set in the resolved object.

                        // That's why we also set the '_readFileListAborted' field to true in
                        // case the current promise was created in the call-chain of 'readFileList'.
                        _readFileListAborted = aborted = true;

                        reader.abort();
                        logWarning("File reading operation was aborted on demand.");
                    }
                };

                // onload
                const onsuccess = e => {
                    succeeded = !aborted;
                    return raiseNotification(e);
                };

                // onloadend
                const onfinish = async e => {
                    await raiseNotification(e);
                    resolve({ succeeded, aborted, content: aborted ? null : e.target.result });
                };

                const onerror = async e => {
                    const error = `Failed to read file! Reason: ${reader.error}`;
                    logDebug(error);
                    await raiseNotification(e, error);
                    reject(error);
                };

                const onabort = async () => {
                    _readFileListAborted = aborted = true;
                };

                const alternateHandlers = { onstart, onprogress, onsuccess, onfinish, onerror, onabort };
                addFileReaderEventListeners(reader, alternateHandlers);

                logDebug("Attempting to read file using method", methodName);

                switch (methodName) {
                    case "readAsArrayBuffer":
                        reader.readAsArrayBuffer(file);
                        break;
                    case "readAsBinaryString":
                        reader.readAsBinaryString(file);
                        break;
                    case "readAsDataURL":
                        reader.readAsDataURL(file);
                        break;
                    case "readAsText":
                        reader.readAsText(file);
                        break;
                    default:
                        reject(new Error(`Unsupported method: ${method}`));
                }
            } catch (e) {
                logDebug("Error reading file", e);
                reject(e);
            }
        });

        /**
         * Invoke .NET method when a progress event is received.
         * @param {ProgressEvent<FileReader>} e The event data.
         * @param {string} error Optional: A message that describes the error that might have occurred.
         */
        async function raiseNotification(e, error) {
            const eventType = UPLOAD_EVENTS[e.type] | 0;
            const eventData = {
                bytesReadOrSent: e.loaded,
                totalBytesToReadOrSend: e.total,
                eventType,
                hasFiles: true,
                error: error || null
            };
            if (eventType === 0) eventData.file = createFileInfo(file);
            return invokeDotNet(onFileReaderChanged, eventData);
        }
    }

    /**
     * Create a file info object from the specified file.
     * @param {File} file
     * @param {{width: number, height: number}} dimensions Optional: The dimensions of the file if it's an image.
     */
    function createFileInfo(file, dimensions) {
        if (!_isObject(dimensions)) dimensions = null;
        return {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModifiedDate: new Date(file.lastModified),
            dimensions
        }
    }

    /**
     * Takes care of generating an image preview for the specified file.
     * @param {string} dataURL URL-encoded image data.
     * @param {File} file The file whose dataURL is provided.
     * @param {object} options An object used to generate an image.
     */
    async function generateImagePreview(dataURL, file, options) {
        const { dropTargetId, imagePreviewOptions } = options;

        if (!_isObject(imagePreviewOptions)) {
            logWarning("No image preview generation options set.");
        } else {
            const {
                autoGenerate, autoGeneratedClass, generateFileInfo, tagClass, tagId,
                tagName, src, wrapperSelector, width: desiredWidth, height: desiredHeight,
                preserveAspectRatio, noResize
            } = defaultPreviewOptionsFrom(imagePreviewOptions);

            if (_isString(tagId)) {
                const result = await getTargetElementById(tagId);
                const { succeeded, targetElement: image, error } = result;

                if (succeeded) {
                    addImageAttributes(image);
                    return {
                        width: (image.width || 0) | 0,
                        height: (image.height || 0) | 0
                    };
                }

                logError(error);

            } else if (autoGenerate) {
                const dropTarget = _document.getElementById(dropTargetId);
                let container = dropTarget;
                let image, width = 0, height = 0;

                if (!noResize && _imageUtilAvailable) {
                    logDebug("Generating preview with ImageUtil.");
                    const { canvas, naturalWidth, naturalHeight } = await new ImageUtil(dataURL).resize(desiredWidth, desiredHeight, preserveAspectRatio);
                    image = addImageAttributes(canvas, true, naturalWidth, naturalHeight);
                    width = naturalWidth;
                    height = naturalHeight;
                } else {
                    image = addImageAttributes(_document.createElement("" + tagName));
                }

                if (_isString(wrapperSelector)) {
                    if (wrapperSelector.startsWith("#")) {
                        // id specified, don't look for the element in the drop target
                        container = _document.querySelector(wrapperSelector);
                    } else {
                        // query first the dropTarget
                        if (!!dropTarget) container = dropTarget.querySelector(wrapperSelector);

                        // then query the document if not found
                        if (!container) container = _document.querySelector(wrapperSelector);
                    }

                    if (!container) {
                        // if an image container has been specified but not found, that's an error
                        logError(`Wrapper ${wrapperSelector} for auto-generated image not found in the DOM tree.`);
                    }
                }

                if (!container) container = dropTarget || _document;

                container.appendChild(image);

                return { width, height };

            } else {
                logWarning("Automatic image preview generation option is disabled!");
            }

            /**
             * Add attributes for an auto-generated image.
             * @param {HTMLElement} img The target HTML element to add attributes to.
             * Can be any HTML element but usually it's an <img /> or a <canvas></canvas> tag.
             * @param {boolean} skipSrc true to skip setting the 'src' attribute; otherwise, false.
             * @param {number} naturalWidth Optional: The original width of the image.
             * @param {number} naturalHeight The original height of the image.
             */
            function addImageAttributes(img, skipSrc, naturalWidth, naturalHeight) {
                const fileSize = fileSizeToString(file.size);

                if (!skipSrc) img.setAttribute(src, dataURL);

                // use classList to preserve existing classes
                addClassList(img, tagClass);

                if (generateFileInfo) {
                    /* A variation of what's built:
    
                     <span class="form-manager-auto-generated">
                        <img src="data:image;..."/>
                        <span class="file-info">
                            <span class="name">file_name.jpg</span>
                            <span class="size">98.29 KB</span>
                        </span>
                        <span class="bg-dimmed"></span>
                     </span>
                     */
                    const elcontainer = _document.createElement("span");
                    const elmeta = _document.createElement("span");
                    const elfilename = _document.createElement("span");
                    const elfilesize = _document.createElement("span");
                    const eldimmed = _document.createElement("span");
                    const eldimensions = naturalWidth && naturalHeight && _document.createElement("span") || null;

                    // add an internal class so that we can remove those created with the current script
                    elcontainer.setAttribute("class", autoGeneratedClass);
                    elmeta.setAttribute("class", "file-info");
                    elfilesize.setAttribute("class", "size");
                    elfilename.setAttribute("class", "name");
                    eldimensions && eldimensions.setAttribute("class", "dimensions");
                    eldimmed.setAttribute("class", "bg-dimmed");

                    elfilesize.textContent = fileSize;
                    elfilename.textContent = file.name;
                    eldimensions && (eldimensions.textContent = `${naturalWidth}x${naturalHeight}`);

                    elmeta.appendChild(elfilesize);
                    elmeta.appendChild(elfilename);
                    eldimensions && elmeta.appendChild(eldimensions);

                    elcontainer.appendChild(img);
                    elcontainer.appendChild(elmeta);
                    elcontainer.appendChild(eldimmed);

                    return elcontainer;
                } else {
                    addClassList(img, autoGeneratedClass).setAttribute("title", `${file.name} (${fileSize})`);
                    return img;
                }
            }
        }

        return { width: 0, height: 0 };
    }

    /**
     * Remove auto-generated images.
     * @param {HTMLElement} container Optional: The HTML element that contains the images. Defaults to document.
     */
    function removeAutoGeneratedImages(container) {
        const images = (container || _document).querySelectorAll(`.${_defaultImagePreviewOptions.autoGeneratedClass}`);
        for (let i = 0; i < images.length; i++) {
            const img = images[i];
            img.remove();
        }
    }

    async function getTargetElementById(id) {
        const ERROR_CODE_BASE = 300;
        if (_isString(id)) {
            const targetElement = _document.getElementById(id);

            if (!targetElement) {
                const error = notFound(id);
                const result = { succeeded: false, error, targetElement, code: ERROR_CODE_BASE + 2 };

                if (_isString(_managerOptions.onFileReaderResult))
                    await invokeDotNet(_managerOptions.onFileReaderResult, result);
                return result;
            }

            return { succeeded: true, error: undefined, targetElement, code: 0 };
        }

        return { succeeded: false, error: undefined, targetElement: undefined, code: ERROR_CODE_BASE + 1 }
    }

    /**
     * Enable drag and drop support for the target element.
     * @param {any} options An object that contains at least these 3 properties: 'dropTargetId', 'dropEffect', and 'inputName'.
     */
    async function dragDropEnable(options) {
        const ERROR_CODE_BASE = 400;
        logDebug("Enable drag and drop support with options", options);

        const {
            dropTargetId,
        } = options;

        let succeeded = false, error = '', code = 0;
        const targetId = "" + dropTargetId;

        if (targetId in _dragDropStorage) {
            code = ERROR_CODE_BASE + 1;
            error = `The drop target element identified by #${targetId} has already been registered.`;
            logDebug(error);
        } else {
            const dropTarget = _document.getElementById(targetId);

            if (!!dropTarget) {
                const { dropEffect = "copy", effectAllowed = "copy" } = options;

                /**
                 * A drag operation has started.
                 * @param {DragEvent} e
                 */
                const dragstart = async e => {
                    e.stopPropagation();
                    e.preventDefault();

                    let effectSet = false;
                    const dt = e.dataTransfer;

                    logDebug(`dragStart: dropEffect = ${dt.dropEffect} ; effectAllowed = ${dt.effectAllowed}`);

                    // Since _managerOptions can be updated, let's get the most current values
                    // of 'onDragStart' and 'onDrop' every time a drag and drop operation occurs.
                    const { onDragStart } = _managerOptions;

                    if (_isString(onDragStart)) {
                        const args = getMouseEventArgs(e);

                        args.dataTransfer = {
                            dropEffect: dt.dropEffect,
                            effectAllowed: dt.effectAllowed,
                            files: [],
                            items: [...dt.items].map(i => ({ kind: i.kind, type: i.type })),
                            types: dt.types
                        };

                        const result = await invokeDotNet(onDragStart, args);

                        if (_isObject(result)) {
                            const { data, dataFormat, effectAllowed: effect } = result;

                            if (_isString(data) && _isString(dataFormat)) {
                                dt.setData(dataFormat, data);
                                logDebug(`Drag start event data set. Format=${dataFormat}`, data);
                            }

                            if (_isString(effect)) {
                                dt.effectAllowed = effect;
                                effectSet = true;
                            }
                        }
                    }

                    if (!effectSet) dt.effectAllowed = effectAllowed;
                };

                /**
                 * Handles the 'dragover' event.
                 * @param {DragEvent} e
                 */
                const dragover = e => {
                    e.stopPropagation();
                    e.preventDefault();
                    e.dataTransfer.dropEffect = dropEffect;
                };

                // copy the options used for dropping so that they can 
                // be locally overriden without global consequences
                const dropOptions = Object.assign({}, options);

                const drop = function (e) {
                    handleDrop(e, dropOptions, dropTarget);
                };

                addEventHandler(dropTarget, 'dragstart', dragstart);
                addEventHandler(dropTarget, 'dragover', dragover);
                addEventHandler(dropTarget, 'drop', drop);

                // required to clean up the mess on demand
                _dragDropStorage[targetId] = {
                    dragstart, dragover,
                    drop,
                    options
                };

                succeeded = true;
                error = null;
                logDebug(`Drag and drop enabled for target element #${targetId}.`);
            } else {
                code = ERROR_CODE_BASE + 2;
                error = notFound(targetId, "drop target");
            }
        }

        return { succeeded, error, code };
    }

    /**
     * Clean up by removing drag and drop event listeners.
     * @param {string} targetId The drop target element identifier.
     */
    function dragDropDisable(targetId) {
        const ERROR_CODE_BASE = 500;
        // explicitly initialize these variables to 
        // make the return type of the function clear
        let succeeded = false, error = '', code = 0;

        if (targetId in _dragDropStorage) {
            const dropTarget = _document.getElementById(targetId);

            if (!!dropTarget) {
                const config = _dragDropStorage[targetId];

                dropTarget.removeEventListener("dragstart", config.dragstart);
                dropTarget.removeEventListener("dragover", config.dragover);
                dropTarget.removeEventListener("drop", config.drop);

                delete config.dragstart;
                delete config.dragover;
                delete config.drop;
                delete config.options;
                if ('droppedFiles' in config) delete config.droppedFiles;

                error = null;
                succeeded = true;
                logDebug(`Drag and drop disabled for #${targetId}.`);
            } else {
                code = ERROR_CODE_BASE + 2;
                error = notFound(targetId, "drop target");
            }

            delete _dragDropStorage[targetId];

        } else {
            code = ERROR_CODE_BASE + 1;
            error = `The event listeners for the drop target element #${targetId} ` +
                "do not exist or have already been removed.";
            logDebug(error);
        }

        return { succeeded, error, code };
    }

    /**
     * Remove dropped files and auto-generated images for the specified target element.
     * @param {string} dropTargetId The identifier of the drop target element.
     */
    function dragDropRemoveFileList(dropTargetId) {
        logDebug(`Attempting to remove dropped files for target element #${dropTargetId}...`);

        if (dropTargetId in _dragDropStorage) {
            const config = _dragDropStorage[dropTargetId];
            const { options } = config;
            const { inputName, imagePreviewOptions = _defaultImagePreviewOptions } = options;

            if ('droppedFiles' in config) {
                delete config.droppedFiles[inputName];
                delete config.droppedFiles;
                logDebug("Files deleted from drag and drop storage.");
            } else {
                logDebug("No files have been dropped onto the dedicated area.");
            }

            if (!!imagePreviewOptions) {
                const { tagId: previewId, attributeName: attr } = imagePreviewOptions;
                if (_isString(previewId)) {
                    // suppress image preview, if any
                    const image = _document.getElementById(previewId);
                    if (!!image) {
                        image.removeAttribute(attr || "src");
                        logDebug("Removed image preview.");
                    }
                    else
                        logDebug(`Image #${previewId} not found in the DOM tree.`);
                }
            }

            const dropTarget = _document.getElementById(dropTargetId);

            if (!!dropTarget) dropTarget.classList.add("drag-drop-area-empty");

            removeAutoGeneratedImages(dropTarget);

            return true;
        } else {
            logDebug("Target element not found in drag and drop storage.");
        }
        return false;
    }

    /**
     * Read files from an input identified by 'options.inputId' and add them to the 
     * temporary drag and drop storage identified by 'options.dropTargetId'.
     * @param {any} options An object containing the properties 'dropTargetId',
     * 'inputId', 'inputName', and 'method'.
     */
    async function dragDropInputFilesOnTarget(options) {
        const ERROR_CODE_BASE = 600;
        let succeeded = false, error = '', code = 0;
        const { dropTargetId, inputId, inputName, method } = options;

        // first, check if the drop target settings exist
        const config = _dragDropStorage[dropTargetId];

        if (!config) {
            code = ERROR_CODE_BASE + 1;
            error = `Drag and drop settings not found for element #${dropTargetId}.`;
            logError(error);
            return { succeeded, error, code };
        } else {
            // second, get a copy of the stored options from config
            const newOptions = Object.assign({}, config.options);

            // and set new properties appropriately
            newOptions.inputId = inputId;
            newOptions.method = method;
            newOptions.dropTargetId = dropTargetId;

            // finally, read the files and store the processed list into the drag and drop settings
            return await readInputFiles(newOptions, processedFiles => {
                dragDropAfterFilesProcessed(processedFiles, dropTargetId, inputName);
            });
        }
    }

    /**
     * Add the list of files to the drag and drop store.
     * @param {FileList} fileList The list of files to add.
     * @param {string} dropTargetId The identifier of the drop target element.
     * @param {string} inputName The name of the form field associated with the files.
     * @param {HTMLElement} dropTargetElement Optional: An HTML element that represents the drop target.
     * If not specified, 'dropTargetId' is used to retrieve it in the DOM. It is used to remove
     * the CSS class 'drag-drop-area-empty' from it.
     * @param {boolean} keepEmtpyClass true to keep the 'drag-drop-area-empty' class on the drop target.
     */
    function dragDropAfterFilesProcessed(fileList, dropTargetId, inputName, dropTargetElement, keepEmtpyClass) {
        if (fileList && fileList.length) {
            // store the dropped files for later use when submitting the form
            const cfg = _dragDropStorage[dropTargetId];
            if (!!cfg) {
                cfg.droppedFiles = { [inputName]: fileList, fileCount: fileList.length };
                logDebug(`Dropped files stored for target #${dropTargetId} and input ${inputName}.`);
                if (!keepEmtpyClass) {
                    dropTargetElement || (dropTargetElement = _document.getElementById(dropTargetId));
                    dropTargetElement && dropTargetElement.classList.remove("drag-drop-area-empty");
                }
            } else {
                logError(`No drop store found for target #${dropTargetId}.`);
            }
        }
    }

    /**
     * Append to the specified form data files from a drag and drop operation.
     * @param {FormData} formData The FormData to which append the files.
     */
    function dragDropAppendFilesOnFormSubmit(formData) {
        logDebug("Collecting drag/drop files...");
        let fileCount = 0;

        for (const dropTargetId in _dragDropStorage) {
            if (_dragDropStorage.hasOwnProperty(dropTargetId)) {
                const config = _dragDropStorage[dropTargetId];
                const { droppedFiles } = config;

                if (!!droppedFiles && droppedFiles.fileCount > 0) {
                    for (const inputName in droppedFiles) {
                        if (droppedFiles.hasOwnProperty(inputName)) {
                            const fileList = droppedFiles[inputName];

                            for (let i = 0; i < fileList.length; i++) {
                                formData.append(inputName, fileList[i]);
                                fileCount++;
                            }

                            logDebug(`Added drag/drop file(s) to form data: ${fileCount}`);
                        }
                    }
                } else {
                    logDebug(`No file dropped onto target #${dropTargetId}.`);
                }
            }
        }

        logDebug(`Collected ${fileCount} drag and drop file(s) for target elements.`);
        return fileCount;
    }

    /**
     * Handles the 'drop' event.
     * @param {DragEvent} e
     * @param {any} options
     * @param {HTMLElement} dropTarget
     */
    async function handleDrop(e, options, dropTarget) {
        e.stopPropagation();
        e.preventDefault();

        const { inputFileId, multiple, inputName } = options;
        const dt = e.dataTransfer;
        const fileList = dt.files;
        const fileCount = fileList && fileList.length || 0;
        const hasFiles = fileCount > 0;
        const files = hasFiles ? [...fileList] : [];
        const { onDrop: onDropInterop } = _managerOptions;

        let filesToProcess = files;
        let storeFilesOnly = false;

        logDebug("Processing dropped files with options", options);

        if (hasFiles) {
            if (!multiple) filesToProcess = [files[0]];

            logDebug(`${fileCount} file(s) dropped onto target element #${dropTarget.id}`);
            if (_isString(inputFileId)) resetInputFile(inputFileId);
        }

        if (_isString(onDropInterop)) {
            const args = {
                dataTransfer: {
                    dropEffect: DROP_EFFECTS[dt.dropEffect],
                    effectAllowed: DROP_EFFECTS_ALLOWED[dt.effectAllowed],
                    files: hasFiles ? files.map(f => createFileInfo(f)) : [],
                    items: !!dt.items ? [...dt.items].map(dti => ({ kind: dti.kind, type: dti.type })) : [],
                    types: dt.types,
                },
                targetId: dropTarget.id,
                multiple: !!multiple,
            };

            logDebug("Drop event args:", args);

            const result = await invokeDotNet(onDropInterop, args);

            logDebug("Drop event response:", result);

            if (_isObject(result)) {
                const { cancel, acceptedFiles, storeOnly, maxFileCount, maxTotalSize, imagePreviewOptions } = result;

                if (cancel) {
                    logDebug(`Drop operation has been cancelled by the user/app.`);
                    return;
                }

                if (hasFiles) {
                    if (acceptedFiles instanceof (Array) && acceptedFiles.length) {
                        // process only specific files

                        logDebug("Filtering out specific files to be processed defined by the application.");

                        // cast acceptedFiles from 'any' to 'string' for strongly-typed file name equality comparison
                        const fileNamesAsStringArray = acceptedFiles.map(n => "" + n);

                        // find corresponding items in the original 'files' array
                        filesToProcess = fileNamesAsStringArray
                            .map(name => files.find(file => file.name === name)) // type- and case-sensitive comparison
                            .filter(f => !!f); // remove potentially undefined items returned by the 'map' function
                    }

                    // only integers allowed
                    const maxcount = maxFileCount | 0;

                    if (maxcount > 0) {
                        filesToProcess = filesToProcess.slice(0, maxcount);
                        logDebug(`Maximum ${maxcount} of ${fileCount} files selected for processing.`);
                    }

                    if (maxTotalSize > 0) {
                        logDebug(`Limiting total file size to ${maxTotalSize} MB.`);

                        let sum = 0;
                        const totalFiles = []
                        // convert max from MB to bytes
                        const maxTotalSizeBytes = 1024 * 1024 * maxTotalSize;

                        for (let i = 0; i < filesToProcess.length; i++) {
                            const file = filesToProcess[i];
                            if ((sum + file.size) <= maxTotalSizeBytes) {
                                sum += file.size;
                                totalFiles.push(file);
                            } else {
                                break;
                            }
                        }

                        const initialFileCount = filesToProcess.length;
                        filesToProcess = totalFiles;

                        logDebug(`${filesToProcess.length} of ${initialFileCount} files ` +
                            `selected for processing.Total size: ${fileSizeToString(sum)}`);
                    }

                    storeFilesOnly = storeOnly;
                    if (_isObject(imagePreviewOptions))
                        options.imagePreviewOptions = imagePreviewOptions;
                }
            }
        }

        // make sure that files have been dropped onto the target
        if (hasFiles && filesToProcess.length) {
            logDebug(`Processing ${filesToProcess.length} file(s)...`);

            /**
             * Callback invoked when at least one file has been effectively processed.
             * @param {File[]} processedFileList
             */
            const cb = processedFileList => {
                const dropTargetId = dropTarget.id;
                if (storeFilesOnly) dropTarget = undefined;
                dragDropAfterFilesProcessed(processedFileList, dropTargetId, inputName, dropTarget, /*keepEmptyClass:*/ storeFilesOnly);
            };

            readFileList(filesToProcess, options, cb, storeFilesOnly);
        }
    }

    /**
     * Return the number of files dropped on the identified target.
     * @param {string} dropTargetId
     */
    function dragDropGetFileCount(dropTargetId) {
        const config = _dragDropStorage[dropTargetId];
        return (!!config && !!config.droppedFiles && config.droppedFiles.fileCount | 0) || 0;
    }

    /**
     * Convert size to a human-readable format.
     * @param {number} size The file size in bytes.
     */
    function fileSizeToString(size) {
        if (size <= 0) return "";
        if (size < 1024) return `${size} B`;
        if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
        if (size < 1024 * 1024 * 1024) return `${(size / 1024 * 1024).toFixed(2)} MB`;
        return `${size / (1024 * 1024 * 1024).toFixed(2)} GB`;
    }

    /**
     * Attempt to set the value of an input file to an empty string.
     * @param {string} inputFileId The identifier of the input file to reset.
     */
    function resetInputFile(inputFileId) {
        logDebug(`Resetting input file #${inputFileId}`);
        try {
            const input = _document.getElementById(inputFileId);
            input && (input.value = "");
        } catch (e) {
            logError(`Error resetting the value of file input #${inputId}`, e);
        }
    }

    /**
     * Log an error message for the element that has not been found in the DOM tree.
     * @param {string} elementId The identifier of the not-found element.
     * @param {string} name Optional: The name of the element.
     */
    function notFound(elementId, name) {
        const error = `The ${name} element identified by #${elementId} not found in the DOM tree.`;
        logError(error);
        return error;
    }

    /**
     * Add classes to the element's classList collection.
     * @param {HTMLElement} element
     * @param {string} classes A whitespace-separated string of HTML classes.
     */
    function addClassList(element, classes) {
        element.classList.add(("" + classes).split(" ").map(cls => cls.trim()));
        return element;
    }

    /**
     * Return an object with all mouse-related event properties.
     * @param {MouseEvent} e
     */
    function getMouseEventArgs(e) {
        return {
            altKey: e.altKey,
            button: e.button,
            buttons: e.buttons,
            clientX: e.clientX,
            clientY: e.clientY,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            movementX: e.movementX,
            movementY: e.movementY,
            offsetX: e.offsetX,
            offsetY: e.offsetY,
            pageX: e.pageX,
            pageY: e.pageY,
            screenX: e.screenX,
            screenY: e.screenY,
            shiftKey: e.shiftKey,
            which: e.which,
            x: e.x,
            y: e.y
        }
    }

    function defaultPreviewOptionsFrom(options) {
        // delete invalid properties
        Object.keys(options).forEach(prop =>
        {
            if (options[prop] === 0 || options[prop] === undefined || options[prop] === null)
                delete options[prop];
        });

        const def = _defaultImagePreviewOptions;
        const result = Object.assign({
            autoGenerate: def.autoGenerate,
            autoGeneratedClass: def.autoGeneratedClass,
            generateFileInfo: def.generateFileInfo,
            tagClass: def.tagClass,
            tagName: def.tagName,
            src: def.attributeName,
            wrapperSelector: def.wrapperSelector,
            width: def.width,
            height: def.height,
            preserveAspectRatio: def.preserveAspectRatio,
            noResize: def.noResize,
        }, options);

        return result;
    }

    function supportsImageUtil() {
        // before checking for the ImageUtil class, which uses the 
        // <canvas> element, make sure first that the device supports canvas
        if (!!window.CanvasRenderingContext2D &&
            !!global.ImageUtil && ImageUtil.prototype && ImageUtil.prototype.constructor) {
            const util = new ImageUtil("");
            return ("crop" in util) && ("resize" in util);
        }
        return false;
    }

    function addEventHandler(target, eventType, handler) {
        if (!!target.addEventListener)
            target.addEventListener(eventType, handler, false);
        else if (!!target.attachEvent)
            target.attachEvent('on' + eventType, handler);
    }
})(window);
