var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
System.register("Shared", [], function (exports_1, context_1) {
    "use strict";
    var DefaultImagePreviewOptions, SIZE_KB, SIZE_MB, SIZE_GB, SIZE_TB, PRIMITIVES, AssemblyName, Forms, DragDropStorage;
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            exports_1("DefaultImagePreviewOptions", DefaultImagePreviewOptions = {
                autoGenerate: true,
                generateFileInfo: true,
                attributeName: "src",
                tagName: "img",
                tagId: "",
                tagClass: "blazor-form-manager-image-preview",
                autoGeneratedClass: "form-manager-auto-generated",
                wrapperSelector: ".image-wrapper",
                width: 150,
                height: 0,
                preserveAspectRatio: true,
                noResize: false,
            });
            exports_1("SIZE_KB", SIZE_KB = 1024);
            exports_1("SIZE_MB", SIZE_MB = SIZE_KB * SIZE_KB);
            exports_1("SIZE_GB", SIZE_GB = SIZE_KB * SIZE_MB);
            exports_1("SIZE_TB", SIZE_TB = SIZE_KB * SIZE_GB);
            exports_1("PRIMITIVES", PRIMITIVES = ["string", "number", "bigint", "boolean"]);
            exports_1("AssemblyName", AssemblyName = 'BlazorFormManager');
            exports_1("Forms", Forms = {});
            exports_1("DragDropStorage", DragDropStorage = {});
        }
    };
});
System.register("ConsoleLogger", ["Shared"], function (exports_2, context_2) {
    "use strict";
    var Shared_1, CONSOLE_FUNC, LOG_LEVEL, ConsoleLogger, log, logDebug, logError, logInfo, logWarning;
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [
            function (Shared_1_1) {
                Shared_1 = Shared_1_1;
            }
        ],
        execute: function () {
            CONSOLE_FUNC = { info: "info", warn: "warn", error: "error", log: "log" };
            LOG_LEVEL = { none: 0, information: 1, warning: 2, error: 3, debug: 4 };
            ConsoleLogger = /** @class */ (function () {
                function ConsoleLogger() {
                }
                ConsoleLogger.logInfo = function (formId) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    this.log.apply(this, __spreadArray([formId, CONSOLE_FUNC.info], args, false));
                };
                ConsoleLogger.logWarning = function (formId) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    this.log.apply(this, __spreadArray([formId, CONSOLE_FUNC.warn], args, false));
                };
                ConsoleLogger.logError = function (formId) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    this.log.apply(this, __spreadArray([formId, CONSOLE_FUNC.error], args, false));
                };
                ConsoleLogger.logDebug = function (formId) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    this.log.apply(this, __spreadArray([formId, CONSOLE_FUNC.log], args, false));
                };
                ConsoleLogger.log = function (formId, func) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    var _a = (Shared_1.Forms[formId] || { logLevel: LOG_LEVEL.debug }).logLevel, logLevel = _a === void 0 ? LOG_LEVEL.debug : _a;
                    if (logLevel === LOG_LEVEL.none)
                        return;
                    func || (func = CONSOLE_FUNC.info);
                    args || (args = []);
                    args.unshift("".concat(func === "log" ? "debug" : func, ": ").concat(formId || 'BlazorFormManager', ":"));
                    if (logLevel === LOG_LEVEL.debug)
                        console[func].apply(console, args);
                    else if (func === CONSOLE_FUNC.error && logLevel >= LOG_LEVEL.error)
                        console.error.apply(console, args);
                    else if (func === CONSOLE_FUNC.warn && logLevel >= LOG_LEVEL.warning)
                        console.warn.apply(console, args);
                    else if (func === CONSOLE_FUNC.info && logLevel >= LOG_LEVEL.information)
                        console.info.apply(console, args);
                };
                return ConsoleLogger;
            }());
            exports_2("ConsoleLogger", ConsoleLogger);
            log = ConsoleLogger.log, logDebug = ConsoleLogger.logDebug, logError = ConsoleLogger.logError, logInfo = ConsoleLogger.logInfo, logWarning = ConsoleLogger.logWarning;
            exports_2("log", log);
            exports_2("logDebug", logDebug);
            exports_2("logError", logError);
            exports_2("logInfo", logInfo);
            exports_2("logWarning", logWarning);
        }
    };
});
System.register("Utils", ["Shared", "ConsoleLogger"], function (exports_3, context_3) {
    "use strict";
    var Shared_2, ConsoleLogger_1, Utils, _isDictionary, _isFunction, _isObject, _isString, populateDictionary, containsFiles, createFileInfo, supportsFileExtension, notFound, fileSizeToString, addClassList, getTargetElementById, supportsImageUtil, removeFileList, formDataKeys, formDataMerge, insertStyles, insertScripts, getElementByTag;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [
            function (Shared_2_1) {
                Shared_2 = Shared_2_1;
            },
            function (ConsoleLogger_1_1) {
                ConsoleLogger_1 = ConsoleLogger_1_1;
            }
        ],
        execute: function () {
            /** A general-purpose utility class. */
            Utils = /** @class */ (function () {
                function Utils() {
                }
                /**
                 * Check if the specified object is defined and is a non-empty string.
                 * @param obj
                 */
                Utils._isString = function (obj) {
                    return obj && typeof obj === "string" && ("" + obj).trim().length > 0;
                };
                /**
                 * Check if the specified object is defined and its type is 'object'.
                 * @param obj
                 */
                Utils._isObject = function (obj) {
                    return obj && typeof obj === "object";
                };
                /**
                 * Check if the specified object is defined and its type is 'function'.
                 * @param obj
                 */
                Utils._isFunction = function (obj) {
                    return obj && typeof obj === "function";
                };
                /**
                 * Check if the specified object is a defined object with one or more keys.
                 * @param obj
                 */
                Utils._isDictionary = function (obj) {
                    return Utils._isObject(obj) && Object.keys(obj).length > 0;
                };
                /**
                 * Builds a dictionary of primitive types.
                 * @param {any} target
                 * @param {any} source
                 */
                Utils.populateDictionary = function (target, source) {
                    for (var prop in source) {
                        var value = source[prop];
                        var type = typeof value;
                        if (value === undefined || value === null)
                            continue;
                        if (Shared_2.PRIMITIVES.indexOf(type) > -1) {
                            target[prop] = value;
                        }
                        //if (value instanceof Array) {
                        //    for (let i = 0; i < value.length; i++) {
                        //    }
                        //}
                    }
                    return target;
                };
                /**
                 * Check if the specified form contains at least one file to upload.
                 * @param form The form to query.
                 */
                Utils.containsFiles = function (form) {
                    var inputs = form.querySelectorAll("input[type=file]");
                    for (var i = 0; i < inputs.length; i++) {
                        var input = inputs[i];
                        if (input.files && input.files.length) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Create a file info object from the specified file.
                 * @param {File} file
                 * @param {{width: number, height: number}} dimensions Optional: The dimensions of the file if it's an image.
                 * @param {boolean} createUrl true to create an object URL if the file type is an image.
                 */
                Utils.createFileInfo = function (file, dimensions, createUrl) {
                    if (!_isObject(dimensions))
                        dimensions = null;
                    return {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        lastModifiedDate: new Date(file.lastModified),
                        dimensions: dimensions,
                        objectUrl: createUrl && file.type.toLowerCase().indexOf('image/') > -1 ? URL.createObjectURL(file) : ""
                    };
                };
                Utils.supportsFileExtension = function (name, supportedFiles) {
                    name = (name || "").toLowerCase();
                    for (var i = 0; i < supportedFiles.length; i++)
                        if (name.endsWith(supportedFiles[i]))
                            return true;
                    return false;
                };
                /**
                 * Log an error message for the element that has not been found in the DOM tree.
                 * @param {string} targetId The identifier of the not-found element.
                 * @param {string} name Optional: The name of the element.
                 */
                Utils.notFound = function (targetId, name) {
                    var error = "The ".concat(name, " element identified by #").concat(targetId, " has not been found in the DOM tree.");
                    return error;
                };
                /**
                 * Convert size to a human-readable format.
                 * @param {number} size The file size in bytes.
                 */
                Utils.fileSizeToString = function (size) {
                    if (size <= 0)
                        return "";
                    if (size < Shared_2.SIZE_KB)
                        return "".concat(size, " B");
                    if (size < Shared_2.SIZE_MB)
                        return "".concat((size / Shared_2.SIZE_KB).toFixed(1), " KB");
                    if (size < Shared_2.SIZE_GB)
                        return "".concat((size / Shared_2.SIZE_MB).toFixed(1), " MB");
                    return "".concat((size / Shared_2.SIZE_TB).toFixed(2), " GB");
                };
                /**
                 * Add classes to the element's classList collection.
                 * @param {HTMLElement} element
                 * @param {string} classes A whitespace-separated string of HTML classes.
                 */
                Utils.addClassList = function (element, classes) {
                    var _a;
                    (_a = element.classList).add.apply(_a, ("" + classes).split(" ").map(function (cls) { return cls.trim(); }));
                    return element;
                };
                Utils.getTargetElementById = function (formId, id, interop) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, targetElement, error, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    ERROR_CODE_BASE = 300;
                                    if (!_isString(id)) return [3 /*break*/, 4];
                                    targetElement = document.getElementById(id);
                                    if (!!targetElement) return [3 /*break*/, 3];
                                    error = notFound(id);
                                    result = { succeeded: false, error: error, targetElement: targetElement, code: ERROR_CODE_BASE + 2 };
                                    if (!(interop && _isString(Shared_2.Forms[formId].onFileReaderResult))) return [3 /*break*/, 2];
                                    return [4 /*yield*/, interop.invokeDotNet(formId, Shared_2.Forms[formId].onFileReaderResult, result)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/, result];
                                case 3: return [2 /*return*/, { succeeded: true, error: undefined, targetElement: targetElement, code: 0 }];
                                case 4: return [2 /*return*/, { succeeded: false, error: undefined, targetElement: undefined, code: ERROR_CODE_BASE + 1 }];
                            }
                        });
                    });
                };
                Utils.supportsImageUtil = function () {
                    // before checking for the ImageUtil class, which uses the 
                    // <canvas> element, make sure first that the device supports canvas
                    if (!!window.CanvasRenderingContext2D &&
                        !!globalThis.ImageUtility && globalThis.ImageUtility.prototype && globalThis.ImageUtility.prototype.constructor) {
                        var util = new globalThis.ImageUtility("");
                        return ("crop" in util) && ("resize" in util);
                    }
                    return false;
                };
                /**
                 * Remove dropped files and auto-generated images for the specified target element.
                 * @param {DragDropTargetOptions} options The options.
                 */
                Utils.removeFileList = function (options) {
                    var formId = options.formId, targetId = options.targetId;
                    ConsoleLogger_1.logDebug(formId, "Attempting to remove dropped files for target element #".concat(targetId, "..."));
                    if (targetId in Shared_2.DragDropStorage) {
                        var config = Shared_2.DragDropStorage[targetId];
                        var options_1 = config.options;
                        var inputName = options_1.inputName, _a = options_1.imagePreviewOptions, imagePreviewOptions = _a === void 0 ? Shared_2.DefaultImagePreviewOptions : _a;
                        if ('droppedFiles' in config) {
                            delete config.droppedFiles[inputName];
                            delete config.droppedFiles;
                            ConsoleLogger_1.logDebug(formId, "Files deleted from drag and drop storage.");
                        }
                        else {
                            ConsoleLogger_1.logDebug(formId, "No files have been dropped onto the dedicated area.");
                        }
                        if (!!imagePreviewOptions) {
                            var previewId = imagePreviewOptions.tagId, attr = imagePreviewOptions.attributeName;
                            if (_isString(previewId)) {
                                // suppress image preview, if any
                                var image = document.getElementById(previewId);
                                if (!!image) {
                                    image.removeAttribute(attr || "src");
                                    ConsoleLogger_1.logDebug(formId, "Removed image preview.");
                                }
                                else
                                    ConsoleLogger_1.logDebug(formId, "Image #".concat(previewId, " not found in the DOM tree."));
                            }
                        }
                        var dropTarget = document.getElementById(targetId);
                        if (dropTarget)
                            dropTarget.classList.add("drag-drop-area-empty");
                        Utils.removeAutoGeneratedImages(dropTarget);
                        return true;
                    }
                    else {
                        ConsoleLogger_1.logDebug(formId, "Target element not found in drag and drop storage.");
                    }
                    return false;
                };
                /**
                 * Enumerate all keys in the given form data object.
                 * @param formData The form data to enumerate.
                 */
                Utils.formDataKeys = function (formData) {
                    var keys = [];
                    if ('keys' in formData && typeof formData['keys'] === 'function') {
                        var fd = formData;
                        for (var _i = 0, _a = fd.keys(); _i < _a.length; _i++) {
                            var key = _a[_i];
                            keys.push(key);
                        }
                    }
                    else {
                        formData.forEach(function (_, key, __) {
                            keys.push(key);
                        });
                    }
                    return keys;
                };
                /**
                 * Merge form data from source into target.
                 * @param target The object that will receive the form data from source.
                 * @param source The object whose data will be merged into target.
                 */
                Utils.formDataMerge = function (target, source) {
                    source.forEach(function (value, key) { return target.set(key, value); });
                    return target;
                };
                /**
                 * Uniquely insert one or more stylesheets into the DOM.
                 * @param sources A URL or array of URL of the stylesheets to load.
                 * @param onload The event handler to fire when the browser loads a stylesheet.
                 * @param formId The form identifier.
                 */
                Utils.insertStyles = function (sources, onload, formId) {
                    return new Promise(function (resolve, reject) {
                        if (!(sources instanceof Array))
                            sources = [sources];
                        var head = Utils.getOrCreateHead();
                        var count = sources.length;
                        var _loop_1 = function (i) {
                            var src = sources[i];
                            var link = document.querySelector("link[href=\"".concat(src, "\"]"));
                            if (link) {
                                var rel = link.attributes["rel"];
                                if (!rel || rel.value === "stylesheet") {
                                    count--;
                                    ConsoleLogger_1.logDebug(formId, "The CSS style ".concat(src, " is already in the DOM."));
                                    if (count <= 0) {
                                        resolve(true);
                                        return { value: void 0 };
                                    }
                                    return "continue";
                                }
                            }
                            var s = document.createElement("link");
                            s.onload = function (e) {
                                if (onload)
                                    onload.call(s, e);
                                if (--count <= 0)
                                    resolve(true);
                            };
                            s.onerror = function (e) { return reject(e); };
                            s.href = src;
                            s.rel = "stylesheet";
                            head.appendChild(s);
                        };
                        for (var i = 0; i < sources.length; i++) {
                            var state_1 = _loop_1(i);
                            if (typeof state_1 === "object")
                                return state_1.value;
                        }
                    });
                };
                /**
                 * Uniquely insert one or more scripts into the DOM.
                 * @param sources A URL or array of URL of the scripts to load.
                 * @param onload The event handler to fire when the browser loads a script.
                 * @param formId The form identifier.
                 * @param isAsync Sets the script's async property.
                 * @param isDeferred Sets the scripts defer property.
                 */
                Utils.insertScripts = function (sources, onload, formId, isAsync, isDeferred) {
                    return new Promise(function (resolve, reject) {
                        if (!(sources instanceof Array))
                            sources = [sources];
                        var head = Utils.getOrCreateHead();
                        var count = sources.length;
                        var _loop_2 = function (i) {
                            var src = (sources[i] || '').trim();
                            if (!src || src.length === 0) {
                                var msg = 'Cannot load an empty script source.';
                                ConsoleLogger_1.logDebug(formId, msg);
                                reject(new Error(msg));
                                return { value: void 0 };
                            }
                            var existing = document.querySelector("script[src=\"".concat(src, "\"]"));
                            if (existing) {
                                count--;
                                //logDebug(formId, `The script ${src} has already been loaded into the DOM.`);
                                if (onload)
                                    onload.call(existing, new Event('load'));
                                if (count <= 0) {
                                    resolve(true);
                                    return { value: void 0 };
                                }
                                return "continue";
                            }
                            var s = document.createElement("script");
                            s.onload = function (e) {
                                if (onload)
                                    onload.call(s, e);
                                if (--count <= 0)
                                    resolve(true);
                            };
                            s.onerror = function (e) { return reject(e); };
                            s.src = src;
                            s.async = isAsync || false;
                            s.defer = isDeferred || false;
                            head.appendChild(s);
                        };
                        for (var i = 0; i < sources.length; i++) {
                            var state_2 = _loop_2(i);
                            if (typeof state_2 === "object")
                                return state_2.value;
                        }
                    });
                };
                /** Get, or create and insert, the 'head' DOM element. */
                Utils.getOrCreateHead = function () {
                    return Utils.getElementByTag("head", function (name) {
                        var d = document;
                        var h = d.createElement(name);
                        return d.insertBefore(h, d.body);
                    });
                };
                /**
                 * Get the first element identified by name, or create a new one using factory.
                 * @param name The tag name of the element to retrieve.
                 * @param factory A fallback factory function or object.
                 */
                Utils.getElementByTag = function (name, factory) {
                    var elms = document.getElementsByTagName(name);
                    return elms && elms.length && elms[0] || (typeof factory === 'function' ? factory(name) : factory);
                };
                /**
                 * Remove auto-generated images.
                 * @param {HTMLElement} container Optional: The HTML element that contains the images. Defaults to document.
                 */
                Utils.removeAutoGeneratedImages = function (container) {
                    var images = (container || document).querySelectorAll(".".concat(Shared_2.DefaultImagePreviewOptions.autoGeneratedClass));
                    for (var i = 0; i < images.length; i++) {
                        var img = images[i];
                        img.remove();
                    }
                };
                return Utils;
            }());
            exports_3("Utils", Utils);
            _isDictionary = Utils._isDictionary, _isFunction = Utils._isFunction, _isObject = Utils._isObject, _isString = Utils._isString, populateDictionary = Utils.populateDictionary, containsFiles = Utils.containsFiles, createFileInfo = Utils.createFileInfo, supportsFileExtension = Utils.supportsFileExtension, notFound = Utils.notFound, fileSizeToString = Utils.fileSizeToString, addClassList = Utils.addClassList, getTargetElementById = Utils.getTargetElementById, supportsImageUtil = Utils.supportsImageUtil, removeFileList = Utils.removeFileList, formDataKeys = Utils.formDataKeys, formDataMerge = Utils.formDataMerge, insertStyles = Utils.insertStyles, insertScripts = Utils.insertScripts, getElementByTag = Utils.getElementByTag;
            exports_3("_isDictionary", _isDictionary);
            exports_3("_isFunction", _isFunction);
            exports_3("_isObject", _isObject);
            exports_3("_isString", _isString);
            exports_3("populateDictionary", populateDictionary);
            exports_3("containsFiles", containsFiles);
            exports_3("createFileInfo", createFileInfo);
            exports_3("supportsFileExtension", supportsFileExtension);
            exports_3("notFound", notFound);
            exports_3("fileSizeToString", fileSizeToString);
            exports_3("addClassList", addClassList);
            exports_3("getTargetElementById", getTargetElementById);
            exports_3("supportsImageUtil", supportsImageUtil);
            exports_3("removeFileList", removeFileList);
            exports_3("formDataKeys", formDataKeys);
            exports_3("formDataMerge", formDataMerge);
            exports_3("insertStyles", insertStyles);
            exports_3("insertScripts", insertScripts);
            exports_3("getElementByTag", getElementByTag);
        }
    };
});
System.register("DomEventManager", ["ConsoleLogger", "Utils", "Shared"], function (exports_4, context_4) {
    "use strict";
    var ConsoleLogger_2, Utils_1, Shared_3, FILTER_KEY_TYPES, dotnet, Listeners, addListener, removeListener, DomEventManager, addEventHandler, addEventListener, filterKeys, removeEventHandler, removeEventListener, getMouseEventArgs;
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [
            function (ConsoleLogger_2_1) {
                ConsoleLogger_2 = ConsoleLogger_2_1;
            },
            function (Utils_1_1) {
                Utils_1 = Utils_1_1;
            },
            function (Shared_3_1) {
                Shared_3 = Shared_3_1;
            }
        ],
        execute: function () {
            FILTER_KEY_TYPES = { none: 0, alpha: 1, alphaNumeric: 2, digits: 3 };
            dotnet = globalThis.DotNet;
            Listeners = {};
            addListener = function (targetId, eventType, listener) {
                var key = targetId + eventType;
                Listeners[key] = listener;
            };
            removeListener = function (targetId, eventType) {
                var key = targetId + eventType;
                if (key in Listeners)
                    delete Listeners[key];
            };
            /** Provides static methods for defining and handling events. */
            DomEventManager = /** @class */ (function () {
                function DomEventManager() {
                }
                /**
                 * Add an event listener to a specified target element identified by 'targetId'.
                 * @param targetId The identifier of the target element.
                 * @param eventType The type of event to add the listener for.
                 * @param callback The static .NET method to invoke when an event occurs.
                 */
                DomEventManager.addEventListener = function (targetId, eventType, callback) {
                    ConsoleLogger_2.logDebug(null, "Adding '".concat(eventType, "' event listener for #").concat(targetId, "."));
                    var target = document.getElementById(targetId);
                    if (target) {
                        var callbackDefined_1 = dotnet && Utils_1._isString(callback);
                        /**
                         * The event listener for the element.
                         * @param event The event data.
                         */
                        var listener = function (event) {
                            var obj = {
                                targetId: targetId,
                                eventType: eventType,
                                arguments: Utils_1.populateDictionary({}, event),
                                value: target['value'] === undefined ? "" : target['value']
                            };
                            // logDebug(`Event received: ${event.type}, invoking .NET method ${callback}...`, obj);
                            if (callbackDefined_1)
                                dotnet.invokeMethodAsync(Shared_3.AssemblyName, callback, obj);
                        };
                        if (DomEventManager.addEventHandler(target, eventType, listener)) {
                            ConsoleLogger_2.logDebug(null, "Event listener added successfully.");
                        }
                        return true;
                    }
                    else {
                        Utils_1.notFound(targetId);
                        return false;
                    }
                };
                /**
                 * Remove an event listener from a target element identified by 'targetId'.
                 * @param targetId The identifier of the target element.
                 * @param eventType The type of event to remove the listener for.
                 */
                DomEventManager.removeEventListener = function (targetId, eventType) {
                    ConsoleLogger_2.logDebug("Removing event listener ".concat(eventType, " for #").concat(targetId, "."));
                    var listener = Listeners[targetId + eventType];
                    return DomEventManager.removeEventHandler(targetId, eventType, listener);
                };
                /**
                 * Add an event listener to the specified HTMLElement.
                 * @param target The target element or identifier.
                 * @param eventType The event type.
                 * @param listener The event listenerj or event listener object.
                 */
                DomEventManager.addEventHandler = function (target, eventType, listener) {
                    var targetElement;
                    if (Utils_1._isString(target)) {
                        targetElement = document.getElementById(target);
                    }
                    else {
                        targetElement = target;
                    }
                    if (!targetElement) {
                        ConsoleLogger_2.logError(null, "Target is not a valid object reference.");
                        return false;
                    }
                    var success;
                    if (targetElement.addEventListener) {
                        targetElement.addEventListener(eventType, listener, false);
                        success = true;
                    }
                    else if (targetElement['attachEvent'] && typeof targetElement['attachEvent'] === 'function') {
                        targetElement.attachEvent('on' + eventType, listener);
                        success = true;
                    }
                    else {
                        ConsoleLogger_2.logDebug("Could not add '".concat(eventType, "' event listener for #").concat(targetElement));
                    }
                    if (success) {
                        addListener(targetElement.id, eventType, listener);
                    }
                    return success;
                };
                /**
                 * Remove the event listener in the identifier target element's event listener list.
                 * @param targetId The identifier of the element for which to remove the event listener.
                 * @param eventType The type of event to remove.
                 * @param listener The event listener or event listener object.
                 */
                DomEventManager.removeEventHandler = function (targetId, eventType, listener) {
                    var success;
                    var targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        if (targetElement.removeEventListener) {
                            targetElement.removeEventListener(eventType, listener, false);
                            success = true;
                        }
                        else if (targetElement['detachEvent'] && typeof targetElement['detachEvent'] === 'function') {
                            targetElement.detachEvent('on' + eventType, listener);
                            success = true;
                        }
                    }
                    if (success) {
                        removeListener(targetId, eventType);
                    }
                    else {
                        ConsoleLogger_2.logDebug("Could not remove '".concat(eventType, "' event listener for #").concat(targetElement));
                    }
                    return success;
                };
                /**
                 * Add a 'keydown' or 'keypress' event listener to the element identified
                 * by 'targetId', and optionally allows or blocks certain types of keystrokes.
                 * @param options An object that with configuration settings.
                 */
                DomEventManager.filterKeys = function (options) {
                    var targetId = options.targetId, eventType = options.eventType, callback = options.callback, filter = options.filter;
                    if (!Utils_1._isString(targetId)) {
                        ConsoleLogger_2.logError(null, "The targetId property must be a non-blank string.");
                        return false;
                    }
                    // Keyboard events occur in the following order: keydown->keypress->input->keyup
                    // However, only the first two can be cancelled,.
                    if (["keydown", "keypress", "keyup"].indexOf(eventType) === -1) {
                        ConsoleLogger_2.logError(null, "Only the 'keydown', 'keypress', and 'keyup' events are supported.");
                        return false;
                    }
                    var target = document.getElementById(targetId);
                    if (target) {
                        var isKeyupEvent_1 = eventType === "keyup";
                        var _a = filter || {}, _b = _a.allowKeyType, allowKeyType_1 = _b === void 0 ? FILTER_KEY_TYPES.none : _b, blockKeyCodes = _a.blockKeyCodes, noCallbackOnPassThrough_1 = _a.noCallbackOnPassThrough;
                        var blockedKeyCodes_1 = (blockKeyCodes || []).map(function (n) { return n | 0; });
                        var hasCallback_1 = Utils_1._isString(callback);
                        /**
                         * Intercepts the 'keydown' and 'keypress' events.
                         * @param e The event object.
                         */
                        var listener = function (e) {
                            var charCode = e.which ? e.which : e.keyCode;
                            // The 'keyup' event cannot be prevented, so we don't check it.
                            if (!isKeyupEvent_1) {
                                if (allowKeyType_1 !== FILTER_KEY_TYPES.none) {
                                    if ((allowKeyType_1 === FILTER_KEY_TYPES.alpha && !isAlpha()) ||
                                        (allowKeyType_1 === FILTER_KEY_TYPES.alphaNumeric && !isAlphaNumeric()) ||
                                        (allowKeyType_1 === FILTER_KEY_TYPES.digits && !isDigit()))
                                        return cancelEvent();
                                }
                                if (blockedKeyCodes_1.indexOf(charCode) > -1)
                                    return cancelEvent();
                            }
                            if (hasCallback_1 && !noCallbackOnPassThrough_1) {
                                var t = e.target;
                                var arg = Utils_1.populateDictionary({
                                    targetId: targetId,
                                    eventType: e.type,
                                    value: t.value === undefined ? "" : t.value
                                }, e);
                                dotnet && dotnet.invokeMethodAsync(Shared_3.AssemblyName, callback, arg);
                            }
                            return true;
                            function isAlpha() {
                                // 95 = _
                                return charCode === 95 || /^[A-Za-z]+$/.test(e.key);
                            }
                            function isAlphaNumeric() {
                                return /^[\w]+$/.test(e.key);
                            }
                            function isDigit() {
                                return charCode > 47 && charCode < 58;
                            }
                            function cancelEvent() {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                return false;
                            }
                        };
                        DomEventManager.addEventHandler(target, eventType, listener);
                        return true;
                    }
                    else {
                        Utils_1.notFound();
                        return false;
                    }
                };
                /**
                 * Return an object with all mouse-related event properties.
                 * @param e The event object.
                 */
                DomEventManager.getMouseEventArgs = function (e) {
                    return {
                        altKey: e.altKey,
                        button: e.button,
                        buttons: e.buttons,
                        clientX: e.clientX,
                        clientY: e.clientY,
                        ctrlKey: e.ctrlKey,
                        metaKey: e.metaKey,
                        movementX: e.movementX,
                        movementY: e.movementY,
                        offsetX: e.offsetX,
                        offsetY: e.offsetY,
                        pageX: e.pageX,
                        pageY: e.pageY,
                        screenX: e.screenX,
                        screenY: e.screenY,
                        shiftKey: e.shiftKey,
                        which: e.which,
                        x: e.x,
                        y: e.y
                    };
                };
                return DomEventManager;
            }());
            addEventHandler = DomEventManager.addEventHandler, addEventListener = DomEventManager.addEventListener, filterKeys = DomEventManager.filterKeys, removeEventHandler = DomEventManager.removeEventHandler, removeEventListener = DomEventManager.removeEventListener, getMouseEventArgs = DomEventManager.getMouseEventArgs;
            exports_4("addEventHandler", addEventHandler);
            exports_4("addEventListener", addEventListener);
            exports_4("filterKeys", filterKeys);
            exports_4("removeEventHandler", removeEventHandler);
            exports_4("removeEventListener", removeEventListener);
            exports_4("getMouseEventArgs", getMouseEventArgs);
        }
    };
});
System.register("ImageUtility", [], function (exports_5, context_5) {
    "use strict";
    var ImageUtility;
    var __moduleName = context_5 && context_5.id;
    return {
        setters: [],
        execute: function () {
            /*
             Name:          ImageUtility
             Version:       1.0.0
             Author:        Abdourahamane Kaba
             Description:   A utility class that provides methods to crop, resize, and perform other image transformation algorithms.
             License:       Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
             Copyright:     Â©2022 Numeric Horizon LLC. All rights reserved.
             */
            ImageUtility = /** @class */ (function () {
                function ImageUtility(source) {
                    var _this = this;
                    if (typeof (source) === "string") {
                        /** The image's source (URL or base64 data URL). */
                        this.url = source;
                    }
                    else if (source instanceof Blob) {
                        this.readFile(source, function (data) { return _this.url = data; });
                    }
                    else {
                        throw new Error("Source type ".concat(typeof (source), " not supported."));
                    }
                }
                /**
                 * Read the specified source using an instance of FileReader.
                 * @param {Blob} source The file or other blob-like object to read.
                 * @param {(dataURL: string) => void} dataCallback
                 */
                ImageUtility.prototype.readFile = function (source, dataCallback) {
                    var reader = new FileReader();
                    /**
                     * FileReader's 'load' event handler.
                     * @param {ProgressEvent<FileReader>} e
                     */
                    var handler = function (e) { return dataCallback.call(e, e.target.result); };
                    if (reader['attachEvent'] && typeof reader['attachEvent'] === 'function') {
                        var r = reader;
                        r.attachEvent('onload', handler);
                    }
                    else {
                        reader.addEventListener("load", handler);
                    }
                    reader.readAsDataURL(source);
                };
                /**
                 * Create an HTMLImageElement, load and manipulate it using the specified handler.
                 * @param {string} src The source URL of the image to create.
                 * @param {(source: HTMLImageElement) => HTMLCanvasElement} handler An image manipulation callback function.
                 * @return {Promise<{canvas: HTMLCanvasElement; naturalWidth: number; naturalHeight: number}>} A Promise that resolves with the resulting HTMLCanvasElement.
                 */
                ImageUtility.prototype.createImage = function (src, handler) {
                    return new Promise(function (resolve) {
                        var sourceImage = new Image();
                        sourceImage.onload = function () {
                            resolve({
                                canvas: handler.call(this, sourceImage),
                                naturalWidth: sourceImage.naturalWidth,
                                naturalHeight: sourceImage.naturalHeight
                            });
                        };
                        sourceImage.src = src;
                    });
                };
                /**
                 * Crop an image to desired aspect ratio.
                 * @param {number} aspectRatio The aspect ratio
                 */
                ImageUtility.prototype.crop = function (aspectRatio) {
                    /**
                    * Image crop handler.
                    * @param {HTMLImageElement} sourceImage The source image element.
                    */
                    var handler = function (sourceImage) {
                        var sourceWidth = sourceImage.naturalWidth;
                        var sourceHeight = sourceImage.naturalHeight;
                        var sourceAspectRatio = sourceWidth / sourceHeight;
                        var targetWidth = sourceWidth;
                        var targetHeight = sourceHeight;
                        if (sourceAspectRatio > aspectRatio) {
                            targetWidth = sourceHeight * aspectRatio;
                        }
                        else if (sourceAspectRatio < aspectRatio) {
                            targetHeight = sourceWidth / aspectRatio;
                        }
                        var targetX = (targetWidth - sourceWidth) * .5;
                        var targetY = (targetHeight - sourceHeight) * .5;
                        var canvas = document.createElement('canvas');
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        canvas.getContext('2d').drawImage(sourceImage, targetX, targetY);
                        return canvas;
                    };
                    return this.createImage(this.url, handler);
                };
                ;
                /**
                 * Resize an image by preserving its aspect ratio.
                 * @param {number} targetWidth Optional: The desired width of the resulting image. If not set, targetHeight must be set.
                 * @param {number} targetHeight Optional: The desired height of the resulting image. If not set, targetWidth must be set.
                 * @param {boolean} preserveAspectRatio Optional: Indicates whether to keep the original aspect ratio.
                 */
                ImageUtility.prototype.resize = function (targetWidth, targetHeight, preserveAspectRatio) {
                    if (!(targetWidth || targetHeight))
                        throw new Error("At least one of the image dimensions must be set.");
                    if (targetWidth < 0 || targetHeight < 0)
                        throw new Error("Image dimensions cannot be negative.");
                    /**
                     * Image resizing handler.
                     * @param {HTMLImageElement} sourceImage The source image element.
                     */
                    var handler = function (sourceImage) {
                        /*
                         * sourceRatio = sourceWidth / sourceHeight
                         * targetRatio = targetWidth / targetHeight
                         * sourceRatio == targetRatio => sourceWidth / sourceHeight == targetWidth / targetHeight;
                         *
                         * Knowing either targetWidth or targetHeight:
                         *
                         * targetWidth = sourceWidth * targetHeight / sourceHeight;
                         * targetHeight = sourceHeight * targetWidth / sourceWidth;
                        */
                        var sourceWidth = sourceImage.naturalWidth;
                        var sourceHeight = sourceImage.naturalHeight;
                        if (!!preserveAspectRatio) {
                            if (targetWidth > 0)
                                targetHeight = sourceHeight * targetWidth / sourceWidth;
                            else
                                targetWidth = sourceWidth * targetHeight / sourceHeight;
                        }
                        var canvas = document.createElement('canvas');
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        canvas.getContext('2d').drawImage(sourceImage, 0, 0, targetWidth, targetHeight);
                        return canvas;
                    };
                    return this.createImage(this.url, handler);
                };
                ;
                return ImageUtility;
            }());
            exports_5("ImageUtility", ImageUtility);
        }
    };
});
System.register("ImagePreviewGenerator", ["ConsoleLogger", "ImageUtility", "Shared", "Utils"], function (exports_6, context_6) {
    "use strict";
    var ConsoleLogger_3, ImageUtility_1, Shared_4, Utils_2, _imageUtilAvailable, ImagePreviewGenerator;
    var __moduleName = context_6 && context_6.id;
    return {
        setters: [
            function (ConsoleLogger_3_1) {
                ConsoleLogger_3 = ConsoleLogger_3_1;
            },
            function (ImageUtility_1_1) {
                ImageUtility_1 = ImageUtility_1_1;
            },
            function (Shared_4_1) {
                Shared_4 = Shared_4_1;
            },
            function (Utils_2_1) {
                Utils_2 = Utils_2_1;
            }
        ],
        execute: function () {
            exports_6("DefaultImagePreviewOptions", Shared_4.DefaultImagePreviewOptions);
            _imageUtilAvailable = Utils_2.supportsImageUtil();
            ImagePreviewGenerator = /** @class */ (function () {
                function ImagePreviewGenerator() {
                }
                /**
                 * Takes care of generating an image preview for the specified file.
                 * @param {string} dataURL URL-encoded image data.
                 * @param {File} file The file whose dataURL is provided.
                 * @param {object} options An object used to generate an image.
                 */
                ImagePreviewGenerator.prototype.generateImagePreview = function (dataURL, file, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var formId, inputId, imagePreviewOptions, multiple, previewOptions, autoGenerate, tagId, tagName, wrapperSelector, desiredWidth, desiredHeight, preserveAspectRatio, noResize, result, succeeded, targetElement, error, image, dropTarget, container, image, width, height, _a, canvas, naturalWidth, naturalHeight, tagImg;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    formId = options.formId, inputId = options.inputId, imagePreviewOptions = options.imagePreviewOptions, multiple = options.multiple;
                                    if (!!Utils_2._isObject(imagePreviewOptions)) return [3 /*break*/, 1];
                                    ConsoleLogger_3.logWarning(formId, "No image preview generation options set.");
                                    return [3 /*break*/, 8];
                                case 1:
                                    previewOptions = this.defaultPreviewOptionsFrom(imagePreviewOptions);
                                    autoGenerate = previewOptions.autoGenerate, tagId = previewOptions.tagId, tagName = previewOptions.tagName, wrapperSelector = previewOptions.wrapperSelector, desiredWidth = previewOptions.width, desiredHeight = previewOptions.height, preserveAspectRatio = previewOptions.preserveAspectRatio, noResize = previewOptions.noResize;
                                    if (!Utils_2._isString(tagId)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, Utils_2.getTargetElementById(formId, tagId)];
                                case 2:
                                    result = _b.sent();
                                    succeeded = result.succeeded, targetElement = result.targetElement, error = result.error;
                                    image = targetElement;
                                    if (succeeded) {
                                        this.addImageAttributes(dataURL, file, image, previewOptions, multiple);
                                        return [2 /*return*/, {
                                                width: (image.width || 0) | 0,
                                                height: (image.height || 0) | 0
                                            }];
                                    }
                                    ConsoleLogger_3.logError(formId, error);
                                    return [3 /*break*/, 8];
                                case 3:
                                    if (!autoGenerate) return [3 /*break*/, 7];
                                    dropTarget = document.getElementById(inputId);
                                    container = dropTarget;
                                    image = void 0, width = 0, height = 0;
                                    if (!(!noResize && _imageUtilAvailable && multiple)) return [3 /*break*/, 5];
                                    ConsoleLogger_3.logDebug(formId, "Generating preview with ImageUtil.");
                                    return [4 /*yield*/, new ImageUtility_1.ImageUtility(dataURL).resize(desiredWidth, desiredHeight, preserveAspectRatio)];
                                case 4:
                                    _a = _b.sent(), canvas = _a.canvas, naturalWidth = _a.naturalWidth, naturalHeight = _a.naturalHeight;
                                    image = this.addImageAttributes(dataURL, file, canvas, previewOptions, multiple, true, naturalWidth, naturalHeight);
                                    width = naturalWidth;
                                    height = naturalHeight;
                                    return [3 /*break*/, 6];
                                case 5:
                                    tagImg = document.createElement("" + tagName);
                                    image = this.addImageAttributes(dataURL, file, tagImg, previewOptions, multiple);
                                    _b.label = 6;
                                case 6:
                                    if (Utils_2._isString(wrapperSelector)) {
                                        if (wrapperSelector.startsWith("#")) {
                                            // id specified, don't look for the element in the drop target
                                            container = document.querySelector(wrapperSelector);
                                        }
                                        else {
                                            // query first the dropTarget
                                            if (!!dropTarget)
                                                container = dropTarget.querySelector(wrapperSelector);
                                            // then query the document if not found
                                            if (!container)
                                                container = document.querySelector(wrapperSelector);
                                        }
                                        if (!container) {
                                            // if an image container has been specified but not found, that's an error
                                            ConsoleLogger_3.logError(formId, "Wrapper ".concat(wrapperSelector, " for auto-generated image not found in the DOM tree."));
                                        }
                                    }
                                    if (!container)
                                        container = dropTarget || document;
                                    container.appendChild(image);
                                    return [2 /*return*/, { width: width, height: height }];
                                case 7:
                                    ConsoleLogger_3.logWarning(formId, "Automatic image preview generation option is disabled!");
                                    _b.label = 8;
                                case 8: return [2 /*return*/, { width: 0, height: 0 }];
                            }
                        });
                    });
                };
                /**
                * Add attributes for an auto-generated image.
                * @param {HTMLImageElement} img The target HTML element to add attributes to.
                * Can be any HTML element but usually it's an <img /> or a <canvas></canvas> tag.
                * @param {boolean} skipSrc true to skip setting the 'src' attribute; otherwise, false.
                * @param {number} naturalWidth Optional: The original width of the image.
                * @param {number} naturalHeight The original height of the image.
                */
                ImagePreviewGenerator.prototype.addImageAttributes = function (dataURL, file, img, options, multiple, skipSrc, naturalWidth, naturalHeight) {
                    var fileSize = Utils_2.fileSizeToString(file.size);
                    var autoGeneratedClass = options.autoGeneratedClass, generateFileInfo = options.generateFileInfo, tagClass = options.tagClass, src = options.src;
                    if (!skipSrc)
                        img.setAttribute(src, dataURL);
                    // use classList to preserve existing classes
                    Utils_2.addClassList(img, tagClass);
                    if (generateFileInfo) {
                        /* A variation of what's built:
             
                         <span class="form-manager-auto-generated">
                            <img src="data:image;..."/>
                            <span class="file-info">
                                <span class="name">file_name.jpg</span>
                                <span class="size">98.29 KB</span>
                            </span>
                            <span class="bg-dimmed"></span>
                         </span>
                         */
                        var elcontainer = document.createElement("span");
                        var elmeta = document.createElement("span");
                        var elfilename = document.createElement("span");
                        var elfilesize = document.createElement("span");
                        var eldimmed = document.createElement("span");
                        var eldimensions = naturalWidth && naturalHeight && document.createElement("span") || null;
                        // add an internal class so that we can remove those created with the current script
                        elcontainer.setAttribute("class", autoGeneratedClass);
                        if (multiple)
                            elcontainer.classList.add("gallery");
                        elmeta.setAttribute("class", "file-info");
                        elfilesize.setAttribute("class", "size");
                        elfilename.setAttribute("class", "name");
                        eldimensions && eldimensions.setAttribute("class", "dimensions");
                        eldimmed.setAttribute("class", "bg-dimmed");
                        elfilesize.textContent = fileSize;
                        elfilename.textContent = file.name;
                        eldimensions && (eldimensions.textContent = "".concat(naturalWidth, "x").concat(naturalHeight));
                        elmeta.appendChild(elfilesize);
                        elmeta.appendChild(elfilename);
                        eldimensions && elmeta.appendChild(eldimensions);
                        elcontainer.appendChild(img);
                        elcontainer.appendChild(elmeta);
                        elcontainer.appendChild(eldimmed);
                        return elcontainer;
                    }
                    else {
                        Utils_2.addClassList(img, autoGeneratedClass).setAttribute("title", "".concat(file.name, " (").concat(fileSize, ")"));
                        return img;
                    }
                };
                ImagePreviewGenerator.prototype.defaultPreviewOptionsFrom = function (options) {
                    // delete invalid properties
                    Object.keys(options).forEach(function (prop) {
                        if (options[prop] === 0 || options[prop] === undefined || options[prop] === null)
                            delete options[prop];
                    });
                    var def = Shared_4.DefaultImagePreviewOptions;
                    var result = Object.assign({
                        autoGenerate: def.autoGenerate,
                        autoGeneratedClass: def.autoGeneratedClass,
                        generateFileInfo: def.generateFileInfo,
                        tagClass: def.tagClass,
                        tagName: def.tagName,
                        src: def.attributeName,
                        wrapperSelector: def.wrapperSelector,
                        width: def.width,
                        height: def.height,
                        preserveAspectRatio: def.preserveAspectRatio,
                        noResize: def.noResize,
                    }, options);
                    return result;
                };
                /**
                 * Remove auto-generated images.
                 * @param {HTMLElement} container Optional: The HTML element that contains the images. Defaults to document.
                 */
                ImagePreviewGenerator.prototype.removeAutoGeneratedImages = function (container) {
                    var images = (container || document).querySelectorAll(".".concat(Shared_4.DefaultImagePreviewOptions.autoGeneratedClass));
                    for (var i = 0; i < images.length; i++) {
                        var img = images[i];
                        img.remove();
                    }
                };
                ImagePreviewGenerator.getTargetElementById = function (formId, id, interop) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, targetElement, error, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    ERROR_CODE_BASE = 300;
                                    if (!Utils_2._isString(id)) return [3 /*break*/, 4];
                                    targetElement = document.getElementById(id);
                                    if (!!targetElement) return [3 /*break*/, 3];
                                    error = Utils_2.notFound(id);
                                    result = { succeeded: false, error: error, targetElement: targetElement, code: ERROR_CODE_BASE + 2 };
                                    if (!(interop && Utils_2._isString(Shared_4.Forms[formId].onFileReaderResult))) return [3 /*break*/, 2];
                                    return [4 /*yield*/, interop.invokeDotNet(formId, Shared_4.Forms[formId].onFileReaderResult, result)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/, result];
                                case 3: return [2 /*return*/, { succeeded: true, error: undefined, targetElement: targetElement, code: 0 }];
                                case 4: return [2 /*return*/, { succeeded: false, error: undefined, targetElement: undefined, code: ERROR_CODE_BASE + 1 }];
                            }
                        });
                    });
                };
                return ImagePreviewGenerator;
            }());
            exports_6("ImagePreviewGenerator", ImagePreviewGenerator);
        }
    };
});
System.register("SimpleEvent", [], function (exports_7, context_7) {
    "use strict";
    var SimpleEvent;
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [],
        execute: function () {
            SimpleEvent = /** @class */ (function () {
                function SimpleEvent() {
                    this.delegates = [];
                }
                SimpleEvent.prototype.subscribe = function (handler) {
                    this.delegates.push(handler);
                };
                SimpleEvent.prototype.unsubscribe = function (handler) {
                    this.delegates = this.delegates.filter(function (h) { return h !== handler; });
                };
                SimpleEvent.prototype.trigger = function (data) {
                    this.delegates.slice(0).forEach(function (d) { return d(data); });
                };
                SimpleEvent.prototype.expose = function () {
                    return this;
                };
                SimpleEvent.prototype.anySubscriber = function () {
                    return this.delegates.length > 0;
                };
                return SimpleEvent;
            }());
            exports_7("SimpleEvent", SimpleEvent);
        }
    };
});
System.register("FileReaderManager", ["ConsoleLogger", "DomEventManager", "ImagePreviewGenerator", "Shared", "SimpleEvent", "Utils"], function (exports_8, context_8) {
    "use strict";
    var ConsoleLogger_4, DomEventManager_1, ImagePreviewGenerator_1, Shared_5, SimpleEvent_1, Utils_3, _supportsFileReader, CompletedPromise, UPLOAD_EVENTS, READ_FILE_LIST_EVENTS, READ_FILE_LIST_REJECTION, FILE_READER_FUNC, FileReaderManager;
    var __moduleName = context_8 && context_8.id;
    return {
        setters: [
            function (ConsoleLogger_4_1) {
                ConsoleLogger_4 = ConsoleLogger_4_1;
            },
            function (DomEventManager_1_1) {
                DomEventManager_1 = DomEventManager_1_1;
            },
            function (ImagePreviewGenerator_1_1) {
                ImagePreviewGenerator_1 = ImagePreviewGenerator_1_1;
            },
            function (Shared_5_1) {
                Shared_5 = Shared_5_1;
            },
            function (SimpleEvent_1_1) {
                SimpleEvent_1 = SimpleEvent_1_1;
            },
            function (Utils_3_1) {
                Utils_3 = Utils_3_1;
            }
        ],
        execute: function () {
            _supportsFileReader = !!globalThis.FileReader;
            /** A promise that resolves as a false boolean value. */
            CompletedPromise = new Promise(function (resolve, _) { return resolve(false); });
            UPLOAD_EVENTS = { loadstart: 0, progress: 1, load: 2, error: 3, abort: 4, timeout: 5, loadend: 6 };
            READ_FILE_LIST_EVENTS = { start: 0, rejected: 1, processed: 2, end: 3 };
            READ_FILE_LIST_REJECTION = { none: 0, extension: 1, type: 2, multiple: 3, aborted: 4 };
            FILE_READER_FUNC = { 1: "readAsArrayBuffer", 2: "readAsBinaryString", 3: "readAsDataURL", 4: "readAsText", 5: "enumerate" };
            FileReaderManager = /** @class */ (function () {
                function FileReaderManager(interopInvoker) {
                    this.interopInvoker = interopInvoker;
                    this.progressEvent = new SimpleEvent_1.SimpleEvent();
                    this._readFileListAborted = false;
                    this._processedFileStorage = {};
                }
                Object.defineProperty(FileReaderManager.prototype, "onprogress", {
                    get: function () {
                        return this.progressEvent.expose();
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Set up event handlers for a FileReader object.
                 * @param {string} formId The form identifier.
                 * @param {FileReader} reader A FileReader object to which event listeners will be added.
                 * @param {object} alternateHandlers Optional: An configuration options object to specify alternate event handlers.
                 * Property names may be any of the following functions:
                 * 'onstart' Event handler to invoke when the operation starts.
                 * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
                 * 'onsuccess' Event handler to invoke when the operation completes successfully.
                 * 'onfinish' Event handler to invoke when the operation finishes.
                 * 'onabort' Event handler to invoke when the operation is aborted.
                 * 'onerror' Event handler to invoke when an error occurs.
                 */
                FileReaderManager.prototype.addFileReaderEventListeners = function (formId, reader, alternateHandlers) {
                    var onFileReaderChanged = Shared_5.Forms[formId].onFileReaderChanged;
                    if (!Utils_3._isString(onFileReaderChanged))
                        return;
                    this.addFileReaderOrUploadEventListeners(formId, reader, reader, onFileReaderChanged, true, alternateHandlers);
                };
                /**
                 * Set up event handlers for an XMLHttpRequest.upload or FileReader object.
                 * @param {string} formId The form identifier.
                 * @param {XMLHttpRequest | FileReader} owner The object that owns the eventTarget (on which 'abort()' should be called if requested).
                 * @param {object} eventTarget An object to which event listeners will be added.
                 * If it's an XMLHttpRequest instance then it should its 'upload' property.
                 * Otherwise, this is the same object has the 'owner'.
                 * @param {string} interopCallback The name of the .NET callback function to invoke when a change occurs.
                 * @param {boolean} hasFiles true if it's an upload operation with files; otherwise, false.
                 * @param {object} alternateHandlers Optional: A configuration options object to specify alternate event handlers.
                 * Property names may be any of the following functions:
                 * 'onstart' Event handler to invoke when the operation starts.
                 * 'onprogress' Event handler to invoke the progress event. This handler should be capable of handling a Promise<boolean>.
                 * 'onsuccess' Event handler to invoke when the operation completes successfully.
                 * 'onfinish' Event handler to invoke when the operation finishes.
                 * 'onabort' Event handler to invoke when the operation is aborted.
                 * 'onerror' Event handler to invoke when an error occurs.
                 */
                FileReaderManager.prototype.addFileReaderOrUploadEventListeners = function (formId, owner, eventTarget, interopCallback, hasFiles, alternateHandlers) {
                    var me = this;
                    /**
                     * Handles a progress event.
                     * @param {ProgressEvent<XMLHttpRequest>|ProgressEvent<FileReader>} e The event data.
                     */
                    function handleEvent(e) {
                        return __awaiter(this, void 0, void 0, function () {
                            var progressData;
                            return __generator(this, function (_a) {
                                progressData = {
                                    bytesReadOrSent: e.loaded,
                                    totalBytesToReadOrSend: e.total,
                                    eventType: UPLOAD_EVENTS[e.type] | 0,
                                    hasFiles: hasFiles
                                };
                                if (me.progressEvent.anySubscriber())
                                    me.progressEvent.trigger({ formId: formId, interopCallback: interopCallback, progressData: progressData });
                                if (me.interopInvoker)
                                    return [2 /*return*/, me.interopInvoker.invokeDotNet(formId, interopCallback, progressData)];
                                return [2 /*return*/, CompletedPromise];
                            });
                        });
                    }
                    var _a = alternateHandlers || {}, onstart = _a.onstart, onprogress = _a.onprogress, onsuccess = _a.onsuccess, onfinish = _a.onfinish, onabort = _a.onabort, onerror = _a.onerror;
                    if (!onstart)
                        onstart = handleEvent;
                    // The upload/read has begun.
                    DomEventManager_1.addEventHandler(eventTarget, 'loadstart', onstart);
                    if (!onsuccess)
                        onsuccess = handleEvent;
                    // The upload/read completed successfully.
                    DomEventManager_1.addEventHandler(eventTarget, 'load', onsuccess);
                    if (!onfinish)
                        onfinish = handleEvent;
                    /**
                     * The upload/read finished. This event does not differentiate between
                     * success or failure, and is sent at the end of the upload
                     * regardless of the outcome. Prior to this event, one of load,
                     * error, abort, or timeout will already have been delivered to
                     * indicate why the upload ended.
                     */
                    DomEventManager_1.addEventHandler(eventTarget, 'loadend', onfinish);
                    if (!onprogress)
                        onprogress = function (e) {
                            handleEvent(e).then(function (cancel) { return (cancel) && owner.abort(); });
                        };
                    // Periodically delivered to indicate the amount of progress made so far.
                    DomEventManager_1.addEventHandler(eventTarget, 'progress', onprogress);
                    if (!onerror)
                        onerror = handleEvent;
                    // The upload/read failed due to an error.
                    DomEventManager_1.addEventHandler(eventTarget, 'error', onerror);
                    if (!onabort)
                        onabort = handleEvent;
                    // The upload/read operation was aborted.
                    DomEventManager_1.addEventHandler(eventTarget, 'abort', onabort);
                    if ('ontimeout' in eventTarget) {
                        // The upload timed out because a reply did not arrive within 
                        // the time interval specified by the XMLHttpRequest.timeout.
                        DomEventManager_1.addEventHandler(eventTarget, 'timeout', handleEvent);
                    }
                };
                /**
                 * Read input files using the specified options
                 * @param {{ formId: string, inputId: string, inputName: string, accept: string, acceptType: string, multiple: boolean, createObjectUrl: boolean, method: {readAsArrayBuffer: number, readAsBinaryString: number, readAsDataURL: number, readAsText: number, enumerate: number}, imagePreviewOptions: { autoGenerate: boolean, generateFileInfo: boolean, tagName: string, tagClass: string, tagId: string, attributeName: string, wrapperSelector: string, width: number, height: number, noResize: boolean, preserveAspectRatio: boolean }}}
                 * options The file reader options.
                 * @param {(files: FileList | File[]) => void} processedFileListCallback
                 * A callback function that receives an array of the files effectively processed.
                 */
                FileReaderManager.prototype.readInputFiles = function (options, processedFileListCallback) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, succeeded, error, code, formId, method, inputId, onFileReaderResult, input;
                        return __generator(this, function (_a) {
                            ConsoleLogger_4.logDebug(options.formId, "Preparing to read input files with options", options);
                            ERROR_CODE_BASE = 100;
                            succeeded = false, error = '', code = 0;
                            if (!_supportsFileReader) {
                                return [2 /*return*/, { succeeded: succeeded, error: "Your device does not support the FileReader API.", code: ERROR_CODE_BASE + 1 }];
                            }
                            formId = options.formId, method = options.method, inputId = options.inputId;
                            ConsoleLogger_4.logDebug(formId, "Reading file(s) from input using options", options);
                            onFileReaderResult = Shared_5.Forms[formId].onFileReaderResult;
                            if (FILE_READER_FUNC[method] === undefined) {
                                succeeded = false;
                                code = ERROR_CODE_BASE + 2;
                                error = "Unsupported file reader method: ".concat(method);
                            }
                            else if (Utils_3._isString(inputId)) {
                                if (!Utils_3._isString(onFileReaderResult))
                                    ConsoleLogger_4.logWarning(formId, "Managed callback 'onFileReaderResult' not specified.");
                                input = document.getElementById(inputId);
                                if (input && 'files' in input) {
                                    return [2 /*return*/, this.readFileList(input.files, options, processedFileListCallback)];
                                }
                                else {
                                    code = ERROR_CODE_BASE + 4;
                                    error = "Specified input id #".concat(inputId, " does not identify an input element of type 'file'.");
                                }
                            }
                            else {
                                code = ERROR_CODE_BASE + 3;
                                error = "Invalid file reader options: 'inputId' not present.";
                            }
                            ConsoleLogger_4.logError(formId, error);
                            succeeded = false;
                            return [2 /*return*/, { succeeded: succeeded, error: error, code: code }];
                        });
                    });
                };
                FileReaderManager.prototype.enforceMultipleFilesPolicy = function (formId, targetId, fileCount) {
                    if (fileCount > 1)
                        ConsoleLogger_4.logWarning(null, "Dropping multiple files (".concat(fileCount, ") here is not allowed. Picking first and ignoring the rest."));
                    fileCount = this.dragDropGetFileCount(targetId);
                    ConsoleLogger_4.logDebug(formId, "dragDropGetFileCount", fileCount);
                    // remove existing files
                    if (fileCount > 0)
                        Utils_3.removeFileList({ formId: formId, targetId: targetId });
                };
                /**
                 * Read a list of files.
                 * @param files The list of files to read.
                 * @param options An object that encapsulates settings for file reading operations.
                 * @param processedFileListCallback A callback function that receives an array of the files effectively processed.
                 * @param storeOnly true to validate file acceptance and store files without reading them; otherwise, false.
                 */
                FileReaderManager.prototype.readFileList = function (files, options, processedFileListCallback, storeOnly) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, fileList, fileCount, formId, accept, acceptType, multiple, inputId, createObjectUrl_1, hasAccept, hasAcceptType, acceptAllFiles, supportedFiles, processedFileList, onReadFileList, hasCallback, hasOnReadFileList, abortedByUser, notAllowed, dimensions_1, _loop_3, this_1, i, state_3, filesRead, error;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    ERROR_CODE_BASE = 200;
                                    fileList = files instanceof Array ? files : Array.from(files);
                                    fileCount = fileList && fileList.length || 0;
                                    if (!(fileCount > 0)) return [3 /*break*/, 9];
                                    formId = options.formId, accept = options.accept, acceptType = options.acceptType, multiple = options.multiple, inputId = options.inputId, createObjectUrl_1 = options.createObjectUrl;
                                    // check for multiple files
                                    if (!multiple)
                                        this.enforceMultipleFilesPolicy(formId, inputId, fileCount);
                                    hasAccept = Utils_3._isString(accept);
                                    hasAcceptType = Utils_3._isString(acceptType);
                                    acceptAllFiles = !(hasAccept || hasAcceptType);
                                    supportedFiles = acceptAllFiles
                                        ? []
                                        : hasAccept ? (accept + '').split(',').map(function (type) { return type.trim().toLowerCase(); }) : undefined;
                                    processedFileList = [];
                                    onReadFileList = Shared_5.Forms[formId].onReadFileList;
                                    hasCallback = Utils_3._isFunction(processedFileListCallback);
                                    hasOnReadFileList = Utils_3._isString(onReadFileList);
                                    abortedByUser = "File list reading operation has been aborted by user";
                                    notAllowed = false;
                                    dimensions_1 = { width: 0, height: 0 };
                                    this._readFileListAborted = false;
                                    if (acceptAllFiles)
                                        ConsoleLogger_4.logDebug(formId, "Any file accepted.");
                                    if (!hasOnReadFileList) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onReadFileList, { type: READ_FILE_LIST_EVENTS["start"], totalFilesToRead: fileCount })];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _loop_3 = function (i) {
                                        var file, evArgs, cancel, evArgs, cancel, result, evArgs, cancel, evArgs;
                                        return __generator(this, function (_b) {
                                            switch (_b.label) {
                                                case 0:
                                                    ConsoleLogger_4.logDebug(formId, "Processing file... ".concat(i + 1, " of ").concat(fileCount));
                                                    file = fileList[i];
                                                    if (!!acceptAllFiles) return [3 /*break*/, 6];
                                                    if (!hasAccept) return [3 /*break*/, 3];
                                                    if (!!Utils_3.supportsFileExtension(file.name, supportedFiles)) return [3 /*break*/, 3];
                                                    ConsoleLogger_4.logWarning(formId, "File \"".concat(file.name, "\" is not allowed."));
                                                    notAllowed = true;
                                                    if (!hasOnReadFileList) return [3 /*break*/, 2];
                                                    evArgs = {
                                                        type: READ_FILE_LIST_EVENTS["rejected"],
                                                        reason: READ_FILE_LIST_REJECTION["extension"],
                                                        file: Utils_3.createFileInfo(file, null, createObjectUrl_1),
                                                        filesRead: i + 1,
                                                        totalFilesToRead: fileCount
                                                    };
                                                    return [4 /*yield*/, this_1.interopInvoker.invokeDotNet(formId, onReadFileList, evArgs)];
                                                case 1:
                                                    cancel = _b.sent();
                                                    if (cancel) {
                                                        this_1._readFileListAborted = true;
                                                        ConsoleLogger_4.logDebug(formId, "".concat(abortedByUser, " after rejected file extension."));
                                                        return [2 /*return*/, "break"];
                                                    }
                                                    _b.label = 2;
                                                case 2: return [2 /*return*/, "continue"];
                                                case 3:
                                                    if (!hasAcceptType) return [3 /*break*/, 6];
                                                    if (!(file.type && file.type.indexOf(acceptType) === -1)) return [3 /*break*/, 6];
                                                    ConsoleLogger_4.logWarning(formId, "File \"".concat(file.name, "\" of type ").concat(file.type, " is not allowed."));
                                                    notAllowed = true;
                                                    if (!hasOnReadFileList) return [3 /*break*/, 5];
                                                    evArgs = {
                                                        type: READ_FILE_LIST_EVENTS["rejected"],
                                                        reason: READ_FILE_LIST_REJECTION["type"],
                                                        file: Utils_3.createFileInfo(file, null, createObjectUrl_1),
                                                        filesRead: i + 1,
                                                        totalFilesToRead: fileCount
                                                    };
                                                    return [4 /*yield*/, this_1.interopInvoker.invokeDotNet(formId, onReadFileList, evArgs)];
                                                case 4:
                                                    cancel = _b.sent();
                                                    if (cancel) {
                                                        this_1._readFileListAborted = true;
                                                        ConsoleLogger_4.logDebug(formId, "".concat(abortedByUser, " after rejected file type."));
                                                        return [2 /*return*/, "break"];
                                                    }
                                                    _b.label = 5;
                                                case 5: return [2 /*return*/, "continue"];
                                                case 6:
                                                    dimensions_1 = null;
                                                    if (!!storeOnly) return [3 /*break*/, 8];
                                                    ConsoleLogger_4.logDebug(formId, "Reading file ".concat(file.name));
                                                    return [4 /*yield*/, this_1.readFileCore(file, options, function (dataURL) { return __awaiter(_this, void 0, void 0, function () {
                                                            return __generator(this, function (_a) {
                                                                switch (_a.label) {
                                                                    case 0:
                                                                        if (!this.previewGenerator) {
                                                                            this.previewGenerator = new ImagePreviewGenerator_1.ImagePreviewGenerator();
                                                                        }
                                                                        return [4 /*yield*/, this.previewGenerator.generateImagePreview(dataURL, file, options)];
                                                                    case 1:
                                                                        dimensions_1 = _a.sent();
                                                                        return [2 /*return*/];
                                                                }
                                                            });
                                                        }); })];
                                                case 7:
                                                    result = _b.sent();
                                                    if (result.aborted) {
                                                        this_1._readFileListAborted = true;
                                                        return [2 /*return*/, "break"];
                                                    }
                                                    _b.label = 8;
                                                case 8:
                                                    if (!hasOnReadFileList) return [3 /*break*/, 10];
                                                    evArgs = {
                                                        type: READ_FILE_LIST_EVENTS["processed"],
                                                        file: Utils_3.createFileInfo(file, dimensions_1, createObjectUrl_1),
                                                        filesRead: i + 1,
                                                        totalFilesToRead: fileCount
                                                    };
                                                    return [4 /*yield*/, this_1.interopInvoker.invokeDotNet(formId, onReadFileList, evArgs)];
                                                case 9:
                                                    cancel = _b.sent();
                                                    if (cancel) {
                                                        if (cancel === 5)
                                                            return [2 /*return*/, "continue"]; // rejection by application policy (file ignored)
                                                        this_1._readFileListAborted = true;
                                                        ConsoleLogger_4.logDebug(formId, abortedByUser);
                                                        return [2 /*return*/, "break"];
                                                    }
                                                    _b.label = 10;
                                                case 10:
                                                    if (hasCallback)
                                                        processedFileList.push(file);
                                                    if (this_1._readFileListAborted)
                                                        return [2 /*return*/, "break"];
                                                    if (!!multiple) return [3 /*break*/, 13];
                                                    if (!(fileCount > 1)) return [3 /*break*/, 12];
                                                    ConsoleLogger_4.logWarning(formId, "Processing multiple files (".concat(fileCount, ") is not allowed. The remaining files are ignored."));
                                                    if (!hasOnReadFileList) return [3 /*break*/, 12];
                                                    evArgs = {
                                                        type: READ_FILE_LIST_EVENTS["rejected"],
                                                        reason: READ_FILE_LIST_REJECTION["multiple"],
                                                        files: __spreadArray([], fileList, true).slice(i + 1).map(function (f) { return Utils_3.createFileInfo(f, null, createObjectUrl_1); }),
                                                        filesRead: i + 1,
                                                        totalFilesToRead: fileCount
                                                    };
                                                    return [4 /*yield*/, this_1.interopInvoker.invokeDotNet(formId, onReadFileList, evArgs)];
                                                case 11:
                                                    _b.sent();
                                                    _b.label = 12;
                                                case 12: return [2 /*return*/, "break"];
                                                case 13: return [2 /*return*/];
                                            }
                                        });
                                    };
                                    this_1 = this;
                                    i = 0;
                                    _a.label = 3;
                                case 3:
                                    if (!(i < fileCount)) return [3 /*break*/, 6];
                                    return [5 /*yield**/, _loop_3(i)];
                                case 4:
                                    state_3 = _a.sent();
                                    if (state_3 === "break")
                                        return [3 /*break*/, 6];
                                    _a.label = 5;
                                case 5:
                                    i++;
                                    return [3 /*break*/, 3];
                                case 6:
                                    if (this._readFileListAborted)
                                        ConsoleLogger_4.logDebug(formId, "Exited 'readFileList' loop prematurely!");
                                    filesRead = processedFileList.length;
                                    if (!multiple && notAllowed)
                                        this.resetInputFile(formId, options.inputFileId);
                                    if (hasCallback && filesRead && !this._readFileListAborted)
                                        processedFileListCallback.call(this, processedFileList);
                                    if (!hasOnReadFileList) return [3 /*break*/, 8];
                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onReadFileList, {
                                            type: READ_FILE_LIST_EVENTS["end"],
                                            reason: this._readFileListAborted ? READ_FILE_LIST_REJECTION["aborted"] : READ_FILE_LIST_REJECTION["none"],
                                            filesRead: filesRead,
                                            totalFilesToRead: fileCount
                                        })];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8:
                                    this._readFileListAborted = false;
                                    return [2 /*return*/, { succeeded: true, error: null, code: 0 }];
                                case 9:
                                    error = "No file available to read.";
                                    ConsoleLogger_4.logDebug(options.formId, error);
                                    return [2 /*return*/, { succeeded: false, error: error, code: ERROR_CODE_BASE + 1 }];
                            }
                        });
                    });
                };
                /**
                 * Read a file.
                 * @param {File} file
                 * @param {any} options
                 * @param {Promise<void>} setDataURLCallback
                 */
                FileReaderManager.prototype.readFileCore = function (file, options, setDataURLCallback) {
                    return __awaiter(this, void 0, void 0, function () {
                        var formId, method, _a, inputId, _b, inputName, onFileReaderResult, methodName, result, promiseResult, succeeded, aborted, content, contentArray, e_1, error;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    formId = options.formId, method = options.method, _a = options.inputId, inputId = _a === void 0 ? null : _a, _b = options.inputName, inputName = _b === void 0 ? null : _b;
                                    onFileReaderResult = Shared_5.Forms[formId].onFileReaderResult;
                                    methodName = FILE_READER_FUNC[method];
                                    result = {
                                        // given back these 3 properties makes the identification
                                        // in the 'onFileReaderResult' callback more accurate
                                        method: method + "",
                                        inputId: inputId + "",
                                        inputName: inputName + "",
                                        aborted: false,
                                        succeeded: false,
                                        completedInScript: false,
                                        error: "",
                                        content: "",
                                        contentArray: [],
                                    };
                                    _c.label = 1;
                                case 1:
                                    _c.trys.push([1, 11, , 14]);
                                    if (!(methodName === "enumerate")) return [3 /*break*/, 2];
                                    ConsoleLogger_4.logDebug(formId, "Enumerating file ", file);
                                    result.succeeded = true;
                                    return [3 /*break*/, 8];
                                case 2: return [4 /*yield*/, this.createFileReaderPromise(formId, file, method)];
                                case 3:
                                    promiseResult = _c.sent();
                                    succeeded = promiseResult.succeeded, aborted = promiseResult.aborted, content = promiseResult.content;
                                    if (!succeeded) return [3 /*break*/, 7];
                                    if (!(methodName === "readAsArrayBuffer")) return [3 /*break*/, 4];
                                    contentArray = Array.prototype.slice.call(new Uint8Array(content));
                                    result.contentArray = contentArray;
                                    return [3 /*break*/, 7];
                                case 4:
                                    if (!(Utils_3._isFunction(setDataURLCallback) &&
                                        methodName === "readAsDataURL" &&
                                        file.type && file.type.indexOf("image") !== -1)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, setDataURLCallback.call(this, content)];
                                case 5:
                                    _c.sent();
                                    result.completedInScript = true;
                                    return [3 /*break*/, 7];
                                case 6:
                                    result.content = content;
                                    _c.label = 7;
                                case 7:
                                    result.succeeded = succeeded;
                                    result.aborted = !!aborted;
                                    _c.label = 8;
                                case 8:
                                    if (!Utils_3._isString(onFileReaderResult)) return [3 /*break*/, 10];
                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onFileReaderResult, result)];
                                case 9:
                                    _c.sent();
                                    _c.label = 10;
                                case 10:
                                    // clean up
                                    if (!result.completedInScript) {
                                        result.content = null;
                                        result.contentArray = null;
                                    }
                                    return [2 /*return*/, result];
                                case 11:
                                    e_1 = _c.sent();
                                    error = e_1.message || e_1;
                                    result.succeeded = false;
                                    result.error = error + "";
                                    ConsoleLogger_4.logError(formId, e_1);
                                    if (!Utils_3._isString(onFileReaderResult)) return [3 /*break*/, 13];
                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onFileReaderResult, result)];
                                case 12:
                                    _c.sent();
                                    _c.label = 13;
                                case 13: return [2 /*return*/, result];
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Remove from the processed file storage the files
                 * that have been previously been successfully selected.
                 * @param {{formId: string; inputId?: string}} options
                 */
                FileReaderManager.prototype.deleteProcessedFileList = function (options) {
                    var _a = options || {}, formId = _a.formId, inputId = _a.inputId;
                    var config = this._processedFileStorage[formId];
                    if (config) {
                        ConsoleLogger_4.logDebug("Deleting processed files with options: ", options);
                        var inputs = config.inputs;
                        if (inputId && inputs) {
                            var input = inputs.find(function (inp) { return inp.id === inputId; });
                            if (!!input) {
                                delete input.id;
                                delete input.name;
                                delete input.files;
                            }
                        }
                        // remove the entire storage for the specified form
                        delete this._processedFileStorage[formId];
                        ConsoleLogger_4.logDebug("Deleted processed file storage for form #" + formId);
                        return true;
                    }
                    else {
                        //logDebug("No processed files associated with form #" + formId);
                    }
                    return false;
                };
                /**
                 * Create a Promise that will handle all supported file reading events and notifications to the Blazor app.
                 * @param {string} formId The form identifier.
                 * @param {File} file The file to read.
                 * @param {number} method An integer between 1 and 4.
                 * @return {Promise<{succeeded: boolean, aborted: boolean, content: string|ArrayBuffer}>}
                 */
                FileReaderManager.prototype.createFileReaderPromise = function (formId, file, method) {
                    var _this = this;
                    var methodName = FILE_READER_FUNC[method];
                    var onFileReaderChanged = Shared_5.Forms[formId].onFileReaderChanged;
                    var me = this;
                    return new Promise(function (resolve, reject) {
                        try {
                            var succeeded_1 = false;
                            var aborted_1 = false;
                            var reader_1 = new FileReader();
                            // custom event handlers
                            var onstart = function (e) { return raiseNotification(e); };
                            var onprogress_1 = function (e) { return __awaiter(_this, void 0, void 0, function () {
                                var cancel;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, raiseNotification(e)];
                                        case 1:
                                            cancel = _a.sent();
                                            if (cancel) {
                                                // Phew! This one was hard to debug...!
                                                // The local 'aborted' flag isn't enough for a small-sized file;
                                                // it may have already been read to end after the notification returns,
                                                // hence the 'readFileList' function won't get a chance to quit because
                                                // the 'aborted' property isn't set in the resolved object.
                                                // That's why we also set the '_readFileListAborted' field to true in
                                                // case the current promise was created in the call-chain of 'readFileList'.
                                                this._readFileListAborted = aborted_1 = true;
                                                reader_1.abort();
                                                ConsoleLogger_4.logWarning(formId, "File reading operation was aborted on demand.");
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            // onload
                            var onsuccess = function (e) {
                                succeeded_1 = !aborted_1;
                                return raiseNotification(e);
                            };
                            // onloadend
                            var onfinish = function (e) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, raiseNotification(e)];
                                        case 1:
                                            _a.sent();
                                            resolve({ succeeded: succeeded_1, aborted: aborted_1, content: aborted_1 ? null : e.target.result });
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            var onerror_1 = function (e) { return __awaiter(_this, void 0, void 0, function () {
                                var error;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            error = "Failed to read file! Reason: ".concat(reader_1.error);
                                            ConsoleLogger_4.logDebug(formId, error);
                                            return [4 /*yield*/, raiseNotification(e, error)];
                                        case 1:
                                            _a.sent();
                                            reject(error);
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            var onabort_1 = function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    this._readFileListAborted = aborted_1 = true;
                                    return [2 /*return*/];
                                });
                            }); };
                            var alternateHandlers = { onstart: onstart, onprogress: onprogress_1, onsuccess: onsuccess, onfinish: onfinish, onerror: onerror_1, onabort: onabort_1 };
                            _this.addFileReaderEventListeners(formId, reader_1, alternateHandlers);
                            ConsoleLogger_4.logDebug(formId, "Attempting to read file using method", methodName);
                            switch (methodName) {
                                case "readAsArrayBuffer":
                                    reader_1.readAsArrayBuffer(file);
                                    break;
                                case "readAsBinaryString":
                                    reader_1.readAsBinaryString(file);
                                    break;
                                case "readAsDataURL":
                                    reader_1.readAsDataURL(file);
                                    break;
                                case "readAsText":
                                    reader_1.readAsText(file);
                                    break;
                                default:
                                    reject(new Error("Unsupported method: ".concat(method)));
                            }
                        }
                        catch (e) {
                            ConsoleLogger_4.logDebug(formId, "Error reading file", e);
                            reject(e);
                        }
                    });
                    /**
                     * Invoke .NET method when a progress event is received.
                     * @param {ProgressEvent<FileReader>} e The event data.
                     * @param {string} error Optional: A message that describes the error that might have occurred.
                     */
                    function raiseNotification(e, error) {
                        return __awaiter(this, void 0, void 0, function () {
                            var eventType, eventData;
                            return __generator(this, function (_a) {
                                eventType = UPLOAD_EVENTS[e.type] | 0;
                                eventData = {
                                    bytesReadOrSent: e.loaded,
                                    totalBytesToReadOrSend: e.total,
                                    eventType: eventType,
                                    hasFiles: true,
                                    error: error || null
                                };
                                if (eventType === 0)
                                    eventData['file'] = Utils_3.createFileInfo(file);
                                return [2 /*return*/, me.interopInvoker.invokeDotNet(formId, onFileReaderChanged, eventData)];
                            });
                        });
                    }
                };
                /**
                 * Attempt to set the value of an input file to an empty string.
                 * @param {string} formId The form identifier.
                 * @param {string} inputFileId The identifier of the input file to reset.
                 */
                FileReaderManager.prototype.resetInputFile = function (formId, inputFileId) {
                    ConsoleLogger_4.logDebug(formId, "Resetting input file #".concat(inputFileId));
                    try {
                        var input = document.getElementById(inputFileId);
                        input && (input.value = "");
                    }
                    catch (e) {
                        ConsoleLogger_4.logError(formId, "Error resetting the value of file input #".concat(inputFileId), e);
                    }
                };
                /**
                 * Return the number of files dropped on the identified target.
                 * @param {string} dropTargetId
                 */
                FileReaderManager.prototype.dragDropGetFileCount = function (dropTargetId) {
                    var config = Shared_5.DragDropStorage[dropTargetId];
                    return (!!config && !!config.droppedFiles && config.droppedFiles.fileCount | 0) || 0;
                };
                return FileReaderManager;
            }());
            exports_8("FileReaderManager", FileReaderManager);
        }
    };
});
System.register("DragDropManager", ["ConsoleLogger", "DomEventManager", "Shared", "Utils"], function (exports_9, context_9) {
    "use strict";
    var ConsoleLogger_5, DomEventManager_2, Shared_6, Utils_4, DROP_EFFECTS, DROP_EFFECTS_ALLOWED, DragDropManager;
    var __moduleName = context_9 && context_9.id;
    return {
        setters: [
            function (ConsoleLogger_5_1) {
                ConsoleLogger_5 = ConsoleLogger_5_1;
            },
            function (DomEventManager_2_1) {
                DomEventManager_2 = DomEventManager_2_1;
            },
            function (Shared_6_1) {
                Shared_6 = Shared_6_1;
            },
            function (Utils_4_1) {
                Utils_4 = Utils_4_1;
            }
        ],
        execute: function () {
            DROP_EFFECTS = { none: 0, copy: 1, link: 2, move: 3 };
            DROP_EFFECTS_ALLOWED = { none: 0, copy: 1, copyLink: 2, copyMove: 3, link: 4, linkMove: 5, move: 6, all: 7, uninitialized: 8 };
            DragDropManager = /** @class */ (function () {
                function DragDropManager(fileManager, interopInvoker) {
                    this.fileManager = fileManager;
                    this.interopInvoker = interopInvoker;
                }
                /**
                 * Enable drag and drop support for the target element.
                 * @param {any} options An object that contains at least these 3 properties: 'dropTargetId', 'dropEffect', and 'inputName'.
                 */
                DragDropManager.prototype.enable = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, formId, dropTargetId, succeeded, error, code, targetId, dropTarget_1, _a, dropEffect_1, _b, effectAllowed_1, dragstart, dragover, dropOptions_1, drop;
                        var _this = this;
                        return __generator(this, function (_c) {
                            ERROR_CODE_BASE = 400;
                            formId = options.formId, dropTargetId = options.dropTargetId;
                            ConsoleLogger_5.logDebug(formId, "Enable drag and drop support with options", options);
                            succeeded = false, error = '', code = 0;
                            targetId = "" + dropTargetId;
                            if (targetId in Shared_6.DragDropStorage) {
                                code = ERROR_CODE_BASE + 1;
                                error = "The drop target element identified by #".concat(targetId, " has already been registered.");
                                ConsoleLogger_5.logDebug(formId, error);
                            }
                            else {
                                dropTarget_1 = document.getElementById(targetId);
                                if (dropTarget_1) {
                                    _a = options.dropEffect, dropEffect_1 = _a === void 0 ? "copy" : _a, _b = options.effectAllowed, effectAllowed_1 = _b === void 0 ? "copy" : _b;
                                    dragstart = function (e) { return __awaiter(_this, void 0, void 0, function () {
                                        var effectSet, dt, onDragStart, args, result, data, dataFormat, effect;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    e.stopPropagation();
                                                    e.preventDefault();
                                                    effectSet = false;
                                                    dt = e.dataTransfer;
                                                    ConsoleLogger_5.logDebug(formId, "dragStart: dropEffect = ".concat(dt.dropEffect, " ; effectAllowed = ").concat(dt.effectAllowed));
                                                    onDragStart = Shared_6.Forms[formId].onDragStart;
                                                    if (!Utils_4._isString(onDragStart)) return [3 /*break*/, 2];
                                                    args = DomEventManager_2.getMouseEventArgs(e);
                                                    args['dataTransfer'] = {
                                                        dropEffect: dt.dropEffect,
                                                        effectAllowed: dt.effectAllowed,
                                                        files: [],
                                                        items: __spreadArray([], Array.from(dt.items), true).map(function (i) { return ({ kind: i.kind, type: i.type }); }),
                                                        types: dt.types
                                                    };
                                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onDragStart, args)];
                                                case 1:
                                                    result = _a.sent();
                                                    if (Utils_4._isObject(result)) {
                                                        data = result.data, dataFormat = result.dataFormat, effect = result.effectAllowed;
                                                        if (Utils_4._isString(data) && Utils_4._isString(dataFormat)) {
                                                            dt.setData(dataFormat, data);
                                                            ConsoleLogger_5.logDebug(formId, "Drag start event data set. Format=".concat(dataFormat), data);
                                                        }
                                                        if (Utils_4._isString(effect)) {
                                                            dt.effectAllowed = effect;
                                                            effectSet = true;
                                                        }
                                                    }
                                                    _a.label = 2;
                                                case 2:
                                                    if (!effectSet)
                                                        dt.effectAllowed = effectAllowed_1;
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); };
                                    dragover = function (e) {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        e.dataTransfer.dropEffect = dropEffect_1;
                                    };
                                    dropOptions_1 = Object.assign({}, options);
                                    drop = function (e) {
                                        _this.handleDrop(e, dropOptions_1, dropTarget_1);
                                    };
                                    DomEventManager_2.addEventHandler(dropTarget_1, 'dragstart', dragstart);
                                    DomEventManager_2.addEventHandler(dropTarget_1, 'dragover', dragover);
                                    DomEventManager_2.addEventHandler(dropTarget_1, 'drop', drop);
                                    // required to clean up the mess on demand
                                    Shared_6.DragDropStorage[targetId] = {
                                        dragstart: dragstart,
                                        dragover: dragover,
                                        drop: drop,
                                        options: options
                                    };
                                    succeeded = true;
                                    error = null;
                                    ConsoleLogger_5.logDebug(formId, "Drag and drop enabled for target element #".concat(targetId, "."));
                                }
                                else {
                                    code = ERROR_CODE_BASE + 2;
                                    error = Utils_4.notFound(targetId, "drop target");
                                }
                            }
                            return [2 /*return*/, { succeeded: succeeded, error: error, code: code }];
                        });
                    });
                };
                /**
                 * Clean up by removing drag and drop event listeners.
                 * @param {string} targetId The drop target element identifier.
                 */
                DragDropManager.prototype.disable = function (_a) {
                    var formId = _a.formId, targetId = _a.targetId;
                    var ERROR_CODE_BASE = 500;
                    // explicitly initialize these variables to 
                    // make the return type of the function clear
                    var succeeded = false, error = '', code = 0;
                    if (targetId in Shared_6.DragDropStorage) {
                        var dropTarget = document.getElementById(targetId);
                        if (!!dropTarget) {
                            var config = Shared_6.DragDropStorage[targetId];
                            dropTarget.removeEventListener("dragstart", config.dragstart);
                            dropTarget.removeEventListener("dragover", config.dragover);
                            dropTarget.removeEventListener("drop", config.drop);
                            delete config.dragstart;
                            delete config.dragover;
                            delete config.drop;
                            delete config.options;
                            if ('droppedFiles' in config)
                                delete config.droppedFiles;
                            error = null;
                            succeeded = true;
                            ConsoleLogger_5.logDebug(formId, "Drag and drop disabled for #".concat(targetId, "."));
                        }
                        else {
                            code = ERROR_CODE_BASE + 2;
                            error = Utils_4.notFound(targetId, "drop target");
                        }
                        delete Shared_6.DragDropStorage[targetId];
                    }
                    else {
                        code = ERROR_CODE_BASE + 1;
                        error = "The event listeners for the drop target element #".concat(targetId, " ") +
                            "do not exist or have already been removed.";
                        ConsoleLogger_5.logDebug(formId, error);
                    }
                    return { succeeded: succeeded, error: error, code: code };
                };
                /**
                 * Read files from an input identified by 'options.inputId' and add them to the
                 * temporary drag and drop storage identified by 'options.dropTargetId'.
                 * @param {any} options An object containing the properties 'targetId',
                 * 'inputId', 'inputName', and 'method'.
                 */
                DragDropManager.prototype.dragDropInputFilesOnTarget = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ERROR_CODE_BASE, succeeded, error, code, formId, targetId, inputId, inputName, method, config, newOptions;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    ERROR_CODE_BASE = 600;
                                    succeeded = false, error = '', code = 0;
                                    formId = options.formId, targetId = options.targetId, inputId = options.inputId, inputName = options.inputName, method = options.method;
                                    config = Shared_6.DragDropStorage[targetId];
                                    if (!!config) return [3 /*break*/, 1];
                                    code = ERROR_CODE_BASE + 1;
                                    error = "Drag and drop settings not found for element #".concat(targetId, ".");
                                    ConsoleLogger_5.logError(formId, error);
                                    return [2 /*return*/, { succeeded: succeeded, error: error, code: code }];
                                case 1:
                                    newOptions = Object.assign({}, config.options);
                                    // and set new properties appropriately
                                    newOptions.inputId = inputId;
                                    newOptions.method = method;
                                    return [4 /*yield*/, this.fileManager.readInputFiles(newOptions, function (processedFiles) {
                                            _this.dragDropAfterFilesProcessed(formId, processedFiles, targetId, inputName);
                                        })];
                                case 2: 
                                // finally, read the files and store the processed list into the drag and drop settings
                                return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Add the list of files to the drag and drop store.
                 * @param {string} formId The form identifier.
                 * @param {File[]} files The list of files to add.
                 * @param {string} dropTargetId The identifier of the drop target element.
                 * @param {string} inputName The name of the form field associated with the files.
                 * @param {HTMLElement} dropTargetElement Optional: An HTML element that represents the drop target.
                 * If not specified, 'dropTargetId' is used to retrieve it in the DOM. It is used to remove
                 * the CSS class 'drag-drop-area-empty' from it.
                 * @param {boolean} keepEmtpyClass true to keep the 'drag-drop-area-empty' class on the drop target.
                 */
                DragDropManager.prototype.dragDropAfterFilesProcessed = function (formId, files, dropTargetId, inputName, dropTargetElement, keepEmtpyClass) {
                    var _a;
                    if (files && files.length) {
                        // store the dropped files for later use when submitting the form
                        var config = Shared_6.DragDropStorage[dropTargetId];
                        if (!!config) {
                            // make sure to add to any previously-dropped files
                            var droppedFiles = config.droppedFiles;
                            if (!!droppedFiles) {
                                var existingFiles = droppedFiles[inputName];
                                if (existingFiles instanceof Array)
                                    files = existingFiles.concat(files);
                            }
                            config.droppedFiles = (_a = {}, _a[inputName] = files, _a.fileCount = files.length, _a);
                            ConsoleLogger_5.logDebug(formId, "Dropped files stored for target #".concat(dropTargetId, " and input ").concat(inputName, "."));
                            if (!keepEmtpyClass) {
                                dropTargetElement || (dropTargetElement = document.getElementById(dropTargetId));
                                dropTargetElement && dropTargetElement.classList.remove("drag-drop-area-empty");
                            }
                        }
                        else {
                            ConsoleLogger_5.logError(formId, "No drop store found for target #".concat(dropTargetId, "."));
                        }
                    }
                };
                /**
                 * Collect all files dropped so far.
                 * @param formId The form identifier.
                 */
                DragDropManager.prototype.collectFiles = function (formId) {
                    ConsoleLogger_5.logDebug(formId, "Collecting drag/drop files...");
                    var collectedFiles = [];
                    var dds = Shared_6.DragDropStorage;
                    for (var dropTargetId in dds) {
                        if (dds.hasOwnProperty(dropTargetId)) {
                            var config = dds[dropTargetId];
                            var droppedFiles = config.droppedFiles;
                            if (!!droppedFiles && droppedFiles.fileCount > 0) {
                                for (var inputName in droppedFiles) {
                                    if (droppedFiles.hasOwnProperty(inputName)) {
                                        var fileList = droppedFiles[inputName];
                                        for (var i = 0; i < fileList.length; i++) {
                                            collectedFiles.push({
                                                name: inputName,
                                                value: fileList[i]
                                            });
                                        }
                                    }
                                }
                            }
                            else {
                                ConsoleLogger_5.logDebug(formId, "No file dropped onto target #".concat(dropTargetId, "."));
                            }
                        }
                    }
                    ConsoleLogger_5.logDebug(formId, "Collected ".concat(collectedFiles.length, " drag and drop file(s) for target elements."));
                    return collectedFiles;
                };
                /**
                 * Handles the 'drop' event.
                 * @param {DragEvent} e
                 * @param {any} options
                 * @param {HTMLElement} dropTarget
                 */
                DragDropManager.prototype.handleDrop = function (e, options, dropTarget) {
                    return __awaiter(this, void 0, void 0, function () {
                        var formId, inputFileId, multiple, inputName, createObjectUrl, dt, fileList, fileCount, hasFiles, files, onDropInterop, filesToProcess, storeFilesOnly, args, result, cancel, acceptedFiles, storeOnly, maxFileCount, maxTotalSize, imagePreviewOptions, fileNamesAsStringArray, maxcount, sum, totalFiles, maxTotalSizeBytes, i, file, initialFileCount, cb;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    e.stopPropagation();
                                    e.preventDefault();
                                    formId = options.formId, inputFileId = options.inputFileId, multiple = options.multiple, inputName = options.inputName, createObjectUrl = options.createObjectUrl;
                                    dt = e.dataTransfer;
                                    fileList = Array.from(dt.files);
                                    fileCount = fileList && fileList.length || 0;
                                    hasFiles = fileCount > 0;
                                    files = hasFiles ? __spreadArray([], fileList, true) : [];
                                    onDropInterop = Shared_6.Forms[formId].onDrop;
                                    filesToProcess = files;
                                    storeFilesOnly = false;
                                    ConsoleLogger_5.logDebug(formId, "Processing dropped files with options", options);
                                    if (hasFiles) {
                                        if (!multiple)
                                            filesToProcess = [files[0]];
                                        ConsoleLogger_5.logDebug(formId, "".concat(fileCount, " file(s) dropped onto target element #").concat(dropTarget.id));
                                        if (Utils_4._isString(inputFileId))
                                            this.fileManager.resetInputFile(formId, inputFileId);
                                    }
                                    if (!Utils_4._isString(onDropInterop)) return [3 /*break*/, 2];
                                    args = {
                                        dataTransfer: {
                                            dropEffect: DROP_EFFECTS[dt.dropEffect],
                                            effectAllowed: DROP_EFFECTS_ALLOWED[dt.effectAllowed],
                                            files: hasFiles ? files.map(function (f) { return Utils_4.createFileInfo(f, null, createObjectUrl); }) : [],
                                            items: dt.items ? __spreadArray([], Array.from(dt.items), true).map(function (dti) { return ({ kind: dti.kind, type: dti.type }); }) : [],
                                            types: dt.types,
                                        },
                                        targetId: dropTarget.id,
                                        multiple: !!multiple,
                                    };
                                    ConsoleLogger_5.logDebug(formId, "Drop event args:", args);
                                    return [4 /*yield*/, this.interopInvoker.invokeDotNet(formId, onDropInterop, args)];
                                case 1:
                                    result = _a.sent();
                                    ConsoleLogger_5.logDebug(formId, "Drag event response:", result);
                                    if (Utils_4._isObject(result)) {
                                        cancel = result.cancel, acceptedFiles = result.acceptedFiles, storeOnly = result.storeOnly, maxFileCount = result.maxFileCount, maxTotalSize = result.maxTotalSize, imagePreviewOptions = result.imagePreviewOptions;
                                        if (cancel) {
                                            ConsoleLogger_5.logDebug(formId, "Drop operation has been cancelled by the user/app.");
                                            return [2 /*return*/];
                                        }
                                        if (hasFiles) {
                                            if (acceptedFiles instanceof (Array) && acceptedFiles.length) {
                                                // process only specific files
                                                ConsoleLogger_5.logDebug(formId, "Filtering out specific files to be processed defined by the application.");
                                                fileNamesAsStringArray = acceptedFiles.map(function (n) { return "" + n; });
                                                // find corresponding items in the original 'files' array
                                                filesToProcess = fileNamesAsStringArray
                                                    .map(function (name) { return files.find(function (file) { return file.name === name; }); }) // type- and case-sensitive comparison
                                                    .filter(function (f) { return !!f; }); // remove potentially undefined items returned by the 'map' function
                                            }
                                            maxcount = maxFileCount | 0;
                                            if (maxcount > 0) {
                                                filesToProcess = filesToProcess.slice(0, maxcount);
                                                ConsoleLogger_5.logDebug(formId, "Maximum ".concat(maxcount, " of ").concat(fileCount, " files selected for processing."));
                                            }
                                            if (maxTotalSize > 0) {
                                                ConsoleLogger_5.logDebug("Limiting total file size to ".concat(maxTotalSize, " MB."));
                                                sum = 0;
                                                totalFiles = [];
                                                maxTotalSizeBytes = Shared_6.SIZE_MB * maxTotalSize;
                                                for (i = 0; i < filesToProcess.length; i++) {
                                                    file = filesToProcess[i];
                                                    if ((sum + file.size) <= maxTotalSizeBytes) {
                                                        sum += file.size;
                                                        totalFiles.push(file);
                                                    }
                                                    else {
                                                        break;
                                                    }
                                                }
                                                initialFileCount = filesToProcess.length;
                                                filesToProcess = totalFiles;
                                                ConsoleLogger_5.logDebug(formId, "".concat(filesToProcess.length, " of ").concat(initialFileCount, " files ") +
                                                    "selected for processing.Total size: ".concat(Utils_4.fileSizeToString(sum)));
                                            }
                                            storeFilesOnly = storeOnly;
                                            if (Utils_4._isObject(imagePreviewOptions))
                                                options.imagePreviewOptions = imagePreviewOptions;
                                        }
                                    }
                                    _a.label = 2;
                                case 2:
                                    if (!(hasFiles && filesToProcess.length)) return [3 /*break*/, 4];
                                    ConsoleLogger_5.logDebug(formId, "Processing ".concat(filesToProcess.length, " dropped file(s)..."));
                                    cb = function (processedFileList) {
                                        var dropTargetId = dropTarget.id;
                                        if (storeFilesOnly)
                                            dropTarget = undefined;
                                        _this.dragDropAfterFilesProcessed(formId, processedFileList, dropTargetId, inputName, dropTarget, /*keepEmptyClass:*/ storeFilesOnly);
                                    };
                                    return [4 /*yield*/, this.fileManager.readFileList(filesToProcess, options, cb, storeFilesOnly)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Return the number of files dropped on the identified target.
                 * @param {string} dropTargetId
                 */
                DragDropManager.prototype.dragDropGetFileCount = function (dropTargetId) {
                    var config = Shared_6.DragDropStorage[dropTargetId];
                    return (!!config && !!config.droppedFiles && config.droppedFiles.fileCount | 0) || 0;
                };
                return DragDropManager;
            }());
            exports_9("DragDropManager", DragDropManager);
        }
    };
});
System.register("ReCAPTCHA", ["Shared", "ConsoleLogger", "Utils", "SimpleEvent"], function (exports_10, context_10) {
    "use strict";
    var Shared_7, ConsoleLogger_6, Utils_5, SimpleEvent_2, global, RECAPTCHA_SCRIPT_BASE_URL, OPTIONS, ReCAPTCHA;
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [
            function (Shared_7_1) {
                Shared_7 = Shared_7_1;
            },
            function (ConsoleLogger_6_1) {
                ConsoleLogger_6 = ConsoleLogger_6_1;
            },
            function (Utils_5_1) {
                Utils_5 = Utils_5_1;
            },
            function (SimpleEvent_2_1) {
                SimpleEvent_2 = SimpleEvent_2_1;
            }
        ],
        execute: function () {
            global = globalThis;
            RECAPTCHA_SCRIPT_BASE_URL = 'https://www.google.com/recaptcha/api.js';
            OPTIONS = {};
            /** Seamlessly integrates Google's reCAPTCHA technology. */
            ReCAPTCHA = /** @class */ (function () {
                /**
                 * Initialize a new instance of the ReCAPTCHA class.
                 */
                function ReCAPTCHA() {
                    this._greCAPTCHA = {
                        callbacks: {},
                        scripts: {
                            v1: '',
                            v2: RECAPTCHA_SCRIPT_BASE_URL + '?onload=BlazorFormManagerReCaptchaOnload&render=explicit',
                            v3: RECAPTCHA_SCRIPT_BASE_URL + '?render=',
                            inserted: false,
                            inserting: false
                        }
                    };
                    this._activityEvent = new SimpleEvent_2.SimpleEvent();
                }
                Object.defineProperty(ReCAPTCHA.prototype, "activity", {
                    /** Expose the activity event. */
                    get: function () {
                        return this._activityEvent.expose();
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(ReCAPTCHA.prototype, "options", {
                    /** Return the reCAPTCHA options. */
                    get: function () {
                        return OPTIONS;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Configure the reCAPTCHA for the specified form identifier.
                 * @param formId The form identifier.
                 * @param reCaptcha The configuration options.
                 * @param isReconfiguring Indicates whether the configuration is being repeated.
                 */
                ReCAPTCHA.prototype.configure = function (formId, reCaptcha, isReconfiguring) {
                    var _this = this;
                    if (isReconfiguring === void 0) { isReconfiguring = false; }
                    var scripts = this._greCAPTCHA.scripts;
                    isReconfiguring || (isReconfiguring = !reCaptcha);
                    reCaptcha
                        ? (OPTIONS[reCaptcha.siteKey] = reCaptcha)
                        : (reCaptcha = this.getFirstOption() || { siteKey: '', version: '' });
                    if (!reCaptcha) {
                        ConsoleLogger_6.logError(formId, 'Cannot configure reCAPTCHA when the options are missing.');
                        return false;
                    }
                    ConsoleLogger_6.logDebug(formId, 'Configuring reCAPTCHA with options', reCaptcha);
                    var version = reCaptcha.version, verificationTokenName = reCaptcha.verificationTokenName, invisible = reCaptcha.invisible;
                    var ver = (version || '').toLowerCase();
                    var url = scripts[ver] + '';
                    var success = false;
                    if (!Utils_5._isString(url)) {
                        var message = "Unsupported reCAPTCHA version: ".concat(ver);
                        ConsoleLogger_6.logError(formId, message);
                        this.reportActivity(formId, { formId: formId, message: message, type: 'danger' });
                    }
                    else {
                        if (ver === 'v2') {
                            // register version 2 callback for this form
                            var callbacks = this._greCAPTCHA.callbacks;
                            var cbConfig_1 = {};
                            // reCAPTCHA execution callback used to 
                            // collect the token and submit the form
                            cbConfig_1['setTokenCallback'] = function (token) {
                                ConsoleLogger_6.logDebug(formId, 'reCAPTCHA token received; preparing to submit the form.', token);
                                if (invisible) {
                                    // these properties must be set in the 'handleFormSubmission' 
                                    // function when the form is being submitted
                                    var xhr = cbConfig_1.xhr, formData = cbConfig_1.formData;
                                    if (xhr && formData) {
                                        _this.reportActivity(formId);
                                        var obj = _this.getData(formId, formData, verificationTokenName, token, ver);
                                        xhr.send(obj);
                                    }
                                    else {
                                        var message = 'reCAPTCHA: xhr and formData properties not set.';
                                        ConsoleLogger_6.logError(formId, message);
                                        _this.reportActivity(formId, { formId: formId, message: message, type: 'danger' });
                                    }
                                }
                                else {
                                    // store the token; it will be used when sending the form
                                    cbConfig_1.token = token;
                                    // clear previous (danger|warning, etc.) message
                                    _this.reportActivity(formId);
                                }
                            };
                            callbacks[formId] = cbConfig_1;
                            if (!global.BlazorFormManagerReCaptchaOnload) {
                                // fired when reCAPTCHA is ready
                                global.BlazorFormManagerReCaptchaOnload = function () { return _this.onload(formId, reCaptcha); };
                            }
                            else {
                                this.onload(formId, reCaptcha);
                            }
                        }
                        if (isReconfiguring) {
                            scripts.inserted = !this.requiresReCaptcha(formId);
                            scripts.inserting = false;
                        }
                        this.insertScript(formId, reCaptcha);
                        success = true;
                    }
                    return success;
                };
                /**
                 * Attempt to insert a Google reCAPTCHA script into the document.
                 * @param formId The form identifier.
                 * @param reCaptcha The reCAPTCHA configuration options.
                 * @returns {boolean} true if reCAPTCHA is required; otherwise, false.
                 */
                ReCAPTCHA.prototype.insertScript = function (formId, reCaptcha) {
                    var _this = this;
                    ConsoleLogger_6.logDebug(formId, 'Attempting reCAPTCHA script tag insertion...');
                    var scripts = this._greCAPTCHA.scripts;
                    var shouldInsert = !scripts.inserted && !scripts.inserting && this.requiresReCaptcha(formId);
                    if (shouldInsert) {
                        scripts.inserting = true;
                        reCaptcha
                            ? (OPTIONS[reCaptcha.siteKey] = reCaptcha)
                            : (reCaptcha = this.getFirstOption() || { siteKey: '', version: '' });
                        var siteKey = reCaptcha.siteKey, version = reCaptcha.version;
                        var ver = (version || '').toLowerCase();
                        var url = scripts[ver] + '';
                        if (ver === 'v3')
                            url += siteKey;
                        ConsoleLogger_6.logDebug(formId, 'Inserting reCAPTCHA script tag...', url);
                        var s_1 = document.createElement('script');
                        var heads_1 = document.getElementsByTagName('head');
                        s_1.async = true;
                        s_1.defer = true;
                        s_1.src = url;
                        s_1.onload = function () {
                            scripts.inserted = true;
                            scripts.inserting = false;
                            _this.reportActivity(formId, { formId: formId, message: 'reCAPTCHA script loaded.', type: 'scriptload' });
                        };
                        s_1.onerror = function () {
                            heads_1[0].removeChild(s_1);
                            scripts.inserted = false;
                            scripts.inserting = false;
                            _this.reportActivity(formId, { formId: formId, message: 'Failed to load reCAPTCHA script.', type: 'scriptloaderror' });
                        };
                        if (heads_1.length === 0) {
                            var h = document.createElement('head');
                            document.appendChild(h);
                            h.appendChild(s_1);
                        }
                        else {
                            heads_1[0].appendChild(s_1);
                        }
                        ConsoleLogger_6.logDebug(formId, 'reCAPTCHA script tag inserted successfully!');
                        return true;
                    }
                    else if (scripts.inserted) {
                        ConsoleLogger_6.logDebug(formId, 'reCAPTCHA script has already been inserted.');
                    }
                    else if (scripts.inserting) {
                        ConsoleLogger_6.logDebug(formId, 'reCAPTCHA script is being inserted.');
                    }
                    return false;
                };
                /**
                 * Check if the document requires reCAPTCHA.
                 * @param formId The form identifier.
                 * @returns {boolean} true if reCAPTCHA is required; otherwise, false.
                 */
                ReCAPTCHA.prototype.requiresReCaptcha = function (formId) {
                    var requires = (
                    // check if there's any form in the document
                    document.querySelectorAll('form').length &&
                        // make sure there's no script starting with the reCAPTCHA source
                        document.querySelectorAll("script[src^=\"".concat(RECAPTCHA_SCRIPT_BASE_URL, "\"]")).length === 0);
                    formId && ConsoleLogger_6.logDebug(formId, 'Is reCAPTCHA required?', requires);
                    return requires;
                };
                /**
                 * Return the reCAPTCHA options for the specified site key.
                 * @param siteKey The reCAPTCHA site key identifier.
                 * @returns {ReCaptchaOptions | undefined}
                 */
                ReCAPTCHA.prototype.getOptions = function (siteKey) {
                    return OPTIONS[siteKey];
                };
                /**
                 * Return the first reCAPTCHA options, if any.
                 * @returns
                 */
                ReCAPTCHA.prototype.getFirstOption = function () {
                    var keys = Object.keys(OPTIONS);
                    for (var i = 0; i < keys.length; i++) {
                        if (OPTIONS[keys[i]])
                            return OPTIONS[keys[i]];
                    }
                    return undefined;
                };
                /**
                 * Reset previously created reCAPTCHA widgets.
                 * @param formId The form identifier.
                 * @param reCaptcha The configuration options.
                 */
                ReCAPTCHA.prototype.reset = function (formId, reCaptcha) {
                    reCaptcha || (reCaptcha = this.getFirstOption());
                    if (!reCaptcha) {
                        ConsoleLogger_6.logError(formId, 'reCAPTCHA argument to reset is not defined!');
                        return;
                    }
                    var grecaptcha = globalThis['grecaptcha'];
                    if (!grecaptcha) {
                        ConsoleLogger_6.logError(formId, 'Google reCAPTCHA not loaded!');
                        return;
                    }
                    var version = reCaptcha.version;
                    var ver = version.toLowerCase();
                    if (ver === 'v3') {
                        ConsoleLogger_6.logDebug(formId, 'Google reCAPTCHA version 3 is executed when the form is submitted.');
                        return;
                    }
                    // get the widget identifers that have been rendered
                    var widgets = this.getCallback(formId).widgets;
                    if (widgets && widgets.length) {
                        for (var i = 0; i < widgets.length; i++)
                            grecaptcha.reset(widgets[i]);
                        var message = "reCAPTCHA was reset.";
                        ConsoleLogger_6.logDebug(formId, message);
                        this.reportActivity(formId, { formId: formId, message: message, type: 'warning' });
                    }
                    else {
                        ConsoleLogger_6.logDebug(formId, 'No reCAPTCHA widgets found to reset!');
                    }
                };
                /**
                 * Report an activity related to Google's reCAPTCHA technology.
                 * @param formId The form identifier.
                 * @param activity The activity to report.
                 */
                ReCAPTCHA.prototype.reportActivity = function (formId, activity) {
                    var onReCaptchaActivity = (Shared_7.Forms[formId] || {}).onReCaptchaActivity;
                    if (Utils_5._isString(onReCaptchaActivity)) {
                        if (!activity)
                            activity = { formId: formId, message: '', type: '', data: null };
                        if (activity.data === undefined)
                            activity.data = null;
                        this._activityEvent.trigger(activity);
                    }
                };
                /**
                 * Execute a reCAPTCHA challenge to obtain a token, and submit the identified form with it.
                 * @param formId The form identifier.
                 * @param xhr The object used to send the form.
                 * @param data The form data to send.
                 * @param reCaptcha The reCAPTCHA configuration options.
                 */
                ReCAPTCHA.prototype.submitForm = function (formId, xhr, data, reCaptcha) {
                    var _this = this;
                    var grecaptcha = global.grecaptcha;
                    if (!grecaptcha) {
                        ConsoleLogger_6.logError(formId, "Google reCAPTCHA is not globally available.");
                        xhr.send(data);
                        return false;
                    }
                    var _a = reCaptcha || {}, siteKey = _a.siteKey, version = _a.version, verificationTokenName = _a.verificationTokenName, allowLocalHost = _a.allowLocalHost, invisible = _a.invisible, size = _a.size;
                    var success = false;
                    if (Utils_5._isString(siteKey)) {
                        if (!allowLocalHost && global.location.hostname.toLowerCase().indexOf('localhost') > -1) {
                            var message = "reCAPTCHA not allowed on localhost; sending form using XHR.";
                            ConsoleLogger_6.logWarning(formId, message);
                            this.reportActivity(formId, { formId: formId, message: message, type: 'warning' });
                            xhr.send(data);
                        }
                        else {
                            var ver_1 = version.toLowerCase();
                            ConsoleLogger_6.logDebug(formId, "Trying to submit form using reCAPTCHA version " + ver_1);
                            if (ver_1 === 'v2') {
                                var cbConfig = this.getCallback(formId);
                                if (!cbConfig) {
                                    var message = 'No callback for reCAPTCHA v2 has been ' +
                                        'configured for this form; submitting without the challenge.';
                                    ConsoleLogger_6.logWarning(formId, message);
                                    this.reportActivity(formId, { formId: formId, message: message, type: 'warning' });
                                    xhr.send(data);
                                }
                                else {
                                    if (invisible || size === 'invisible') {
                                        // set these properties so that the reCAPTCHA 
                                        // callback may use them to send the request
                                        cbConfig.xhr = xhr;
                                        cbConfig.formData = data;
                                        // execution, if successful, will delegate the form submission
                                        grecaptcha.execute();
                                    }
                                    else {
                                        var token = cbConfig.token || '';
                                        if (!Utils_5._isString(token)) {
                                            var message = "Please make sure to complete the reCAPTCHA challenge!";
                                            ConsoleLogger_6.logError(formId, message);
                                            this.reportActivity(formId, { formId: formId, message: message, type: 'danger' });
                                        }
                                        else {
                                            var obj = this.getData(formId, data, verificationTokenName, token, ver_1);
                                            xhr.send(obj);
                                            success = true;
                                        }
                                    }
                                }
                            }
                            else if (ver_1 === 'v3') {
                                grecaptcha.ready(function () {
                                    grecaptcha.execute(siteKey, { action: 'submit' }).then(function (token) {
                                        var message = "reCAPTCHA token received.";
                                        ConsoleLogger_6.logDebug(formId, message);
                                        _this.reportActivity(formId, { formId: formId, message: message, type: 'info', data: token });
                                        var obj = _this.getData(formId, data, verificationTokenName, token, ver_1);
                                        xhr.send(obj);
                                        success = true;
                                    });
                                });
                            }
                            else {
                                var message = 'Unsupported reCAPTCHA version: ' + ver_1;
                                ConsoleLogger_6.logWarning(formId, message);
                                this.reportActivity(formId, { formId: formId, message: message, type: 'warning', data: ver_1 });
                                xhr.send(data);
                            }
                        }
                    }
                    else {
                        ConsoleLogger_6.logWarning(formId, "reCAPTCHA form key not defined; sending form using XHR.");
                        xhr.send(data);
                    }
                    return success;
                };
                ReCAPTCHA.prototype.getData = function (formId, data, verificationTokenName, token, ver) {
                    if (data instanceof FormData) {
                        ConsoleLogger_6.logDebug(formId, 'Setting form data values.');
                        data.set(verificationTokenName, token);
                        data.set('g-recaptcha-version', ver);
                        return data;
                    }
                    else {
                        var json = JSON.parse(data);
                        ConsoleLogger_6.logDebug(formId, 'Converted data to JSON prior to setting the verification token name and version.', json);
                        json[verificationTokenName] = token;
                        json['g-recaptcha-version'] = ver;
                        return JSON.stringify(json);
                    }
                };
                ReCAPTCHA.prototype.onload = function (formId, reCaptcha) {
                    var siteKey = reCaptcha.siteKey, them = reCaptcha.theme, languageCode = reCaptcha.languageCode, invisible = reCaptcha.invisible, sz = reCaptcha.size, cssSelector = reCaptcha.cssSelector;
                    var selector = cssSelector || '.g-recaptcha';
                    var form = document.getElementById(formId);
                    var elements = form && form.querySelectorAll(selector) || [];
                    var count = elements.length;
                    if (count > 0) {
                        ConsoleLogger_6.logDebug(formId, "".concat(count, " HTML element(s) with ").concat(selector, " CSS selector found."));
                        var hl = '', size = sz, theme = them;
                        if (languageCode)
                            hl = languageCode;
                        if (invisible)
                            reCaptcha['size'] = size = 'invisible';
                        else if (!Utils_5._isString(size))
                            reCaptcha['size'] = size = 'normal';
                        if (!Utils_5._isString(theme))
                            theme = 'light';
                        var cbConfig = this.getCallback(formId);
                        var parameters = {
                            hl: hl,
                            size: size,
                            theme: theme,
                            'sitekey': siteKey,
                            'callback': cbConfig.setTokenCallback
                        };
                        // since a reCAPTCHA response is verified only once,
                        // we have to store the rendered widget IDs so that 
                        // we can reset them later, should the submission fail
                        var widgets = [];
                        var gr = global.grecaptcha;
                        for (var i = 0; i < count; i++)
                            // grecaptcha.render returns an ID for each created widget
                            widgets.push(gr.render(elements[i], parameters));
                        cbConfig['widgets'] = widgets;
                    }
                    else {
                        ConsoleLogger_6.logError(formId, "No HTML element with ".concat(selector, " CSS selector found."));
                    }
                };
                ReCAPTCHA.prototype.getCallback = function (formId) {
                    return this._greCAPTCHA.callbacks[formId] || {};
                };
                return ReCAPTCHA;
            }());
            exports_10("ReCAPTCHA", ReCAPTCHA);
        }
    };
});
System.register("QuillEditor", ["ConsoleLogger", "Utils"], function (exports_11, context_11) {
    "use strict";
    var ConsoleLogger_7, Utils_6, global, throwDependenciesMissing, parseDelta, Quill, _installed, _installing, _pendingResolvers, QuillEditor;
    var __moduleName = context_11 && context_11.id;
    return {
        setters: [
            function (ConsoleLogger_7_1) {
                ConsoleLogger_7 = ConsoleLogger_7_1;
            },
            function (Utils_6_1) {
                Utils_6 = Utils_6_1;
            }
        ],
        execute: function () {
            global = globalThis;
            throwDependenciesMissing = function () {
                throw new Error("Couldn't install Quill dependencies.");
            };
            parseDelta = function (delta) { return Utils_6._isString(delta) ? JSON.parse(delta) : delta; };
            Quill = global.Quill;
            _pendingResolvers = [];
            /**
             * Provides easy Quill (https://quilljs.com) integration, the
             * free, open source WYSIWYG editor built for the modern web.
             */
            QuillEditor = /** @class */ (function () {
                /**
                 * Initialize a new instance of the QuillEditor class.
                 * @param selector The selector that targets the element used as the editor.
                 * @param options Optional: The options to use.
                 */
                function QuillEditor(selector, options, installOptions) {
                    var _this = this;
                    this.selector = selector;
                    this.options = options;
                    this.installOptions = installOptions;
                    this.instance = null;
                    var _a = this.options = Object.assign({ theme: 'snow' }, options), noinit = _a.noinit, onready = _a.onready;
                    if (!this.options.modules) {
                        ConsoleLogger_7.logDebug(this.options.formId, 'Setting default Quill modules!');
                        this.options.modules = {
                            'toolbar': [[{ 'font': [] }, { 'size': [] }], ['bold', 'italic', 'underline', 'strike'], [{ 'color': [] }, { 'background': [] }], [{ 'script': 'super' }, { 'script': 'sub' }], [{ 'header': [false, 1, 2, 3, 4, 5, 6] }, 'blockquote', 'code-block'], [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'indent': '-1' }, { 'indent': '+1' }], ['direction', { 'align': [] }], ['link', 'image', 'video'], ['clean']]
                        };
                    }
                    // simple security token for invoking a method on the dotnet object reference
                    var changeToken = this.options['changeToken'];
                    // don't leave it in an easily accessible memory location
                    delete this.options['changeToken'];
                    if (!this.installOptions)
                        this.installOptions = Object.assign({}, this.options);
                    if (!noinit)
                        this.init().then(function (success) {
                            if (success) {
                                _this.setupChangeHandler(changeToken);
                                if (onready)
                                    onready(_this);
                            }
                        });
                }
                Object.defineProperty(QuillEditor.prototype, "quill", {
                    /** Get the Quill editor instance for the current selector. */
                    get: function () {
                        if (!this.instance && !Quill)
                            throw new Error("The editor has not been initialized yet! Call await init()");
                        return this.instance || (this.instance = new Quill(this.selector, this.options));
                    },
                    enumerable: false,
                    configurable: true
                });
                /** Install Quill dependencies (if required), and initialize the Quill instance. */
                QuillEditor.prototype.init = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var success;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.instance)
                                        return [2 /*return*/, this.instance];
                                    if (!!Quill) return [3 /*break*/, 2];
                                    return [4 /*yield*/, QuillEditor.install(this.installOptions)];
                                case 1:
                                    success = _a.sent();
                                    if (!success)
                                        throwDependenciesMissing();
                                    _a.label = 2;
                                case 2: return [2 /*return*/, this.quill];
                            }
                        });
                    });
                };
                /**
                 * Get the contents of the editor at the specified index.
                 * @param index The zero-based index at which to get the index.
                 * @param length The number of characters to return.
                 */
                QuillEditor.prototype.getContents = function (index, length) {
                    if (index === void 0) { index = 0; }
                    return this.quill.getContents(index, length);
                };
                /**
                 * Set the contents of the editor.
                 * @param delta The delta object or string to set.
                 */
                QuillEditor.prototype.setContents = function (delta) {
                    return this.quill.setContents(parseDelta(delta));
                };
                /**
                 * Update the contents of the editor.
                 * @param delta The delta object or string to set.
                 */
                QuillEditor.prototype.updateContents = function (delta) {
                    return this.quill.updateContents(parseDelta(delta));
                };
                /**
                 * Delete the text at the specified index.
                 * @param index The zero-based index at which to delete the text.
                 * @param length The number of characters to delete.
                 */
                QuillEditor.prototype.deleteText = function (index, length) {
                    return this.quill.deleteText(index, length);
                };
                /**
                 * Return the text at the specified index.
                 * @param index The zero-based index at which to get the text.
                 * @param remaining The number of the remaining characters to return.
                 */
                QuillEditor.prototype.getText = function (index, remaining) {
                    if (index === void 0) { index = 0; }
                    return this.quill.getText(index, remaining);
                };
                /** Get the inner HTML of the root in the editor. */
                QuillEditor.prototype.getInnerHTML = function () {
                    return this.quill.root.innerHTML;
                };
                /**
                 * Insert an embedded object at the specified index.
                 * @param index The zero-based index at which to insert the object.
                 * @param type The type of object to insert.
                 * @param value The value of the object to insert.
                 */
                QuillEditor.prototype.insertEmbed = function (index, type, value) {
                    return this.quill.insertEmbed(index, type, value);
                };
                /**
                 * Insert some text at the specified index.
                 * @param index The zero-based index at which to insert the text.
                 * @param text The text to insert.
                 * @param format The format of the text to insert.
                 * @param value The value of the text to insert.
                 * @param formats A dictionary specifying the formats of the text to insert.
                 */
                QuillEditor.prototype.insertText = function (index, text, format, value, formats) {
                    if (format)
                        return this.quill.insertText(index, text, format, value);
                    return this.quill.insertText(index, text, value, formats);
                };
                /**
                 * Format the contents
                 * @param name The name of the format.
                 * @param value The value of the format.
                 */
                QuillEditor.prototype.format = function (name, value) {
                    return this.quill.format(name, value);
                };
                /**
                 * Enable or disable the editor.
                 * @param enabled true if the editor is enabled; otherwise, false.
                 */
                QuillEditor.prototype.enable = function (enabled) {
                    this.quill.enable(enabled);
                };
                /** This function is called when the editor's dependencies have been successfully loaded. */
                QuillEditor.prototype.setupChangeHandler = function (changeToken) {
                    var _this = this;
                    var _a;
                    var selector = this.selector;
                    // the dotnet object reference used to report back edit changes
                    var dotnetObj = this.options['dotNetObjectReference'];
                    if (dotnetObj || (typeof selector === 'string' && selector.startsWith('#'))) {
                        // the selector is an element identifier;
                        // the C# class AutoInputBase adds a hidden input for
                        // every rich text-enabled textarea; we'll use that
                        // input to store the changes made through the editor; this
                        // way, the value will be included during the form submission
                        var hiddenInput_1;
                        if (typeof selector === 'string') {
                            var inputId = selector.substring(1) + '_hidden';
                            hiddenInput_1 = document.getElementById(inputId);
                        }
                        if (hiddenInput_1 || dotnetObj) {
                            // the dotnet method to invoke upon change detection
                            var onValueChanged_1 = (_a = this.options['onValueChanged']) !== null && _a !== void 0 ? _a : 'OnValueChanged';
                            this.quill.on('text-change', function () { return __awaiter(_this, void 0, void 0, function () {
                                var value;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            value = this.getInnerHTML();
                                            if (hiddenInput_1)
                                                hiddenInput_1.value = value;
                                            if (!dotnetObj) return [3 /*break*/, 2];
                                            // invoke the dotnet method with the changed value
                                            return [4 /*yield*/, dotnetObj.invokeMethodAsync(onValueChanged_1, value, changeToken)];
                                        case 1:
                                            // invoke the dotnet method with the changed value
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            }); });
                        }
                    }
                };
                /**
                 * Install Quill Editor's dependencies.
                 * @param options The base installation options to use.
                 */
                QuillEditor.install = function (options) {
                    return new Promise(function (resolve) {
                        if (_installed) {
                            resolve(true);
                        }
                        else if (_installing) {
                            // installation in progress; queue subsequent resolvers
                            _pendingResolvers.push(resolve);
                        }
                        else {
                            _installing = true;
                            // queue the first resolver
                            _pendingResolvers.push(resolve);
                            var _a = options.theme, theme = _a === void 0 ? 'snow' : _a, _b = options.version, version = _b === void 0 ? '1.3.6' : _b;
                            var basepath = "https://cdn.quilljs.com/".concat(version);
                            var _c = options.scriptUrl, scriptUrl = _c === void 0 ? "".concat(basepath, "/quill.min.js") : _c, _d = options.styleUrl, styleUrl = _d === void 0 ? "".concat(basepath, "/quill.").concat(theme, ".css") : _d;
                            Utils_6.insertStyles(styleUrl);
                            Utils_6.insertScripts(scriptUrl, function () {
                                // installation done
                                Quill = global.Quill;
                                _installed = !!Quill;
                                while (_pendingResolvers.length) {
                                    // get, invoke, and then remove the resolver
                                    var r = _pendingResolvers[0];
                                    r.call(r, _installed);
                                    _pendingResolvers.splice(0, 1);
                                }
                                _installing = false;
                            });
                        }
                    });
                };
                /**
                 * Register a Quill module.
                 * @param name The name of the module to register.
                 * @param classDef The implementation class of the module.
                 */
                QuillEditor.registerModule = function (name, classDef) {
                    return __awaiter(this, void 0, void 0, function () {
                        function register() {
                            Quill.register('modules/' + name, classDef, true);
                        }
                        var success;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!!Quill) return [3 /*break*/, 2];
                                    return [4 /*yield*/, QuillEditor.install()];
                                case 1:
                                    success = _a.sent();
                                    if (success)
                                        register();
                                    else
                                        throwDependenciesMissing();
                                    return [3 /*break*/, 3];
                                case 2:
                                    register();
                                    _a.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                return QuillEditor;
            }());
            exports_11("QuillEditor", QuillEditor);
        }
    };
});
System.register("ChartjsHelper", ["Utils"], function (exports_12, context_12) {
    "use strict";
    var Utils_7, Chart, ChartjsHelper;
    var __moduleName = context_12 && context_12.id;
    return {
        setters: [
            function (Utils_7_1) {
                Utils_7 = Utils_7_1;
            }
        ],
        execute: function () {
            Chart = window["Chart"];
            ChartjsHelper = /** @class */ (function () {
                function ChartjsHelper() {
                }
                ChartjsHelper.install = function (scriptSource, onload) {
                    return new Promise(function (resolve, reject) {
                        if (Chart) {
                            resolve(true);
                        }
                        else {
                            scriptSource || (scriptSource = 'https://cdn.jsdelivr.net/npm/chart.js');
                            return Utils_7.insertScripts(scriptSource, function (e) {
                                if (onload)
                                    onload.call(e);
                                resolve(true);
                            });
                        }
                    });
                };
                ChartjsHelper.createChart = function (selector, config) {
                    if (!(Chart || (Chart = window["Chart"]))) {
                        throw new Error('Chart is not defined! Please install the Chartjs library first.');
                    }
                    Chart.defaults.global.defaultFontFamily = 'Nunito', '-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif';
                    Chart.defaults.global.defaultFontColor = '#858796';
                    var ctx = document.querySelector(selector);
                    if (!ctx)
                        throw new Error("Could not find any DOM element matching the selector ".concat(selector, "."));
                    config.data || (config.data = {
                        labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],
                        datasets: [{
                                label: '# of Votes',
                                data: [12, 19, 3, 5, 2, 3],
                                borderWidth: 1
                            }]
                    });
                    config.options || (config.options = {
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    });
                    console.log('Creating new chart for selector, and config:', selector, config);
                    var chart = new Chart(ctx, config);
                    return chart;
                };
                return ChartjsHelper;
            }());
            exports_12("ChartjsHelper", ChartjsHelper);
        }
    };
});
System.register("BlazorFormManager", ["ConsoleLogger", "DomEventManager", "DragDropManager", "FileReaderManager", "ReCAPTCHA", "QuillEditor", "ChartjsHelper", "Shared", "Utils"], function (exports_13, context_13) {
    "use strict";
    var ConsoleLogger_8, DomEventManager_3, DragDropManager_1, FileReaderManager_1, ReCAPTCHA_1, QuillEditor_1, ChartjsHelper_1, Shared_8, Utils_8, global, dotNet, XHRSTATE, _resolvedPromise, SESSION_FORMDATA_KEY, BlazorFormManager;
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [
            function (ConsoleLogger_8_1) {
                ConsoleLogger_8 = ConsoleLogger_8_1;
            },
            function (DomEventManager_3_1) {
                DomEventManager_3 = DomEventManager_3_1;
            },
            function (DragDropManager_1_1) {
                DragDropManager_1 = DragDropManager_1_1;
            },
            function (FileReaderManager_1_1) {
                FileReaderManager_1 = FileReaderManager_1_1;
            },
            function (ReCAPTCHA_1_1) {
                ReCAPTCHA_1 = ReCAPTCHA_1_1;
            },
            function (QuillEditor_1_1) {
                QuillEditor_1 = QuillEditor_1_1;
            },
            function (ChartjsHelper_1_1) {
                ChartjsHelper_1 = ChartjsHelper_1_1;
            },
            function (Shared_8_1) {
                Shared_8 = Shared_8_1;
            },
            function (Utils_8_1) {
                Utils_8 = Utils_8_1;
            }
        ],
        execute: function () {
            global = globalThis;
            dotNet = global.DotNet;
            XHRSTATE = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 };
            _resolvedPromise = new Promise(function (resolve, _) { return resolve(false); });
            SESSION_FORMDATA_KEY = 'BlazorFormManager.Session.FormData';
            BlazorFormManager = /** @class */ (function () {
                /** Construct a new instance of the form manager class. */
                function BlazorFormManager() {
                    this.processedFileStorage = {};
                    this._enhancedLoadEventEnabled = false;
                    this.fileManager = new FileReaderManager_1.FileReaderManager(this);
                    this.dragdropManager = new DragDropManager_1.DragDropManager(this.fileManager, this);
                }
                /**
                 * Register a form submit manager.
                 * @param options The options used to initialize the form manager.
                 */
                BlazorFormManager.prototype.init = function (options) {
                    if (!this.updateOptions(options))
                        return BlazorFormManager.showOptionsUsage(false);
                    var dotNetObjectReference = options.dotNetObjectReference, formId = options.formId;
                    ConsoleLogger_8.logDebug(formId, "Initializing with options:", options);
                    if (!this.validateFormAttributes(formId))
                        return false;
                    if (!dotNetObjectReference) {
                        ConsoleLogger_8.logWarning(formId, "Invokable object instance reference not received. " +
                            "This is the preferred way of invoking.NET methods from within " +
                            "Blazor components.");
                    }
                    if (this.registerSubmitHandler(options)) {
                        ConsoleLogger_8.logInfo(formId, "BlazorFormManager initialized successfully!");
                        return true;
                    }
                    return false;
                };
                /**
                 * Destroy all resources used by formId.
                 * @param formId The form identifier.
                 */
                BlazorFormManager.prototype.destroy = function (formId) {
                    if (Shared_8.Forms[formId]) {
                        ConsoleLogger_8.logDebug(formId, "Deleting form manager options...");
                        delete Shared_8.Forms[formId];
                    }
                };
                /**
                 * Update existing form options with the new one.
                 * @param options The new form options.
                 */
                BlazorFormManager.prototype.updateOptions = function (options) {
                    // fail early
                    if (!Utils_8._isObject(options))
                        return BlazorFormManager.showOptionsUsage(true);
                    var formId = options.formId;
                    if (!Shared_8.Forms[formId]) {
                        Shared_8.Forms[formId] = options;
                        ConsoleLogger_8.logDebug(formId, "Script options stored.", options);
                    }
                    else {
                        var storedOptions = Shared_8.Forms[formId];
                        var count = 0;
                        for (var key in options) {
                            if (options.hasOwnProperty(key)) {
                                storedOptions[key] = options[key];
                                count++;
                            }
                        }
                        ConsoleLogger_8.logDebug(formId, "".concat(count, " script properties updated."));
                    }
                    return true;
                };
                /**
                 * Submit the form identified by the given parameter.
                 * @param formId The identifier of the form to submit.
                 */
                BlazorFormManager.prototype.submitForm = function (formId) {
                    ConsoleLogger_8.logDebug(formId, "Form submit requested.", formId);
                    var form = document.getElementById(formId);
                    if (!form) {
                        ConsoleLogger_8.logError(formId, "Form #".concat(formId, " not defined"));
                        return false;
                    }
                    if (form.onsubmit) {
                        form.onsubmit(new SubmitEvent('submit'));
                        ConsoleLogger_8.logInfo(formId, "Form submitted via 'BlazorFormManager.submitForm'.");
                        return true;
                    }
                    ConsoleLogger_8.logError(formId, "'onsubmit' event handler not defined for form #".concat(formId, "."));
                    return false;
                };
                /**
                 * Dynamically initialize MDBootstrap 5 inputs matching the specified CSS query selector.
                 * @param options Initialization options.
                 */
                BlazorFormManager.prototype.initMdbInput = function (options) {
                    var formId = options.formId, inputSelector = options.selector, scoped = options.scoped;
                    var selector = inputSelector || '.form-outline';
                    if (scoped)
                        selector = "#".concat(formId, " ").concat(selector);
                    ConsoleLogger_8.logDebug(formId, "Initializing \"MDBootstrap 5\" inputs with query selector '".concat(selector, "'..."));
                    var query = document.querySelectorAll(selector);
                    if (query.length) {
                        var win_1 = window;
                        if (win_1.mdb && win_1.mdb.Input) {
                            ConsoleLogger_8.logDebug(formId, "\"MDBootstrap 5\" UMD module: ".concat(query.length, " input.s found."));
                            query.forEach(function (formOutline) {
                                if (!formOutline.classList.contains('select')) {
                                    new win_1.mdb.Input(formOutline).init();
                                }
                                else {
                                    //new win.mdb.Dropdown(formOutline, {});
                                }
                            });
                        }
                        else if (win_1.Input) {
                            ConsoleLogger_8.logDebug(formId, "\"MDBootstrap 5\" ES module: ".concat(query.length, " input.s found."));
                            query.forEach(function (formOutline) {
                                if (!formOutline.classList.contains('select')) {
                                    new win_1.Input(formOutline).init();
                                }
                                else {
                                }
                            });
                        }
                        else {
                            ConsoleLogger_8.logDebug(formId, "No \"MDBootstrap 5\" module: ".concat(query.length, " input.s found."));
                        }
                    }
                    else {
                        ConsoleLogger_8.logDebug(formId, "No input found matching the specified CSS query selector.");
                    }
                    selector = scoped ? "#".concat(formId, " .form-floating>label") : '.form-floating>label';
                    query = document.querySelectorAll(selector);
                    if (query.length) {
                        ConsoleLogger_8.logDebug(formId, "Found ".concat(query.length, " input.s with query selector '").concat(selector, "'."));
                        /** Mimick form-outline effect for 'select' elements. */
                        var maybeSetActive_1 = function (select, label, focused) {
                            if (focused === void 0) { focused = false; }
                            var selectIsNumber = label.parentElement.classList.contains('number');
                            var active = focused;
                            if (!focused) {
                                var invalid = selectIsNumber && (select.value === '0' || select.value === '') ||
                                    (!selectIsNumber && select.value === '');
                                active = !invalid;
                            }
                            active ? select.classList.add('active') : select.classList.remove('active');
                        };
                        query.forEach(function (label) {
                            var select = label.previousElementSibling;
                            if (select instanceof HTMLSelectElement) {
                                var _a = select.style, initialBorder_1 = _a.border, initialColor_1 = _a.color;
                                // the free version of MDBootstrap 5 doesn't allow specifying 
                                // '.form-outline' on a 'select' element when initializing inputs
                                label.parentElement.classList.replace('form-floating', 'form-outline');
                                maybeSetActive_1(select, label);
                                select.addEventListener('focus', function () {
                                    maybeSetActive_1(select, label, true);
                                    label.style.color = 'var(--mdb-picker-header-bg)';
                                    select.style.border = '2px solid var(--mdb-picker-header-bg)';
                                });
                                select.addEventListener('blur', function () {
                                    maybeSetActive_1(select, label);
                                    label.style.color = initialColor_1;
                                    select.style.border = initialBorder_1;
                                });
                            }
                        });
                    }
                };
                /**
                 * Sets the value of the pair identified by key to value, creating
                 * a new key/value pair if none existed for key previously.
                 * @param key The key of the value to set.
                 * @param value The value to set.
                 */
                BlazorFormManager.prototype.localStorageSetItem = function (key, value) {
                    localStorage.setItem(key, value);
                };
                /**
                 * Removes the key/value pair with the given key from the list associated
                 * with the object, if a key/value pair with the given key exists.
                 * @param key The key of the value to remove.
                 */
                BlazorFormManager.prototype.localStorageRemoveItem = function (key) {
                    localStorage.removeItem(key);
                };
                /**
                 * Returns the current value associated with the given key, or null if
                 * the given key does not exist in the list associated with the object.
                 * @param key The key of the value to retrieve.
                 */
                BlazorFormManager.prototype.localStorageGetItem = function (key) {
                    return localStorage.getItem(key);
                };
                /**
                 * Register an AJAX handler for the submission of a form.
                 * @param options An configuration object used to register the form submit handler.
                 */
                BlazorFormManager.prototype.registerSubmitHandler = function (options) {
                    var _this_1 = this;
                    var formId = options.formId, onBeforeSubmit = options.onBeforeSubmit, onBeforeSend = options.onBeforeSend, onSendFailed = options.onSendFailed, onSendSucceeded = options.onSendSucceeded, onReCaptchaActivity = options.onReCaptchaActivity, requireModel = options.requireModel, reCaptcha = options.reCaptcha, enhancedLoad = options.enhancedLoad, onEnhancedLoad = options.onEnhancedLoad, sessionStorageKey = options.sessionStorageKey;
                    var _this = this;
                    var recaptcha = _this.initReCaptcha(formId, reCaptcha, onReCaptchaActivity);
                    if (enhancedLoad && Utils_8._isString(onEnhancedLoad)) {
                        this._enableEnhancedLoad(formId, true, onEnhancedLoad);
                    }
                    return this.handleFormSubmission({
                        formId: formId,
                        requireModel: requireModel,
                        reCaptcha: reCaptcha,
                        getFormData: function () { return _this_1.getFormData(formId); },
                        beforeSubmit: function () {
                            return __awaiter(this, void 0, void 0, function () {
                                var cancel;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            cancel = false;
                                            if (!Utils_8._isString(onBeforeSubmit)) return [3 /*break*/, 2];
                                            return [4 /*yield*/, _this.invokeDotNet(formId, onBeforeSubmit)];
                                        case 1:
                                            cancel = _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/, cancel];
                                    }
                                });
                            });
                        },
                        beforeSend: function () {
                            return __awaiter(this, void 0, void 0, function () {
                                var cancel;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            cancel = false;
                                            if (!Utils_8._isString(onBeforeSend)) return [3 /*break*/, 2];
                                            return [4 /*yield*/, _this.invokeDotNet(formId, onBeforeSend, getXhrResult.call(this, true))];
                                        case 1:
                                            cancel = _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/, cancel];
                                    }
                                });
                            });
                        },
                        done: function () {
                            ConsoleLogger_8.logInfo(formId, "Form data successfully uploaded.", this);
                            if (Utils_8._isString(onSendSucceeded))
                                _this.invokeDotNet(formId, onSendSucceeded, getXhrResult.call(this, false));
                            // eventually free up the processed file storage for this form
                            _this.fileManager.deleteProcessedFileList({ formId: formId });
                            _this.raiseFormSubmitted(formId);
                        },
                        fail: function (error) {
                            ConsoleLogger_8.logError(formId, "Form upload failed.", this);
                            if (Utils_8._isString(onSendFailed))
                                _this.invokeDotNet(formId, onSendFailed, getXhrResult.call(this, false, error));
                            recaptcha && recaptcha.reset(formId, reCaptcha);
                        }
                    });
                    function getXhrResult(excludeHeaders, error) {
                        var extraProperties = { error: error };
                        var xhr = this;
                        // these properties may throw an "InvalidStateError" DOMException
                        var responseText, responseType, responseXML;
                        // so we safely access them
                        try {
                            responseText = xhr.responseText || '';
                        }
                        catch (_a) {
                            responseText = null;
                        }
                        try {
                            responseType = xhr.responseType || '';
                        }
                        catch (_b) {
                            responseType = null;
                        }
                        try {
                            responseXML = xhr.responseXML && xhr.responseXML.textContent || null;
                        }
                        catch (_c) {
                            responseXML = null;
                        }
                        return {
                            response: xhr.response || null,
                            responseHeaders: excludeHeaders ? null : xhr.getAllResponseHeaders(),
                            responseText: responseText,
                            responseType: responseType,
                            responseXML: responseXML,
                            status: xhr.status,
                            statusText: xhr.statusText || "",
                            timeout: xhr.timeout,
                            extraProperties: extraProperties,
                        };
                    }
                };
                BlazorFormManager.prototype.getFormData = function (formId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, onGetModel, requireModel, model, form, enctype, hasFiles, json, formData;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = Shared_8.Forms[formId] || {}, onGetModel = _a.onGetModel, requireModel = _a.requireModel;
                                    if (!Utils_8._isString(onGetModel)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.invokeDotNet(formId, onGetModel)];
                                case 1:
                                    model = _b.sent();
                                    ConsoleLogger_8.logDebug(formId, "Model", model);
                                    _b.label = 2;
                                case 2:
                                    if (model === null) {
                                        if (requireModel) {
                                            ConsoleLogger_8.logError(formId, "A model is required.");
                                        }
                                        else {
                                            ConsoleLogger_8.logDebug(formId, "Model not defined. Caller will collect FormData.");
                                        }
                                        return [2 /*return*/, { hasFiles: false, formData: undefined, json: '' }];
                                    }
                                    form = document.getElementById(formId);
                                    enctype = form.getAttribute("enctype") || 'multipart/form-data';
                                    hasFiles = Utils_8.containsFiles(form);
                                    if (enctype.toLowerCase().indexOf('json') > -1) {
                                        if (hasFiles)
                                            ConsoleLogger_8.logWarning(formId, "The form contains files which cannot be sent using the JSON format.");
                                        else
                                            ConsoleLogger_8.logDebug(formId, "Collecting form model data as JSON...");
                                        json = BlazorFormManager.objectFromEntries(new FormData(form), model);
                                        return [2 /*return*/, { hasFiles: hasFiles, formData: undefined, json: json }];
                                    }
                                    else {
                                        ConsoleLogger_8.logDebug(formId, "Collecting form model data...");
                                        formData = new FormData();
                                        // add additional form data values using the model...
                                        this.collectModelData(model, formData);
                                        Utils_8.formDataMerge(formData, new FormData(form));
                                        return [2 /*return*/, { hasFiles: hasFiles, formData: formData, json: '' }];
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                BlazorFormManager.prototype.storeFormData = function (formId, sessionStorageKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, formData, json, itemKey, data;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, this.getFormData(formId)];
                                case 1:
                                    _a = _b.sent(), formData = _a.formData, json = _a.json;
                                    itemKey = "".concat(SESSION_FORMDATA_KEY, ":").concat(sessionStorageKey);
                                    if (json) {
                                        sessionStorage.setItem(itemKey, json);
                                        return [2 /*return*/, json];
                                    }
                                    else if (formData) {
                                        data = BlazorFormManager.objectFromEntries(formData);
                                        sessionStorage.setItem(itemKey, data);
                                        return [2 /*return*/, data];
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                BlazorFormManager.prototype.retrieveFormData = function (sessionStorageKey) {
                    var itemKey = "".concat(SESSION_FORMDATA_KEY, ":").concat(sessionStorageKey);
                    return sessionStorage.getItem(itemKey);
                };
                /**
                 * Set the log level.
                 * @param config The configuration options.
                 */
                BlazorFormManager.prototype.setLogLevel = function (config) {
                    var formId = config.formId, level = config.logLevel;
                    var options = Shared_8.Forms[formId];
                    if (!options) {
                        ConsoleLogger_8.logError(formId, "The form #".concat(formId, " has not been initialized yet."));
                    }
                    else if (options.logLevel !== level) {
                        if (typeof level === "number") {
                            var validLevel = 0 | level; // force the number to be an integer
                            if (validLevel > -1 && validLevel < 5) {
                                options.logLevel = validLevel;
                                ConsoleLogger_8.logInfo(formId, "Log level changed to", validLevel);
                                return true;
                            }
                        }
                        ConsoleLogger_8.logError(formId, "Log level must be an integer between 0 and 4 inclusive.");
                    }
                    return false;
                };
                /**
                 * Handle all aspects of an asynchronous form submission.
                 * @param options The configuration object to use.
                 */
                BlazorFormManager.prototype.handleFormSubmission = function (options) {
                    var _this_1 = this;
                    if (!Utils_8._isObject(options))
                        return false;
                    var formId = options.formId, requireModel = options.requireModel, reCaptcha = options.reCaptcha;
                    if (!Utils_8._isString(formId)) {
                        ConsoleLogger_8.logError(formId, "No form identified!");
                        return false;
                    }
                    var form = document.getElementById(formId);
                    if (!form) {
                        ConsoleLogger_8.logError(formId, "Form with id #".concat(formId, " not found!"));
                        return false;
                    }
                    form.onsubmit = function () { return __awaiter(_this_1, void 0, void 0, function () {
                        var cancel, beforeSubmit, beforeSend, done, fail, getFormData, _a, formData, hasFiles, json, isJson, xhr, url, method, headersSet, xhrResult, objData;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    ConsoleLogger_8.logDebug(formId, "Submitting form...");
                                    cancel = false;
                                    beforeSubmit = options.beforeSubmit;
                                    if (!Utils_8._isFunction(beforeSubmit)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, beforeSubmit.call(form)];
                                case 1:
                                    cancel = _b.sent();
                                    _b.label = 2;
                                case 2:
                                    if (cancel) {
                                        ConsoleLogger_8.logInfo(formId, "Form submission was cancelled.");
                                        return [2 /*return*/, false];
                                    }
                                    if (!!BlazorFormManager._supportsAJAXwithUpload) return [3 /*break*/, 4];
                                    ConsoleLogger_8.logWarning(formId, "AJAX upload with progress report not supported.");
                                    return [4 /*yield*/, this.raiseAjaxUploadWithProgressNotSupported(formId)];
                                case 3:
                                    cancel = _b.sent();
                                    if (cancel) {
                                        // do not allow full page refresh
                                        ConsoleLogger_8.logInfo(formId, "Blocked submitting form with full-page refresh.");
                                        return [2 /*return*/, false];
                                    }
                                    // allow normal form submission (post back with full page refresh)
                                    return [2 /*return*/, true];
                                case 4:
                                    beforeSend = options.beforeSend, done = options.done, fail = options.fail, getFormData = options.getFormData;
                                    return [4 /*yield*/, getFormData()];
                                case 5:
                                    _a = _b.sent(), formData = _a.formData, hasFiles = _a.hasFiles, json = _a.json;
                                    isJson = !!json;
                                    if (!formData && !isJson) {
                                        if (requireModel) {
                                            ConsoleLogger_8.logError(formId, "Form submission cancelled because a model is required to continue.");
                                            return [2 /*return*/, false];
                                        }
                                        else {
                                            formData = new FormData(form);
                                            hasFiles = Utils_8.containsFiles(form);
                                        }
                                    }
                                    if (!isJson && this.clearFilesAppendProcessed(formId, formData))
                                        hasFiles = true;
                                    xhr = new XMLHttpRequest();
                                    xhr.onreadystatechange = function () {
                                        if (this.readyState === XHRSTATE.DONE) {
                                            // any status code between 200 and 299 inclusive is success
                                            if (this.status > 199 && this.status < 300) {
                                                if (Utils_8._isFunction(done))
                                                    done.call(this);
                                            }
                                            else if (Utils_8._isFunction(fail)) {
                                                fail.call(this);
                                            }
                                        }
                                    };
                                    this.addXHRUploadEventListeners(formId, xhr, hasFiles);
                                    url = form.getAttribute("action") || global.location.href;
                                    method = (form.getAttribute("method") || "POST").toUpperCase();
                                    ConsoleLogger_8.logDebug(formId, "Form action URL and method are:", url, method);
                                    xhr.open(method, url, true);
                                    headersSet = false;
                                    if (!Utils_8._isFunction(beforeSend)) return [3 /*break*/, 7];
                                    return [4 /*yield*/, beforeSend.call(xhr)];
                                case 6:
                                    xhrResult = _b.sent();
                                    ConsoleLogger_8.logDebug(formId, "beforeSend was called:", xhrResult);
                                    if (Utils_8._isObject(xhrResult)) {
                                        if (xhrResult.cancel) {
                                            ConsoleLogger_8.logDebug(formId, "XMLHttpRequest.send was cancelled.");
                                            return [2 /*return*/, false];
                                        }
                                        ConsoleLogger_8.logDebug(formId, "Trying to set XMLHttpRequest (XHR) properties...");
                                        try {
                                            headersSet = this.setRequestHeaders(formId, xhr, xhrResult.requestHeaders);
                                            xhr.withCredentials = xhrResult.withCredentials;
                                        }
                                        catch (e) {
                                            ConsoleLogger_8.logError(formId, "Error setting XHR properties.", e);
                                            if (Utils_8._isFunction(fail))
                                                fail.call(xhr, e.message);
                                            return [2 /*return*/, false];
                                        }
                                    }
                                    _b.label = 7;
                                case 7:
                                    if (!headersSet && Shared_8.Forms[formId])
                                        this.setRequestHeaders(formId, xhr, Shared_8.Forms[formId].requestHeaders);
                                    if (isJson) {
                                        this.setRequestHeaders(formId, xhr, { 'content-type': 'application/json', accept: 'application/json; text/plain' });
                                    }
                                    ConsoleLogger_8.logDebug(formId, "Adjusting bad form data keys.");
                                    objData = this.adjustBadFormDataKeys(formData || json);
                                    if (this.reCaptcha) {
                                        ConsoleLogger_8.logDebug(formId, "Submitting form using reCAPTCHA.");
                                        this.reCaptcha.submitForm(formId, xhr, objData, reCaptcha);
                                    }
                                    else {
                                        ConsoleLogger_8.logDebug(formId, "Submitting form using XMLHttpRequest.");
                                        xhr.send(objData);
                                    }
                                    return [2 /*return*/, false]; // To avoid actual submission of the form
                            }
                        });
                    }); };
                    return true;
                };
                BlazorFormManager.prototype.deleteProcessedFileList = function (options) {
                    return this.fileManager.deleteProcessedFileList(options);
                };
                BlazorFormManager.prototype.dragDropEnable = function (options) {
                    return this.dragdropManager.enable(options);
                };
                BlazorFormManager.prototype.dragDropDisable = function (options) {
                    return this.dragdropManager.disable(options);
                };
                BlazorFormManager.prototype.dragDropRemoveFileList = function (options) {
                    return Utils_8.removeFileList(options);
                };
                BlazorFormManager.prototype.dragDropInputFilesOnTarget = function (options) {
                    return this.dragdropManager.dragDropInputFilesOnTarget(options);
                };
                BlazorFormManager.prototype.filterKeys = function (options) {
                    return DomEventManager_3.filterKeys(options);
                };
                BlazorFormManager.prototype.addEventListener = function (targetId, eventType, callback) {
                    return DomEventManager_3.addEventListener(targetId, eventType, callback);
                };
                /**
                 * Remove an event listener from a target element identified by 'targetId'.
                 * @param targetId The identifier of the target element.
                 * @param eventType The type of event to remove the listener for.
                 */
                BlazorFormManager.prototype.removeEventListener = function (targetId, eventType) {
                    return DomEventManager_3.removeEventListener(targetId, eventType);
                };
                /**
                 * Set request headers on the specified XMLHttpRequest object.
                 * @param formId The form identifier.
                 * @param xhr The XMLHttpRequest object.
                 * @param headers A collection of key=value pairs.
                 */
                BlazorFormManager.prototype.setRequestHeaders = function (formId, xhr, headers) {
                    if (!Utils_8._isDictionary(headers))
                        return false;
                    ConsoleLogger_8.logDebug(formId, "Setting request headers...");
                    for (var name_1 in headers) {
                        if (headers.hasOwnProperty(name_1)) {
                            var value = headers[name_1];
                            ConsoleLogger_8.logDebug(formId, "Header:", { name: name_1, value: value });
                            xhr.setRequestHeader(name_1, value);
                        }
                    }
                    return true;
                };
                /** Return the dictionary of registered form manager options. */
                BlazorFormManager.prototype.getForms = function () {
                    return Shared_8.Forms;
                };
                BlazorFormManager.supportsImageUtil = function () {
                    // before checking for the ImageUtility class, which uses the 
                    // <canvas> element, make sure first that the device supports canvas
                    return !!window.CanvasRenderingContext2D;
                };
                /**
                 * Invoke dotnet method 'onAjaxUploadWithProgressNotSupported'.
                 * @param formId The form identifier.
                 */
                BlazorFormManager.prototype.raiseAjaxUploadWithProgressNotSupported = function (formId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var cancel, onAjaxUploadWithProgressNotSupported, navigatorInfo;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    cancel = false;
                                    if (!Shared_8.Forms[formId]) return [3 /*break*/, 2];
                                    onAjaxUploadWithProgressNotSupported = Shared_8.Forms[formId].onAjaxUploadWithProgressNotSupported;
                                    if (!Utils_8._isString(onAjaxUploadWithProgressNotSupported)) return [3 /*break*/, 2];
                                    navigatorInfo = {};
                                    Utils_8.populateDictionary(navigatorInfo, global.navigator);
                                    ConsoleLogger_8.logDebug(formId, "Navigator properties collected", navigatorInfo);
                                    return [4 /*yield*/, this.invokeDotNet(formId, onAjaxUploadWithProgressNotSupported, { extraProperties: navigatorInfo })];
                                case 1:
                                    cancel = _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/, cancel];
                            }
                        });
                    });
                };
                /**
                 * Read input files using the specified options.
                 * @param options
                 */
                BlazorFormManager.prototype.readInputFiles = function (options) {
                    var _this_1 = this;
                    return this.fileManager.readInputFiles(options, function (processedFiles) {
                        var formId = options.formId, inputId = options.inputId, inputName = options.inputName;
                        ConsoleLogger_8.logDebug(formId, "Received processed files.");
                        if (processedFiles && processedFiles.length > 0) {
                            ConsoleLogger_8.logDebug(formId, "Storing processed files...");
                            // store files that have been processed so that they can be 
                            // used later to validate when the form is being submitted
                            var config = _this_1.processedFileStorage[formId];
                            if (!config) {
                                // create the configuration and store it
                                config = {
                                    inputs: []
                                };
                                _this_1.processedFileStorage[formId] = config;
                            }
                            var input = config.inputs.find(function (obj) { return obj.id === inputId; });
                            // update the configuration
                            if (!input) {
                                config.inputs.push({
                                    id: inputId,
                                    name: inputName,
                                    files: processedFiles
                                });
                                ConsoleLogger_8.logDebug(formId, "Created processed files configuration.");
                            }
                            else {
                                input.files = processedFiles;
                                ConsoleLogger_8.logDebug(formId, "Updated processed files configuration.");
                            }
                        }
                        else {
                            ConsoleLogger_8.logDebug(formId, "No files processed!");
                        }
                    });
                };
                /**
                 * Invoke a .NET method.
                 * @param formId The form identifier.
                 * @param method The .NET method to invoke.
                 * @param arg The argument to the .NET method to invoke.
                 */
                BlazorFormManager.prototype.invokeDotNet = function (formId, method, arg) {
                    if (arg === undefined)
                        arg = null;
                    var obj = (Shared_8.Forms[formId] || {}).dotNetObjectReference;
                    if (obj) {
                        //logDebug(formId, `Invoking .NET method "${method}" using object instance.`, arg);
                        return obj.invokeMethodAsync(method, arg);
                    }
                    else if (dotNet && Shared_8.AssemblyName) {
                        //logDebug(formId, `Invoking .NET method "${method}" using static type`, arg);
                        return dotNet.invokeMethodAsync(Shared_8.AssemblyName, method, arg);
                    }
                    ConsoleLogger_8.logWarning(formId, 'No DotNetObjectReference nor static .NET interop reference defined!');
                    return _resolvedPromise;
                };
                /**
                 * Reset previously created reCAPTCHA widgets for the specfified form.
                 * @param formId The form identifier.
                 * @param options The reCAPTCHA options.
                 */
                BlazorFormManager.prototype.resetRecaptcha = function (formId, options) {
                    ConsoleLogger_8.logDebug(formId, 'resetting reCAPTCHA', options);
                    var recap = this.reCaptcha;
                    recap && recap.reset(formId, options);
                };
                /**
                 *
                 * Reconfigure the reCAPTCHA for the specified form identifier.
                 * @param formId The form identifier.
                 * @param options The configuration options.
                 */
                BlazorFormManager.prototype.reConfigureRecaptcha = function (formId, options) {
                    ConsoleLogger_8.logDebug(formId, 'Reconfiguring reCAPTCHA', options);
                    var recap = this.reCaptcha;
                    recap && recap.configure(formId, options, true);
                };
                /**
                 * Uniquely insert one or more CSS styles into the DOM.
                 * @param formId The form identifier.
                 * @param styles A string or array of styles to insert.
                 */
                BlazorFormManager.prototype.insertDomStyles = function (formId, styles) {
                    return Utils_8.insertStyles(styles, null, formId);
                };
                /**
                 * Uniquely insert one or more scripts into the DOM.
                 * @param formId The form identifier.
                 * @param scripts A string or array of scripts to insert.
                 * @param isAsync Sets the script's async property.
                 * @param isDeferred Sets the scripts defer property.
                 */
                BlazorFormManager.prototype.insertDomScripts = function (formId, scripts, isAsync, isDeferred) {
                    return Utils_8.insertScripts(scripts, null, formId, isAsync, isDeferred);
                };
                BlazorFormManager.prototype.initQRCode = function (formId, script, onload) {
                    ConsoleLogger_8.logDebug(formId, 'Loading QRCode script...', script);
                    script || (script = "https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js");
                    onload || (onload = function () { return ConsoleLogger_8.logDebug(formId, 'Done.'); });
                    return Utils_8.insertScripts(script, onload, formId);
                };
                BlazorFormManager.prototype.generateQRCode = function (formId, selector, value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var qrCode, elm_1, QRCode_1, loadQRCode, success;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    qrCode = (Shared_8.Forms[formId] || (Shared_8.Forms[formId] = { formId: formId })).qrCode;
                                    if (!qrCode) return [3 /*break*/, 1];
                                    qrCode.delegate.clear();
                                    ConsoleLogger_8.logDebug(formId, 'QRCode cleared.');
                                    if (value) {
                                        qrCode.delegate.makeCode(value);
                                        ConsoleLogger_8.logDebug(formId, 'Generated new QRCode.');
                                    }
                                    return [2 /*return*/, true];
                                case 1:
                                    if (!value) return [3 /*break*/, 6];
                                    elm_1 = document.querySelector(selector);
                                    if (!elm_1) return [3 /*break*/, 5];
                                    QRCode_1 = window["QRCode"];
                                    loadQRCode = function () {
                                        qrCode = { delegate: new QRCode_1(elm_1, value), selector: selector };
                                        Shared_8.Forms[formId].qrCode = qrCode;
                                        ConsoleLogger_8.logDebug(formId, "QRCode generated successfully for text ".concat(value, "."));
                                    };
                                    if (!!QRCode_1) return [3 /*break*/, 3];
                                    ConsoleLogger_8.logDebug(formId, 'QRCode not initialized, loading default script...');
                                    return [4 /*yield*/, this.initQRCode(formId)];
                                case 2:
                                    success = _a.sent();
                                    if (success) {
                                        ConsoleLogger_8.logDebug(formId, 'Done.');
                                        QRCode_1 = window["QRCode"];
                                        loadQRCode();
                                    }
                                    else {
                                        ConsoleLogger_8.logError(formId, 'Could not initialize the default QRCode script.');
                                    }
                                    return [3 /*break*/, 4];
                                case 3:
                                    loadQRCode();
                                    _a.label = 4;
                                case 4: return [2 /*return*/, true];
                                case 5:
                                    ConsoleLogger_8.logError(formId, "generateQRCode: No DOM element matches the selector '".concat(selector, "'."));
                                    _a.label = 6;
                                case 6: return [2 /*return*/, false];
                            }
                        });
                    });
                };
                BlazorFormManager.prototype.destroyQrCode = function (formId) {
                    var qrCode = Shared_8.Forms[formId].qrCode;
                    if (qrCode) {
                        var delegate = qrCode.delegate, selector = qrCode.selector;
                        delegate.clear();
                        delete Shared_8.Forms[formId].qrCode;
                        ConsoleLogger_8.logDebug(formId, "The QRCode identified by ".concat(selector, " has been destroyed!"));
                    }
                };
                /** Determines whether an environment supports asynchronous form submissions with file upload progress events. */
                BlazorFormManager.supportsAjaxUploadWithProgress = function () {
                    return supportsFileAPI() &&
                        supportsAjaxUploadProgressEvents() &&
                        supportsFormData();
                    function supportsFileAPI() {
                        var fi = document.createElement("INPUT");
                        fi.type = "file";
                        return "files" in fi;
                    }
                    ;
                    function supportsAjaxUploadProgressEvents() {
                        var xhr = "XMLHttpRequest" in globalThis && new XMLHttpRequest();
                        return !!(xhr && ("upload" in xhr) && ("onprogress" in xhr.upload));
                    }
                    ;
                    function supportsFormData() {
                        return !!global.FormData;
                    }
                };
                BlazorFormManager.prototype.validateFormAttributes = function (formId) {
                    var frm = document.getElementById(formId);
                    if (!frm) {
                        ConsoleLogger_8.logWarning(formId, "The form element identified by '".concat(formId, "' does not exist in the DOM."));
                        return false;
                    }
                    return true;
                };
                BlazorFormManager.prototype.addXHRUploadEventListeners = function (formId, xhr, hasFiles) {
                    var onUploadChanged = Shared_8.Forms[formId].onUploadChanged;
                    if (!Utils_8._isString(onUploadChanged))
                        return;
                    ConsoleLogger_8.logDebug(formId, "Setting up upload event handlers...");
                    this.fileManager.addFileReaderOrUploadEventListeners(formId, xhr, xhr.upload, onUploadChanged, hasFiles, null);
                };
                BlazorFormManager.prototype.initReCaptcha = function (formId, reCaptcha, onReCaptchaActivity) {
                    var _this_1 = this;
                    if (Utils_8._isObject(reCaptcha)) {
                        var recap = this.reCaptcha;
                        if (!recap) {
                            recap = new ReCAPTCHA_1.ReCAPTCHA();
                            recap.activity.subscribe(function (activity) {
                                _this_1.invokeDotNet(activity.formId, onReCaptchaActivity, activity);
                            });
                            this.reCaptcha = recap;
                        }
                        recap.configure(formId, reCaptcha);
                    }
                    return this.reCaptcha;
                };
                BlazorFormManager.showOptionsUsage = function (isError) {
                    var optionalNameOfMethodWhen = "string (optional): The name of the .NET method to invoke when ";
                    var options = {
                        formId: "string (required): The unique identifier of the form to submit.",
                        requireModel: "boolean (optional): Gets or sets a value that indicates whether specifying a " +
                            "non-null reference model is required when the 'onGetModel' event is invoked. If this value is " +
                            "true and no valid model is provided after that event, the form submission will be cancelled.",
                        enhancedLoad: "boolean (optional): Gets or sets a value that indicates whether to react to a Blazor Server App's 'enhanceload' event. This parameter allows resetting up specific aspects of the form, such as reinitializing the reCaptcha options.",
                        onEnhancedLoad: optionalNameOfMethodWhen + "a Blazor Server App's 'enhancedLoad' event occurs.",
                        assembly: "string (optional): The name of the .NET assembly on which " +
                            "to invoke static methods. Required if any of the 'onXXX' static " +
                            "method names are set.",
                        logLevel: "number (optional): The level of details when logging messages " +
                            "to the console. Supported values are: 0 (none), 1 (information), " +
                            "2 (warning), 3 (error), 4 (debug). The default is 3.",
                        requestHeaders: "object (optional): A dictionary of key-value pairs to set on an instance of XMLHttpRequest.",
                        reCaptcha: "object (optional): An object that encapsulates configuration settings for Google's reCAPTCHA technology.",
                        onGetModel: optionalNameOfMethodWhen + "retrieving the form model.",
                        onBeforeSubmit: optionalNameOfMethodWhen + "submitting the form. This event can be cancelled.",
                        onBeforeSend: optionalNameOfMethodWhen + "sending the HTTP request. This event can be cancelled.",
                        onSendFailed: optionalNameOfMethodWhen + "the HTTP request fails.",
                        onSendSucceeded: optionalNameOfMethodWhen + "the HTTP request completes successfully.",
                        onUploadChanged: optionalNameOfMethodWhen + "an upload operation occurs.",
                        onFileReaderChanged: optionalNameOfMethodWhen + "a change occurs in a file reading operation.",
                        onFileReaderResult: optionalNameOfMethodWhen + "a file reading operation is completed successfully.",
                        onReCaptchaActivity: optionalNameOfMethodWhen + "a Google reCAPTCHA activity is reported.",
                        onAjaxUploadWithProgressNotSupported: optionalNameOfMethodWhen + "the browser does not support AJAX uploads with progress report.",
                    };
                    var message = "Initialization options must be a variation of the following format:";
                    var formId = undefined;
                    if (isError)
                        ConsoleLogger_8.logError(formId, message, options);
                    else
                        ConsoleLogger_8.logInfo(formId, message, options);
                    return false;
                };
                BlazorFormManager.objectFromEntries = function (data, fallback) {
                    //const obj: any = Object;
                    //const json = JSON.stringify(obj.fromEntries && obj.fromEntries(new FormData(form)) || model)
                    //    .replace('"true"', 'true')
                    //    .replace('"false"', 'false');
                    var obj = Object;
                    return JSON.stringify(obj.fromEntries && obj.fromEntries(data) || fallback || {})
                        .replace('"true"', 'true')
                        .replace('"false"', 'false');
                };
                /**
                 * Collect all processed (approved) files before submitting the form.
                 * @param formId The form identifier.
                 */
                BlazorFormManager.prototype.collectFilesOnFormSubmit = function (formId) {
                    return this.collectInputFiles(formId).concat(this.dragdropManager.collectFiles(formId));
                };
                /**
                 * Collect all input files found in the specified form identifier.
                 * @param formId The form identifier.
                 */
                BlazorFormManager.prototype.collectInputFiles = function (formId) {
                    var config = this.processedFileStorage[formId];
                    if (!config) {
                        ConsoleLogger_8.logDebug(formId, "No processed files found for form #" + formId);
                        return [];
                    }
                    var inputs = config.inputs;
                    var collected = [];
                    for (var i = 0; i < inputs.length; i++) {
                        var _a = inputs[i], name_2 = _a.name, files = _a.files;
                        for (var k = 0; k < files.length; k++) {
                            collected.push({
                                name: name_2,
                                value: files[k]
                            });
                        }
                    }
                    return collected;
                };
                /**
                 * Make sure that only successfully processed files are submitted with the form data.
                 * @param formId The form identifier.
                 * @param formData The form data to check.
                 */
                BlazorFormManager.prototype.clearFilesAppendProcessed = function (formId, formData) {
                    if (!formId || !formData) {
                        ConsoleLogger_8.logError(formId, "formId and formData parameters must be set when validating processed files.");
                        return false;
                    }
                    ConsoleLogger_8.logDebug(formId, "Validating processed files on form submit");
                    // get processed files...
                    var processedFiles = this.collectFilesOnFormSubmit(formId);
                    var hasFiles = processedFiles.length > 0;
                    if (hasFiles) {
                        this.clearFormDataFiles(formId, formData);
                    }
                    // ... and append them
                    processedFiles.forEach(function (_a) {
                        var name = _a.name, file = _a.value;
                        formData.append(name, file, file.name);
                    });
                    return hasFiles;
                };
                /**
                 * Remove all files from the specified form data.
                 * @param formId The form identifier.
                 * @param formData The form data to clear.
                 */
                BlazorFormManager.prototype.clearFormDataFiles = function (formId, formData) {
                    if (!formData)
                        return false;
                    // first, grab the keys to avoid deleting 
                    // entries from the formData while enumerating
                    var keys = Utils_8.formDataKeys(formData);
                    ConsoleLogger_8.logDebug(formId, "Removing all files from form data; keys are: ", keys);
                    var success = false;
                    // delete all files
                    for (var i = 0; i < keys.length; i++) {
                        var entry = formData.get(keys[i]);
                        if (entry instanceof File) {
                            formData.delete(keys[i]);
                            success = true;
                        }
                    }
                    return success;
                };
                /**
                 * Remove inappropriate data keys.
                 * @param data The data to clean up.
                 */
                BlazorFormManager.prototype.adjustBadFormDataKeys = function (data) {
                    var RVT_KEY1 = '__RequestVerificationToken';
                    var RVT_KEY2 = 'requestVerificationToken';
                    if (data instanceof FormData) {
                        var rvt1 = data.get(RVT_KEY1);
                        var rvt2 = data.get(RVT_KEY2);
                        if (!Utils_8._isString(rvt1))
                            data.set(RVT_KEY1, rvt2);
                        data.delete(RVT_KEY2);
                        return data;
                    }
                    else {
                        var json = JSON.parse(data);
                        var rvt1 = json[RVT_KEY1];
                        var rvt2 = json[RVT_KEY2];
                        if (!Utils_8._isString(rvt1))
                            json[RVT_KEY1] = rvt2;
                        delete json[RVT_KEY2];
                        return JSON.stringify(json);
                    }
                };
                /**
                 * Recursively append to the specified form data properties and values from the given model.
                 * @param model The model from which to collect form data.
                 * @param formData The FormData object to which collected values are appended.
                 * @param path The current navigation path to a given property of the model.
                 */
                BlazorFormManager.prototype.collectModelData = function (model, formData, path) {
                    var _this_1 = this;
                    if (Utils_8._isObject(model) && !(model instanceof Date) && !(model instanceof File) && !(model instanceof Blob)) {
                        Object.keys(model).forEach(function (key) {
                            _this_1.collectModelData(model[key], formData, path ? "".concat(path, "[").concat(key, "]") : key);
                        });
                    }
                    else {
                        var value = (model === null || model === undefined) ? null : model;
                        if (model !== null)
                            formData.append(path, value);
                    }
                };
                BlazorFormManager.prototype.raiseFormSubmitted = function (formId) {
                    ConsoleLogger_8.logWarning(formId, 'raiseFormSubmitted not implemented!');
                };
                BlazorFormManager.prototype._enableEnhancedLoad = function (formId, enabled, dotnetMethodName) {
                    var _this_1 = this;
                    var Blazor = global['Blazor'];
                    if (Blazor && Blazor.addEventListener) {
                        if (enabled) {
                            if (!this._enhancedLoadEventEnabled) {
                                Blazor.addEventListener('enhancedload', function () {
                                    ConsoleLogger_8.logDebug(formId, 'enhancedload occurred!');
                                    // the method must be static
                                    // dotNet.invokeMethodAsync(AssemblyName, dotnetMethodName, window.location.href);
                                    setTimeout(function () { return __awaiter(_this_1, void 0, void 0, function () {
                                        var sessionStorageKey, stored;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    if (!(this.reCaptcha && this.reCaptcha.requiresReCaptcha())) return [3 /*break*/, 3];
                                                    sessionStorageKey = (Shared_8.Forms[formId] || {}).sessionStorageKey;
                                                    if (!Utils_8._isString(sessionStorageKey)) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, this.storeFormData(formId, sessionStorageKey)];
                                                case 1:
                                                    stored = _a.sent();
                                                    ConsoleLogger_8.logDebug(formId, 'Storing form data', stored);
                                                    _a.label = 2;
                                                case 2:
                                                    window.location.reload();
                                                    _a.label = 3;
                                                case 3: return [2 /*return*/];
                                            }
                                        });
                                    }); }, 1000);
                                });
                                this._enhancedLoadEventEnabled = true;
                                ConsoleLogger_8.logDebug(formId, 'Blazor enhancedload event enabled.');
                            }
                        }
                        else {
                            if (Blazor.removeEventListener) {
                                Blazor.removeEventListener('enhancedload');
                                ConsoleLogger_8.logDebug(formId, 'Blazor enhancedload event disabled.');
                            }
                            this._enhancedLoadEventEnabled = false;
                        }
                    }
                    else {
                        ConsoleLogger_8.logWarning(formId, '"enhanceload" event not supported: No global Blazor object found.');
                    }
                };
                BlazorFormManager._supportsAJAXwithUpload = BlazorFormManager.supportsAjaxUploadWithProgress();
                return BlazorFormManager;
            }());
            exports_13("BlazorFormManager", BlazorFormManager);
            (function () {
                var blazorFormManager = new BlazorFormManager();
                Object.defineProperty(global, 'BlazorFormManager', { value: blazorFormManager });
                // define immutable properties
                Object.defineProperty(blazorFormManager, 'QuillEditor', { value: QuillEditor_1.QuillEditor });
                Object.defineProperty(blazorFormManager, 'Quill', { value: {} });
                Object.defineProperty(blazorFormManager['Quill'], 'create', {
                    /**
                    * Create a new QuillEditor instance.
                    * @param {string} selector A DOM query selector.
                    * @param {any} options The options.
                    */
                    value: function (selector, options) {
                        var editor = new QuillEditor_1.QuillEditor(selector, options);
                        return editor;
                    }
                });
                Object.defineProperty(blazorFormManager['Quill'], 'getInnerHTML', {
                    value: function (editor) {
                        return editor.getInnerHTML();
                    }
                });
                Object.defineProperty(blazorFormManager, 'ChartjsHelper', { value: ChartjsHelper_1.ChartjsHelper });
            })();
        }
    };
});
//# sourceMappingURL=bundle.js.map